<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Quantum information with polarized light &#8212; Practical Quantum Computing for Scientists 2022.02.24 alpha documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/sphinx_highlight.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../../../../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../../../../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../../../_static/bootstrap-sphinx.js"></script>

  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default ">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../../index.html">
          Practical QC for Scientists</a>
        <span class="navbar-text navbar-version pull-left"><b>2022.02.24</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../index.html">437</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../../index.html">Contents <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Courses</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../index.html">PHYS 437</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../PHYS710/index.html">PHYS 710</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../archives/archives.html">Archives</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../help/index.html">HOWTOs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../help/IBM_quantum.html">Using IBM quantum Cloud</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <section class="tex2jax_ignore mathjax_ignore" id="quantum-information-with-polarized-light">
<h1>Quantum information with polarized light<a class="headerlink" href="#quantum-information-with-polarized-light" title="Permalink to this heading">¶</a></h1>
<p><em>Author: Nicolás Quesada</em></p>
<p>In this tutorial we will explore how to model quantum photonic
experiments involving “internal” degrees of freedom of light, such as
polarization. Note that by default Strawberry Fields deals with
qumodes without an explicit commitment to what degree of freedom those
qumodes correspond to. Using polarization degrees of freedom allows us
to encode quantum information more densely. For example, one can use
the two orthogonal polarizations of a single photon to encode a single qubit.</p>
<p>Polarization is the ability of fields to oscillate in more than one
direction as they propagate. One can think of light as a transverse
field, meaning that it does not oscillate in the direction of
propagation. This implies that in our three-dimensional world light has
two directions in which it can oscillate that are perpendicular to its direction of propagation.
Because of this, a photon propagating in a certain direction <span class="math notranslate nohighlight">\(k\)</span>
can have two orthogonal polarizations. This is schematically shown below:</p>
<p><img alt="" src="../../../../_images/polarization.png" /></p>
<p>In this tutorial, we will show how polarization “gates” implemented by half-wave plates
and polarizing beamsplitters can be mapped into the usual quantum
operations from Strawberry Fields. Then we will use this knowledge to simulate the generation
of a maximally entangled Bell state encoded in polarization degrees of
freedom.</p>
<section id="manipulating-polarization-degrees-of-freedom">
<h2>Manipulating polarization degrees of freedom<a class="headerlink" href="#manipulating-polarization-degrees-of-freedom" title="Permalink to this heading">¶</a></h2>
<p>It turns out that the polarization degree of freedom of photons can be used
to encode information, and this information is typically manipulated
using so-called half-wave plates and polarizing beamsplitters.</p>
<section id="half-wave-plates">
<h3>Half-wave plates<a class="headerlink" href="#half-wave-plates" title="Permalink to this heading">¶</a></h3>
<p>A half-wave plate (HWP) allows us to rotate the polarization of a photon. For
example,</p>
<div class="amsmath math notranslate nohighlight" id="equation-7cf2c7ed-552a-4da1-af24-93efb44eff15">
<span class="eqno">(1)<a class="headerlink" href="#equation-7cf2c7ed-552a-4da1-af24-93efb44eff15" title="Permalink to this equation">¶</a></span>\[\begin{align}\text{HWP} |1_H 0_V \rangle &amp;= \frac{1}{\sqrt{2}} \left( |1_H 0_V \rangle + |0_H 1_V \rangle \right), \quad \text{(A)}\\
    \text{HWP} |0_H 1_V \rangle &amp;= \frac{1}{\sqrt{2}} \left( |1_H 0_V \rangle - |0_H 1_V \rangle \right), \quad \text{(B)}\end{align}\]</div>
<p>where <span class="math notranslate nohighlight">\(\text{HWP}\)</span> is a unitary operator representing
a half-wave plate, <span class="math notranslate nohighlight">\(|1_H \rangle\)</span> is a single horizontally-polarized photon
and, similarly, <span class="math notranslate nohighlight">\(|1_V \rangle\)</span> is a single vertically-polarized photon
The states in the right hand sides of the last
equation can be understood as single photons polarized along the diagonal
(<span class="math notranslate nohighlight">\(+45^\circ\)</span>) and antidiagonal (<span class="math notranslate nohighlight">\(-45^\circ\)</span>) directions, as depicted below:</p>
<p><img alt="" src="../../../../_images/HWP.png" /></p>
<p>The transformation above is written in the Schrödinger picture for
single photon inputs. It is often more fruitful to write it in the
Heisenberg picture as follows:</p>
<div class="amsmath math notranslate nohighlight" id="equation-10d1e1ab-8bcd-4954-a013-ac390a923514">
<span class="eqno">(2)<a class="headerlink" href="#equation-10d1e1ab-8bcd-4954-a013-ac390a923514" title="Permalink to this equation">¶</a></span>\[\begin{align}\text{HWP} ^\dagger a_H^\dagger \text{HWP} &amp;= \frac{1}{\sqrt{2}}\left( a_H^\dagger + a_V^\dagger \right),\\
    \text{HWP} ^\dagger a_V^\dagger \text{HWP} &amp;= \frac{1}{\sqrt{2}}\left( a_H^\dagger - a_V^\dagger \right),\end{align}\]</div>
<p>where we transformed the creation operators <span class="math notranslate nohighlight">\(a_{H/V}^\dagger\)</span> of the modes.</p>
</section>
<section id="polarizing-beamsplitters">
<h3>Polarizing beamsplitters<a class="headerlink" href="#polarizing-beamsplitters" title="Permalink to this heading">¶</a></h3>
<p>A polarizing beamsplitter (PBS) will transmit light of a certain
polarization while reflecting light from the orthogonal polarization.
This operation acts on two paths each having two polarizations. For two
spatial modes with two polarizations (a total of <span class="math notranslate nohighlight">\(4 = 2 \times 2\)</span>
creation operators) we can write its Heisenberg action as</p>
<div class="amsmath math notranslate nohighlight" id="equation-df6d6f27-1683-487b-8f08-6ec0d26b8315">
<span class="eqno">(3)<a class="headerlink" href="#equation-df6d6f27-1683-487b-8f08-6ec0d26b8315" title="Permalink to this equation">¶</a></span>\[\begin{align}\text{PBS}^\dagger a_{1,H}^\dagger \text{PBS} &amp;= a_{1,H}^\dagger, \quad \text{(a)}\\
   \text{PBS}^\dagger a_{1,V}^\dagger \text{PBS} &amp;= a_{2,V}^\dagger, \quad \text{(b)}\\
   \text{PBS}^\dagger a_{2,H}^\dagger \text{PBS} &amp;= a_{2,H}^\dagger, \quad \text{(c)}\\
   \text{PBS}^\dagger a_{2,V}^\dagger \text{PBS} &amp;= a_{1,V}^\dagger. \quad \text{(d)}\end{align}\]</div>
<p>Note that the horizontal polarizations of both modes are
unaffected (they are “transmitted”) and that the vertical polarizations
are swapped (they are “reflected”). The action of the PBS is schematically shown below
for the different path and polarization modes:</p>
<p><img alt="" src="../../../../_images/PBS.png" /></p>
<p>We can use a PBS to separate two photons with orthogonal polarizations
in the same path into two photons in different paths:</p>
<div class="amsmath math notranslate nohighlight" id="equation-77157a5a-6bc2-4c06-bc8b-1751a9b227f3">
<span class="eqno">(4)<a class="headerlink" href="#equation-77157a5a-6bc2-4c06-bc8b-1751a9b227f3" title="Permalink to this equation">¶</a></span>\[\begin{align}\text{PBS}|1_H 1_V, 0_H 0_V \rangle = |1_H 0_V, 0_H 1_V \rangle,\end{align}\]</div>
<p>where we used the notation <span class="math notranslate nohighlight">\(|x_H y_V,a_H b_V \rangle\)</span>
to indicate <span class="math notranslate nohighlight">\(x\)</span> (<span class="math notranslate nohighlight">\(y\)</span>) horizontal (vertical) photons in mode
1, <span class="math notranslate nohighlight">\(a\)</span> (<span class="math notranslate nohighlight">\(b\)</span>) horizontal (vertical) photons in mode 2.</p>
</section>
</section>
<section id="mapping-to-strawberry-fields-gates">
<h2>Mapping to Strawberry Fields gates<a class="headerlink" href="#mapping-to-strawberry-fields-gates" title="Permalink to this heading">¶</a></h2>
<p>With the notation we developed above we are ready to simulate basic
polarization optical primitives using Strawberry Fields. We simply need
to recall that each optical path with two polarizations can be
represented using 2 qumodes.
For each path <span class="math notranslate nohighlight">\(i\)</span>, we associate qumodes <span class="math notranslate nohighlight">\(2i\)</span> and <span class="math notranslate nohighlight">\(2i+1\)</span> to its horizontal and vertical polarization respectively.</p>
<p>We can the associate Strawberry Fields gates with the polarization primitives discussed
above as follows:</p>
<div class="amsmath math notranslate nohighlight" id="equation-6353bde8-f476-43c5-9243-947ce2e6fb2a">
<span class="eqno">(5)<a class="headerlink" href="#equation-6353bde8-f476-43c5-9243-947ce2e6fb2a" title="Permalink to this equation">¶</a></span>\[\begin{align}\text{HWP}_i &amp;\leftrightarrow \text{BSgate}_{2i,2i+1}\\
   \text{PBS}_{i,j} &amp;\leftrightarrow \text{Permute}_{2i+1,2j+1} = \text{Interferometer}\left(\left[\begin{smallmatrix} 0&amp;1 \\1&amp;0 \end{smallmatrix} \right]\right)_{2i+1,2j+1}\end{align}\]</div>
<p>To see why the first association is true recall that a
HWP maps the creation operators of two polarizations in the same path to
linear combinations of the same operators, which is precisely what the
<code class="docutils literal notranslate"><span class="pre">BSgate</span></code> does when applied to modes <span class="math notranslate nohighlight">\(2i\)</span> and <span class="math notranslate nohighlight">\(2i+1\)</span>
representing the two orthogonal polarizations of path <span class="math notranslate nohighlight">\(i\)</span>.</p>
<p>To understand the second expression recall that a
<span class="math notranslate nohighlight">\(\text{PBS}\)</span> simply swaps the vertical polarization of the two
paths, which correspond precisely to qumodes <span class="math notranslate nohighlight">\(2i+1\)</span> and
<span class="math notranslate nohighlight">\(2j+1\)</span>. Finally, note that a swap is readily implemented in Strawberry Fields by
using the <code class="docutils literal notranslate"><span class="pre">Interferometer</span></code> gate with argument
<span class="math notranslate nohighlight">\(\left[\begin{smallmatrix} 0&amp;1 \\1&amp;0 \end{smallmatrix} \right]\)</span>.</p>
</section>
<section id="simulating-the-generation-of-event-ready-photon-pairs">
<h2>Simulating the generation of event-ready photon pairs<a class="headerlink" href="#simulating-the-generation-of-event-ready-photon-pairs" title="Permalink to this heading">¶</a></h2>
<p>Zhang et al. [[#zhang]_] propose a method for generating postselected photonic maximally
entangled Bell states by using single photons input into an
interferometer. Their method uses a 4 spatial-path interferometer where
each path takes advantage of the two polarizations (vertical and
horizontal) of a photon. The circuit starts with four horizontal photons
in each of the paths and then proceeds as shown below</p>
<p><img alt="" src="../../../../_images/circuit_path.png" /></p>
<p>Conditioned in two of the detectors collecting a single photon each and
the other two measuring vacuum, Zhang et al. show that the state of
modes 1 and 4 collapses to a two-photon maximally entangled Bell
state of the form</p>
<div class="amsmath math notranslate nohighlight" id="equation-c06d097f-2fc7-4aeb-856f-1a044f1edf9d">
<span class="eqno">(6)<a class="headerlink" href="#equation-c06d097f-2fc7-4aeb-856f-1a044f1edf9d" title="Permalink to this equation">¶</a></span>\[\begin{align}|\phi^+ \rangle \propto \left( |1_H 0_V, 1_H 0_V \rangle + |0_H 1_V, 0_H 1_V \rangle \right).\end{align}\]</div>
<p>With the rules established in the last section we can translate the
2-polarization 4-path circuit into a circuit with 8 qumodes as shown below</p>
<p>We are now ready to do the simulations!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import and preliminaries</span>
<span class="kn">import</span> <span class="nn">strawberryfields</span> <span class="k">as</span> <span class="nn">sf</span>
<span class="kn">from</span> <span class="nn">strawberryfields.ops</span> <span class="kn">import</span> <span class="n">Ket</span><span class="p">,</span> <span class="n">BSgate</span><span class="p">,</span> <span class="n">Interferometer</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">cutoff_dim</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># (1+ total number of photons)</span>
<span class="n">paths</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">modes</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">paths</span>

<span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">cutoff_dim</span><span class="p">]</span> <span class="o">*</span> <span class="n">modes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
<span class="c1"># The ket below corresponds to a single horizontal photon in each of the modes</span>
<span class="n">initial_state</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="c1"># Permutation matrix</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

<span class="c1"># Here is the main program</span>
<span class="c1"># We create the input state and then send it through a network of beamsplitters and swaps.</span>
<span class="n">prog</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Program</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="k">with</span> <span class="n">prog</span><span class="o">.</span><span class="n">context</span> <span class="k">as</span> <span class="n">q</span><span class="p">:</span>
    <span class="n">Ket</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span>  <span class="c1"># Initial state preparation</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">paths</span><span class="p">):</span>
        <span class="n">BSgate</span><span class="p">()</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>  <span class="c1"># First layer of beamsplitters</span>
    <span class="n">Interferometer</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">Interferometer</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
    <span class="n">BSgate</span><span class="p">()</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">BSgate</span><span class="p">()</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
    <span class="n">Interferometer</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
    <span class="n">BSgate</span><span class="p">()</span><span class="o">.</span><span class="n">H</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">BSgate</span><span class="p">()</span><span class="o">.</span><span class="n">H</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>

<span class="c1"># We run the simulation</span>
<span class="n">eng</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Engine</span><span class="p">(</span><span class="s2">&quot;fock&quot;</span><span class="p">,</span> <span class="n">backend_options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;cutoff_dim&quot;</span><span class="p">:</span> <span class="n">cutoff_dim</span><span class="p">})</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">eng</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">state</span>
<span class="n">ket</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">ket</span><span class="p">()</span>

<span class="c1"># Check the normalization of the ket.</span>
<span class="c1"># This does give the exact answer because of the cutoff we chose.</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The norm of the ket is &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ket</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">ModuleNotFoundError</span><span class="g g-Whitespace">                       </span>Traceback (most recent call last)
<span class="nn">Input In [1],</span> in <span class="ni">&lt;cell line: 2&gt;</span><span class="nt">()</span>
<span class="g g-Whitespace">      </span><span class="mi">1</span> <span class="c1"># Import and preliminaries</span>
<span class="ne">----&gt; </span><span class="mi">2</span> <span class="kn">import</span> <span class="nn">strawberryfields</span> <span class="k">as</span> <span class="nn">sf</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span> <span class="kn">from</span> <span class="nn">strawberryfields.ops</span> <span class="kn">import</span> <span class="n">Ket</span><span class="p">,</span> <span class="n">BSgate</span><span class="p">,</span> <span class="n">Interferometer</span>
<span class="g g-Whitespace">      </span><span class="mi">4</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="ne">ModuleNotFoundError</span>: No module named &#39;strawberryfields&#39;
</pre></div>
</div>
</div>
</div>
</section>
<section id="postselection">
<h2>Postselection<a class="headerlink" href="#postselection" title="Permalink to this heading">¶</a></h2>
<p>Let’s consider the case where one horizontally-polarized photon is detected in both paths
2 and 3.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sub_ket1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ket</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="mi">14</span><span class="p">)</span>  <span class="c1"># postselect on correct pattern</span>
<span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sub_ket1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>  <span class="c1"># Check the probability of this event</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The probability is &quot;</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The expected probability is &quot;</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">32</span><span class="p">)</span>

<span class="c1"># These are the only nonzero components</span>
<span class="n">ind1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real_if_close</span><span class="p">(</span><span class="n">sub_ket1</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The indices of the nonzero components are </span><span class="se">\n</span><span class="s2"> &quot;</span><span class="p">,</span> <span class="n">ind1</span><span class="p">)</span>

<span class="c1"># And these are their coefficients</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The nonzero components have values &quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">sub_ket1</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind</span><span class="p">)]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">ind1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The probability is  0.03125
The expected probability is  0.03125
The indices of the nonzero components are 
  [[0 1 0 1]
 [1 0 1 0]]
The nonzero components have values  [(0.125-0j), (0.125-0j)]
</pre></div>
</div>
</div>
</div>
<p>Thus up to normalization the postselected state is indeed <span class="math notranslate nohighlight">\(|\phi^+ \rangle\)</span>.</p>
<p>We can study all the successful postselections. To simplify tensor
manipulation we will move the modes in which we measure to be the first
4 modes of the tensor by using a transposition:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Transpose the ket</span>
<span class="n">ket_t</span> <span class="o">=</span> <span class="n">ket</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="c1"># Postselection patterns:</span>
<span class="n">patterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>For each pattern we can construct the postselected ket, and find which
components are nonzero. Note that for each postselection there are only
two nonzero components, as expected for a Bell state.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sub_kets</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ket_t</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind</span><span class="p">)],</span> <span class="mi">15</span><span class="p">)</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">]</span>
<span class="n">ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">,</span> <span class="n">sub_kets</span><span class="p">)))</span> <span class="o">**</span> <span class="mi">2</span>
<span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">sub_ket</span><span class="p">))</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">sub_ket</span> <span class="ow">in</span> <span class="n">sub_kets</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span>
    <span class="s2">&quot;The indices of the nonzero components for the six different postselections are </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># The successful postselection events occur with the same probability</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The success probabilities for each pattern are the same </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ps</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The indices of the nonzero components for the six different postselections are 
 [[[0 0 1 1]
  [1 1 0 0]]

 [[0 1 0 1]
  [1 0 1 0]]

 [[0 1 1 0]
  [1 0 0 1]]

 [[0 1 1 0]
  [1 0 0 1]]

 [[0 1 0 1]
  [1 0 1 0]]

 [[0 0 1 1]
  [1 1 0 0]]]
The success probabilities for each pattern are the same 
 [0.03125 0.03125 0.03125 0.03125 0.03125 0.03125]
</pre></div>
</div>
</div>
</div>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this heading">¶</a></h2>
<p>We have examined how to map the evolution of photonic systems with path
and polarization degrees of freedom into qumodes evolving under unitary
operations. The main takeaway is that a system with <span class="math notranslate nohighlight">\(N\)</span> paths and
2 polarization degrees of freedom can be mapped into a system of
<span class="math notranslate nohighlight">\(2N\)</span> qumodes. We have also explored in detail how the typical
optical elements used to couple path and polarization can be mapped to
qumode simulations. Finally, we used these identifications to
simulate the generation of event-ready (i.e. postselected) Bell states.</p>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this heading">¶</a></h2>
<p>.. [#zhang]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Q. Zhang, X.-H. Bao, C.-Y. Lu, X.-Q. Zhou, T. Yang, T. Rudolph, and J.-W. Pan
Physical Review A 77, 062316, 2008. doi:10.1103/PhysRevA.77.062316 .
</pre></div>
</div>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="quantum-teleportation">
<h1>Quantum teleportation<a class="headerlink" href="#quantum-teleportation" title="Permalink to this heading">¶</a></h1>
<p>To see how to construct and simulate a simple continuous-variable (CV) quantum circuit in Strawberry
Fields, let’s consider the case of <strong>state teleportation</strong>.</p>
<section id="background-theory">
<h2>Background theory<a class="headerlink" href="#background-theory" title="Permalink to this heading">¶</a></h2>
<p>Quantum teleportation - sometimes referred to as state teleportation to avoid confusion
with gate teleportation - is the reliable transfer of an unknown quantum state across
spatially separated qubits or qumodes, through the use of a classical transmission channel
and quantum entanglement [[2]<em>]. Considered a fundamental quantum information
protocol, it has applications ranging from quantum communication to enabling distributed
information processing in quantum computation [[3]</em>].</p>
<p>In general, all quantum teleportation circuits work on the same basic principle. Two
distant observers, Alice and Bob, share a maximally entangled quantum state (in discrete
variables, any one of the four <code class="docutils literal notranslate"><span class="pre">Bell</span> <span class="pre">states</span> <span class="pre">&lt;https://en.wikipedia.org/wiki/Bell_state&gt;</span></code><em>;
or in CV, a maximally entangled state for a fixed energy), and have access to a classical
communication channel. Alice, in possession of an unknown state which she wishes to
transport to Bob, makes a joint measurement of the unknown state and her half of the
entangled state, by projecting onto the Bell basis. By transmitting the results of her
measurement to Bob, Bob is then able to transform his half of the entangled state to
an accurate replica of the original unknown state, by performing a conditional phase
flip (for qubits) or displacement (for qumodes) [[4]</em>].</p>
<p>While originally designed for discrete-variable quantum computation with qubits, the
(spatially separated) quantum teleportation algorithm described above can be easily
translated to CV qumodes; the result is shown in the following circuit:</p>
<p><img alt="" src="../../../../_images/teleport.png" /></p>
<p>This process can be explained as follows:</p>
<ol class="arabic">
<li><p>Here, qumodes <span class="math notranslate nohighlight">\(q_1\)</span> and <span class="math notranslate nohighlight">\(q_2\)</span> are initially prepared as (the unphysical)
infinitely squeezed vacuum states in momentum and position space respectively,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
       &amp;\ket{0}_x \sim \lim_{z\rightarrow\infty} S(z)\ket{0}\\ &amp;\ket{0}_p \sim
       \lim_{z\rightarrow-\infty} S(z)\ket{0}=\frac{1}{\sqrt{\pi}}\int_{-\infty}^\infty \ket{x}~dx
   \end{split}\]</div>
<p>before being maximally entangled by a 50-50 beamsplitter:</p>
<p><span class="math notranslate nohighlight">\( BS(\pi/4,0)(\ket{0}_p\otimes\ket{0}_x)\)</span></p>
</li>
<li><p>These two qumodes are now spatially separated, with <span class="math notranslate nohighlight">\(\ket{q_1}\)</span> held by
Alice, and <span class="math notranslate nohighlight">\(\ket{q_2}\)</span> held by Bob, with the two connected via the classical
communication channels <span class="math notranslate nohighlight">\(c_0\)</span> and <span class="math notranslate nohighlight">\(c_1\)</span>.</p></li>
<li><p>To teleport her unknown state <span class="math notranslate nohighlight">\(\ket{\psi}\)</span> to Bob, Alice now performs a projective
measurement of her entire system onto the maximally entangled basis states. This is done
by entangling <span class="math notranslate nohighlight">\(\ket{\psi}\)</span> and <span class="math notranslate nohighlight">\(\ket{q_1}\)</span> via another 50-50 beamsplitter,
before performing two homodyne measurements, in the <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(p\)</span> quadratures respectively.</p></li>
<li><p>The results of these measurements are then transmitted to Bob, who performs both a
position displacement (conditional on the <span class="math notranslate nohighlight">\(x\)</span> measurement) and a momentum
displacement (conditional on the <span class="math notranslate nohighlight">\(p\)</span> measurement) to recover exactly the
transmitted state <span class="math notranslate nohighlight">\(\ket{\psi}\)</span>.</p></li>
</ol>
</section>
<section id="importing-strawberry-fields">
<h2>Importing Strawberry Fields<a class="headerlink" href="#importing-strawberry-fields" title="Permalink to this heading">¶</a></h2>
<p>The first thing we need to do is import Strawberry Fields; we do this with the following import
statements:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">strawberryfields</span> <span class="k">as</span> <span class="nn">sf</span>
<span class="kn">from</span> <span class="nn">strawberryfields.ops</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sqrt</span>

<span class="c1"># set the random seed</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The first import statement imports Strawberry Fields as <code class="docutils literal notranslate"><span class="pre">sf</span></code>, allowing us to access the engine
and backends; the second import statement imports all available CV gates into the global
namespace. Finally, we import <span class="math notranslate nohighlight">\(\pi\)</span> and the square root from <code class="docutils literal notranslate"><span class="pre">NumPy</span></code> so that we can pass angle
parameters to gates such as beamsplitters, and perform some custom classical processing.</p>
</section>
<section id="program-initialization">
<h2>Program initialization<a class="headerlink" href="#program-initialization" title="Permalink to this heading">¶</a></h2>
<p>We can now initialize our quantum program by instantiating a
<code class="docutils literal notranslate"><span class="pre">~strawberryfields.Program</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">sf.Program(num_subsystems,</span> <span class="pre">name=None)</span></code></p>
<p>where</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">num_subsystems</span></code> (<em>int</em>) is the number of modes we want to initialize in our quantum register</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code> (<em>str</em>) is the name of the program (optional)</p></li>
</ul>
<blockquote>
<div><p><strong>Note:</strong> By default, Strawberry Fields uses the convention <span class="math notranslate nohighlight">\(\hbar=2\)</span> for the commutation relation
<span class="math notranslate nohighlight">\([\x,\p]=i\hbar\)</span>.</p>
</div></blockquote>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Other conventions can also be chosen by setting the global variable
``sf.hbar`` at the beginning of a session.

The value of $\hbar$ chosen modifies the application of the
:class:`~strawberryfields.ops.Xgate` and :class:`~strawberryfields.ops.Zgate`, as well as the
measurements returned by Homodyne measurement :class:`~strawberryfields.ops.MeasureHomodyne`, so this must be
taken into account if the value of $\hbar$ is modified. All other gates are
unaffected.

See `conventions` for more details.
</pre></div>
</div>
<p>Therefore, to initialize a program on three quantum registers, we write:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Program</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="circuit-construction">
<h2>Circuit construction<a class="headerlink" href="#circuit-construction" title="Permalink to this heading">¶</a></h2>
<p>To prepare states and apply gates to the quantum register <code class="docutils literal notranslate"><span class="pre">q</span></code>, we must be inside the context of
the program we initialized using the <code class="docutils literal notranslate"><span class="pre">with</span></code> statement. Everything within the program context is
written using the <code class="docutils literal notranslate"><span class="pre">Blackbird</span> <span class="pre">quantum</span> <span class="pre">programming</span> <span class="pre">language</span> <span class="pre">&lt;blackbird&gt;</span></code>. For example, to
construct the following state teleportation circuit</p>
<p><img alt="" src="../../../../_images/teleport.png" /></p>
<p>to teleport the coherent state <span class="math notranslate nohighlight">\(\ket{\alpha}\)</span> where <span class="math notranslate nohighlight">\(\alpha=1+0.5i\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="mf">0.5</span><span class="n">j</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
<span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>

<span class="k">with</span> <span class="n">prog</span><span class="o">.</span><span class="n">context</span> <span class="k">as</span> <span class="n">q</span><span class="p">:</span>
    <span class="c1"># prepare initial states</span>
    <span class="n">Coherent</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Squeezed</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Squeezed</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># apply gates</span>
    <span class="n">BS</span> <span class="o">=</span> <span class="n">BSgate</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
    <span class="n">BS</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">BS</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Perform homodyne measurements</span>
    <span class="n">MeasureX</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">MeasureP</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Displacement gates conditioned on</span>
    <span class="c1"># the measurements</span>
    <span class="n">Xgate</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">par</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">Zgate</span><span class="p">(</span><span class="o">-</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">par</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>A couple of things to note here:</p>
<ul>
<li><p><strong>The quantum register returned from the</strong> <code class="docutils literal notranslate"><span class="pre">prog.context</span></code> <strong>context manager is a sequence</strong>.
Individual modes can be accessed via standard Python indexing and slicing techniques.</p></li>
<li><p><strong>Preparing initial states, measurements, and gate operations all make use of the following
syntax:</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">Operation([arg1,</span> <span class="pre">arg2,</span> <span class="pre">...])</span> <span class="pre">|</span> <span class="pre">reg</span></code></p>
<p>where the number of arguments depends on the specific operation, and <code class="docutils literal notranslate"><span class="pre">reg</span></code> is either a
single mode or a sequence of modes, depending on how many modes the operation acts on. For a full
list of operations and gates available, see the <code class="docutils literal notranslate"><span class="pre">quantum</span> <span class="pre">gates</span> <span class="pre">&lt;gates&gt;</span></code> documentation.</p>
</li>
<li><p><strong>Every time a operation is applied it is added to the command queue</strong>, ready to be simulated by
the backend.</p></li>
<li><p><strong>Operations must be applied in temporal order</strong>. Different operation orderings can result in the
same quantum circuit, providing the operations do not apply sequentially to the same mode. For
example, we can permute the line containing <code class="docutils literal notranslate"><span class="pre">MeasureX</span></code> and <code class="docutils literal notranslate"><span class="pre">MeasureP</span></code> without changing the
result.</p></li>
<li><p><strong>Gates are standard Python objects, and can be treated as such</strong>. In this case, since both
beamsplitters use the same parameters, a single instance is being instantiated and stored under
variable <code class="docutils literal notranslate"><span class="pre">BS</span></code>.</p></li>
<li><p><strong>The results of measured modes are passed to gates simply by passing the measured mode as an
argument.</strong> In order to perform additional classical processing to the measured mode <code class="docutils literal notranslate"><span class="pre">q[i]</span></code>, and
use the result to control a subsequent quantum operation, we can use the <code class="docutils literal notranslate"><span class="pre">q[i].par</span></code> attribute
within the operation argument.</p></li>
</ul>
<div class="alert alert-info"><h4>Note</h4><p>By choosing a different phase for the 50-50 beamsplitter, that is, ``BSgate(pi/4,0)``, we can
    avoid having to negate the :class:`~strawberryfields.ops.Zgate` correction at the end of the
    circuit.</p></div>
</section>
<section id="executing-the-program">
<h2>Executing the program<a class="headerlink" href="#executing-the-program" title="Permalink to this heading">¶</a></h2>
<p>Once the program is constructed, we then must initialize an <strong>engine</strong>, which is responsible for
executing the program on a specified <strong>backend</strong> (which can be either a local simulator, or a
remote simulator/hardware device). Engines are initialized as follows:</p>
<p><code class="docutils literal notranslate"><span class="pre">sf.Engine(backend,</span> <span class="pre">backend_options={})</span></code></p>
<p>where</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">backend</span></code>: a string or :class:<code class="docutils literal notranslate"><span class="pre">~strawberryfields.backends.BaseBackend</span></code> object representing
the Strawberry Fields backend we wish to use; we have the choice of two Fock backends [[#]<em>], the
NumPy based (<code class="docutils literal notranslate"><span class="pre">'fock'</span></code>) and TensorFlow (<code class="docutils literal notranslate"><span class="pre">'tf'</span></code>), and one Gaussian backend [[#]</em>]
(<code class="docutils literal notranslate"><span class="pre">'gaussian'</span></code>).</p>
<p>This argument is <em>required</em> when creating the engine.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">backend_options</span></code> is a dictionary containing options specific to the chosen backend.</p></li>
</ul>
<p>Let’s choose the Fock backend for this particular example. Since we are working in the Fock basis,
we must also specify the Fock basis <em>cutoff dimension</em>; let’s choose <code class="docutils literal notranslate"><span class="pre">cutoff_dim=15</span></code>, such that
a state <span class="math notranslate nohighlight">\(\ket{\psi}\)</span> has approximation</p>
<div class="amsmath math notranslate nohighlight" id="equation-f86d2112-94a9-46ef-9b26-f35ad976cd2d">
<span class="eqno">(7)<a class="headerlink" href="#equation-f86d2112-94a9-46ef-9b26-f35ad976cd2d" title="Permalink to this equation">¶</a></span>\[\begin{align}\ket{\psi} = \sum_{n=0}^\infty c_n\ket{n} \approx \sum_{n=0}^{\texttt{cutoff_dim}-1}
    c_n\ket{n}\end{align}\]</div>
<p>in our truncated Fock basis. We now have all the parameters ready to initialize the engine:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eng</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Engine</span><span class="p">(</span><span class="s1">&#39;fock&#39;</span><span class="p">,</span> <span class="n">backend_options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;cutoff_dim&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<div class="alert alert-danger"><h4>Warning</h4><p>To avoid significant numerical error when working with the Fock backend, we need to make sure
    from now on that all initial states and gates we apply result in negligible amplitude in the
    Fock basis for Fock states $\ket{n}, ~~n\geq \texttt{cutoff_dim}$. For example, to
    prepare a squeezed vacuum state in the $x$ quadrature with ``cutoff_dim=10``, a
    squeezing factor of $r=1$ provides an acceptable approximation, since
    $|\braketD{n}{z}|^2<0.02$ for $n\geq 10$.</p></div>
<p>We can now execute our quantum program <code class="docutils literal notranslate"><span class="pre">prog</span></code> on the engine via the
:meth:<code class="docutils literal notranslate"><span class="pre">~strawberryfields.Engine.run</span></code> method:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">eng</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">modes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compile_options</span><span class="o">=</span><span class="p">{})</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">eng.run</span> <span class="pre">&lt;strawberryfields.Engine.run&gt;</span></code> method accepts the arguments:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">program</span></code>: The <code class="docutils literal notranslate"><span class="pre">~strawberryfields.Program</span></code> to execute.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shots</span></code>: A positive integer that specifies the number of times the program measurement
evaluation is to be repeated.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">modes</span></code>: An optional list of integers that specifies which modes we wish the backend to
return for the quantum state. If the state is a mixed state represented by a density matrix,
then the backend will automatically perform a partial trace to return only the modes
specified. Note that this only affects the returned state object—all modes remain in the
backend circuit.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compile_options</span></code>: A dictionary of keyword arguments to be used for program compilation. To
ensure the <code class="docutils literal notranslate"><span class="pre">~strawberryfields.Program</span></code> will run on the specified backend, the engine will
perform <strong>program compilation</strong>, by calling the <code class="docutils literal notranslate"><span class="pre">~strawberryfields.Program.compile</span></code>
method.</p></li>
</ul>
<blockquote>
<div><p>**Note:**A <code class="docutils literal notranslate"><span class="pre">shots</span></code> value different than 1 is currently only supported for one specific case: the
<code class="docutils literal notranslate"><span class="pre">MeasureFock/Measure</span></code> operation executed on the Gaussian backend.</p>
</div></blockquote>
<p>Other useful engine methods that can be called at any time include:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eng.print_applied()</span> <span class="pre">&lt;strawberryfields.engine.BaseEngine.print_applied&gt;</span></code>: Prints all
commands applied using :meth:<code class="docutils literal notranslate"><span class="pre">eng.run</span> <span class="pre">&lt;strawberryfields.engine.LocalEngine.run&gt;</span></code> since the last
backend reset/initialisation.</p>
<ul>
<li><p>This may differ from your original constructed program due to program compilation. As a
result, this shows all applied gate decompositions, which may differ depending on the backend.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">eng.reset()</span> <span class="pre">&lt;strawberryfields.engine.BaseEngine.reset&gt;</span></code>: Resets the backend circuit to
the vacuum state.</p></li>
</ul>
</section>
<section id="results-and-visualization">
<h2>Results and visualization<a class="headerlink" href="#results-and-visualization" title="Permalink to this heading">¶</a></h2>
<p>The returned <code class="docutils literal notranslate"><span class="pre">~strawberryfields.Result</span></code> object provides several useful properties for accessing the results
of your program execution:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">result.state</span></code>: The quantum state object contains details and methods for manipulation of the
final circuit state.</p>
<p>Note that only local simulators will return a state object. Remote simulators and hardware
backends will return <code class="docutils literal notranslate"><span class="pre">measurement</span> <span class="pre">samples</span> <span class="pre">&lt;strawberryfields.Result.samples&gt;</span></code>, but the
return value of <code class="docutils literal notranslate"><span class="pre">state</span></code> will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Depending on backend used, the state returned might be a
<code class="docutils literal notranslate"><span class="pre">~strawberryfields.backends.BaseFockState</span></code>, which represents the state using the
Fock/number basis, or might be a <code class="docutils literal notranslate"><span class="pre">~strawberryfields.backends.BaseGaussianState</span></code>, which
represents the state using Gaussian representation, as a vector of means and a covariance
matrix. Many methods are provided for state manipulation, see <code class="docutils literal notranslate"><span class="pre">introduction/states</span></code> for
more details.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">result.samples</span></code>: Measurement samples from any measurements performed. Returned measurement
samples will have shape <code class="docutils literal notranslate"><span class="pre">(shots,</span> <span class="pre">modes)</span></code>.</p></li>
</ul>
<p>Once the engine has been run, we can extract results of measurements and the quantum state from
the circuit. Any measurements performed on a mode are stored attribute <code class="docutils literal notranslate"><span class="pre">result.samples</span> <span class="pre">&lt;strawberryfields.Result.samples&gt;</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[0.19890199 0.17330173]]
</pre></div>
</div>
</div>
</div>
<p>If a mode has not been measured, this attribute simply returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>In this particular example, we are using the Fock backend, and so the state that was returned by
<code class="docutils literal notranslate"><span class="pre">result.state</span></code> is in the Fock basis. To double check this, we can inspect it with the <code class="docutils literal notranslate"><span class="pre">print</span></code>
function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">state</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;FockState: num_modes=3, cutoff=15, pure=False, hbar=2&gt;
</pre></div>
</div>
</div>
</div>
<p>In addition to the parameters we have already configured when creating and running the engine, the
line <code class="docutils literal notranslate"><span class="pre">pure=False</span></code>, indicates that this is a mixed state represented as a density matrix, and not
a state vector.</p>
<p>To return the density matrix representing the Fock state, we can use the method <code class="docutils literal notranslate"><span class="pre">state.dm</span> <span class="pre">&lt;strawberryfields.backends.BaseFockState.dm&gt;</span></code> [[#]_]. In this case, the density matrix has dimension</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">dm</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(15, 15, 15, 15, 15, 15)
</pre></div>
</div>
</div>
</div>
<p>Here, we use the convention that every pair of consecutive dimensions corresponds to a subsystem;
i.e.,</p>
<div class="amsmath math notranslate nohighlight" id="equation-5e40e2f0-7502-4d7a-a1fa-05f27108c2a0">
<span class="eqno">(8)<a class="headerlink" href="#equation-5e40e2f0-7502-4d7a-a1fa-05f27108c2a0" title="Permalink to this equation">¶</a></span>\[\begin{align}\rho_{\underbrace{ij}_{q[0]}~\underbrace{kl}_{q[1]}~\underbrace{mn}_{q[2]}}\end{align}\]</div>
<p>Thus we can calculate the reduced density matrix for mode <code class="docutils literal notranslate"><span class="pre">q[2]</span></code>, <span class="math notranslate nohighlight">\(\rho_2\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rho2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;kkllij-&gt;ij&#39;</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">dm</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rho2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(15, 15)
</pre></div>
</div>
</div>
</div>
<div class="alert alert-info"><h4>Note</h4><p>The Fock state also provides the method
    :meth:`~strawberryfields.backends.BaseFockState.reduced_dm` for extracting the reduced density
    matrix automatically.</p></div>
<p>The diagonal values of the reduced density matrix contain the marginal Fock state probabilities
<span class="math notranslate nohighlight">\(|\braketD{i}{\rho_2}|^2,~~ 0\leq i\leq 14\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real_if_close</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">rho2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[3.10694907e-01 3.62467630e-01 2.11807608e-01 8.23802050e-02
 2.43874177e-02 5.83556629e-03 1.26776314e-03 2.37656289e-04
 8.43934922e-05 1.78787082e-06 1.52342119e-04 1.07036413e-05
 3.36055927e-04 1.47426072e-05 1.92773805e-04]
</pre></div>
</div>
</div>
</div>
<p>We can then use a package such as matplotlib to plot the marginal Fock state probability
distributions for the first 6 Fock states, for the teleported mode <code class="docutils literal notranslate"><span class="pre">q[2]</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">probs</span><span class="p">[:</span><span class="mi">7</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Fock state&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Marginal probability&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Mode 2&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../../_images/e68c619b2231e540efef046c50c5d95c021d5c83b3aaded8fbaa4535ab112e91.png" src="../../../../_images/e68c619b2231e540efef046c50c5d95c021d5c83b3aaded8fbaa4535ab112e91.png" />
</div>
</div>
<p>Note that this information can also be extracted automatically via the Fock state method
<code class="docutils literal notranslate"><span class="pre">~strawberryfields.backends.BaseFockState.all_fock_probs</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fock_probs</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">all_fock_probs</span><span class="p">()</span>
<span class="n">fock_probs</span><span class="o">.</span><span class="n">shape</span>
<span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fock_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([3.10694907e-01, 3.62467630e-01, 2.11807608e-01, 8.23802050e-02,
       2.43874177e-02, 5.83556629e-03, 1.26776314e-03, 2.37656289e-04,
       8.43934922e-05, 1.78787082e-06, 1.52342119e-04, 1.07036413e-05,
       3.36055927e-04, 1.47426072e-05, 1.92773805e-04])
</pre></div>
</div>
</div>
</div>
</section>
<section id="full-program">
<h2>Full program<a class="headerlink" href="#full-program" title="Permalink to this heading">¶</a></h2>
<p>The full Strawberry Fields program for teleportation is given by:</p>
<p>.. code-block:: python</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>import strawberryfields as sf
from strawberryfields.ops import *

import numpy as np
from numpy import pi, sqrt

prog = sf.Program(3)

alpha = 1+0.5j
r = np.abs(alpha)
phi = np.angle(alpha)

with prog.context as q:
    # prepare initial states
    Coherent(r, phi) | q[0]
    Squeezed(-2) | q[1]
    Squeezed(2) | q[2]

    # apply gates
    BS = BSgate(pi/4, pi)
    BS | (q[1], q[2])
    BS | (q[0], q[1])

    # Perform homodyne measurements
    MeasureX | q[0]
    MeasureP | q[1]

    # Displacement gates conditioned on
    # the measurements
    Xgate(sqrt(2) * q[0].par) | q[2]
    Zgate(sqrt(2) * q[1].par) | q[2]

eng = sf.Engine(&#39;fock&#39;, backend_options={&#39;cutoff_dim&#39;: 15})
result = eng.run(prog, shots=1, modes=None, compile_options={})
</pre></div>
</div>
</section>
<section id="footnotes">
<h2>Footnotes<a class="headerlink" href="#footnotes" title="Permalink to this heading">¶</a></h2>
<p>.. [#] Fock backends are backends which represent the quantum state and operations via the Fock
basis. These can represent <em>all</em> possible CV states and operations, but also introduce
numerical error due to truncation of the Fock space, and consume more memory.</p>
<p>.. [#] The Gaussian backend, due to its ability to represent states and operations as Gaussian
objects/transforms in the phase space, consumes less memory and is less computationally intensive
then the Fock backends. However, it cannot represent non-Gaussian operations and states (such as
the cubic phase gate, and Fock states, amongst others). The only exception is Fock measurements.
The Gaussian backend can simulate these, but it does not update the post-measurement quantum
state, which would be non-Gaussian.</p>
<p>.. [#] If using the Gaussian backend, state methods and attributes available for extracting the
state information include:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>   * :meth:`~strawberryfields.backends.BaseGaussianState.means` and
     :meth:`~strawberryfields.backends.BaseGaussianState.cov` for returning the vector of
     means and the covariance matrix of the specified modes
   * :meth:`~strawberryfields.backends.BaseState.fock_prob` for returning the probability that
     the photon counting pattern specified by ``n`` occurs
   * :meth:`~strawberryfields.backends.BaseState.reduced_dm` for returning the reduced density
     matrix in the fock basis of mode ``n``
</pre></div>
</div>
</section>
<section id="id1">
<h2>References<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h2>
<p>.. [1] Dagmar Bruß. Characterizing entanglement. Journal of Mathematical Physics,
43(9):4237-4251, Sep 2002. URL: https://doi.org/10.1063/1.1494474, doi:10.1063/1.1494474.</p>
<p>.. [2] Charles H. Bennett, Gilles Brassard, Claude Crépeau, Richard Jozsa, Asher Peres, and
William K. Wootters. Teleporting an unknown quantum state via dual classical and
Einstein-Podolsky-Rosen channels. Physical Review Letters, 70:1895-1899, Mar 1993.
doi:10.1103/PhysRevLett.70.1895.</p>
<p>.. [3] A. Furusawa and P. van Loock. Quantum Teleportation and Entanglement:
A Hybrid Approach to Optical Quantum Information Processing. Wiley, 2011.
ISBN 9783527635290. URL: https://books.google.ca/books?id=eKxHZ0UHEU4C.</p>
<p>.. [4] W.H. Steeb and Y. Hardy. Problems and Solutions in Quantum Computing and
Quantum Information. World Scientific, 2006. ISBN 9789812567406.
URL: https://books.google.ca/books?id=HGMy_dSmfbkC.</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="cv-quantum-gate-visualizations">
<h1>CV quantum gate visualizations<a class="headerlink" href="#cv-quantum-gate-visualizations" title="Permalink to this heading">¶</a></h1>
<p><em>Author: Brianna Gopaul</em></p>
<p>In a conventional quantum circuit, qubits represented by wires are
operated on by quantum gates which collectively perform computations.
Similarily, continuous variable quantum computing uses qumodes that
represent bundles of interacting photons. To perform computations on
qumodes, we leverage Gaussian and non-Gaussian gates.</p>
<p>Gaussian and non-Gaussian gates can be described within the phase space.
This space is shown by the position and momentum axes.</p>
<p>Gaussian gates such as the squeezing and rotation gate act linearly on
modes. These gates can only reach positive quasi-probability
distributions and can be classically simulated. On the other hand,
non-Gaussian gates such as the Kerr gate and Cubic Phase gate act
nonlinearly. This property allows them to be in negative
quasi-probability distributions and not be classically simulated.</p>
<p><strong>In this notebook, we’ll learn about various single mode Gaussian and
non-Gaussian gates and apply them to a state using Strawberry Fields.</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">strawberryfields</span> <span class="k">as</span> <span class="nn">sf</span>
<span class="kn">from</span> <span class="nn">strawberryfields.ops</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
</pre></div>
</div>
</div>
</div>
<section id="vacuum-state">
<h2>Vacuum State<a class="headerlink" href="#vacuum-state" title="Permalink to this heading">¶</a></h2>
<p>The vacuum state is the lowest energy Gaussian state. It has no
displacement or squeezing in phase space.</p>
<p>Here we learn how to create the vacuum state on a quantum circuit with
one qumode.</p>
<p>We initialize the Strawberry Fields program. <code class="docutils literal notranslate"><span class="pre">q</span></code> represents a qumode
and below we start with one qumode for our circuit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Program</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We declare our quantum circuit using the engine. We can prepare the
Vacuum state on one qumode using <code class="docutils literal notranslate"><span class="pre">|</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">prog</span><span class="o">.</span><span class="n">context</span> <span class="k">as</span> <span class="n">q</span><span class="p">:</span>
    <span class="n">Vac</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">eng</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Engine</span><span class="p">(</span><span class="s1">&#39;gaussian&#39;</span><span class="p">)</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">eng</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span><span class="o">.</span><span class="n">state</span>
</pre></div>
</div>
</div>
</div>
<p>It should be noted that the default state in strawberry fields is the
vacuum state. The above gate is listed to show the operation.</p>
<p>In Strawberry Fields, there are three main backends that can be used to
perform computations. The backend selected will depend on the task you
want to perform. Above, we’ve used the Gaussian backend to run our
vacuum state circuit. We can also alternatively use the Fock backend to
run the circuit. The third backend is the tensorflow backend ‘tf’. It
leverages tensorflow to create quantum machine learning models.</p>
<p>Using matplotlib, we then plot the Wigner function of the vacuum state,
which is a Gaussian distribution. The Wigner function quasi-probability
illustrates negative and positive regions in phase space. We’ll notice
below that Gaussian states such as the vacuum and squeezed state are in
positive regions of phase space while non-Gaussian states can reach
negative regions of the phase space. The y-axis on this plot can
describe the <span class="math notranslate nohighlight">\(\hat {p}\)</span> quadrature or momentum operator and the
x-axis describes the <span class="math notranslate nohighlight">\(\hat{x}\)</span> quadrature or position operator of
the state.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">wigner</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="n">X</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;3d&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;RdYlGn&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">rstride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cstride</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="mf">4.8</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../../_images/c40d425b2b2eb500b9bd3d258379a7f7e910de956e5fbb677276cec0d170a526.png" src="../../../../_images/c40d425b2b2eb500b9bd3d258379a7f7e910de956e5fbb677276cec0d170a526.png" />
</div>
</div>
<p>We can make a couple of observations from the Gaussian distribution
above. We notice that it has positive quasi-probability everywhere.
Later on, we’ll have a look at non-Gaussian gates that have regions of
negative quasi-probability. The vacuum state is also centered at 0 on
both the position axis <span class="math notranslate nohighlight">\(\hat {x}\)</span> and momentum axis
<span class="math notranslate nohighlight">\(\hat {p}\)</span>.</p>
</section>
<section id="squeezing-gate">
<h2>Squeezing Gate<a class="headerlink" href="#squeezing-gate" title="Permalink to this heading">¶</a></h2>
<p>The squeezing gate can also be thought of as a transformation on the
position and momentum axes. The squeezing gate scales <span class="math notranslate nohighlight">\(x\)</span> to
<span class="math notranslate nohighlight">\(e^{ - r}\hat{x} _\phi\)</span> and scales <span class="math notranslate nohighlight">\(p\)</span> with
<span class="math notranslate nohighlight">\(e^{r}\hat{p} _\phi\)</span>. In the Wigner function, we can see the
probability distribution being lengthened on the momentum axis and being
pinched on the position axis. As the squeezing gate is a Gaussian gate,
there are no regions of negative quasi-probabilty.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Program</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">with</span> <span class="n">prog</span><span class="o">.</span><span class="n">context</span> <span class="k">as</span> <span class="n">q</span><span class="p">:</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">Sgate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">S</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="n">state</span> <span class="o">=</span> <span class="n">eng</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span><span class="o">.</span><span class="n">state</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">wigner</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="n">X</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;3d&quot;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="mf">4.8</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;RdYlGn&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">rstride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cstride</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../../_images/4b0bd2f871330643e28771fbb46089cb08565712b358b02e123ccb851bbb6fe5.png" src="../../../../_images/4b0bd2f871330643e28771fbb46089cb08565712b358b02e123ccb851bbb6fe5.png" />
</div>
</div>
<p>The below animation shows the squeezing gate acting on the vacuum state
with increasing strengths of parameters. |squeezing|</p>
<p>.. |squeezing| image:: /tutorials/images/squeezinggif.gif</p>
</section>
<section id="rotation-gate">
<h2>Rotation Gate<a class="headerlink" href="#rotation-gate" title="Permalink to this heading">¶</a></h2>
<p>The rotation gate shifts the <span class="math notranslate nohighlight">\(\hat{x}\)</span> quadrature to
<span class="math notranslate nohighlight">\(\hat{x}\)</span> <span class="math notranslate nohighlight">\(\cos \phi\)</span> - <span class="math notranslate nohighlight">\(\hat{p}\sin\)</span> <span class="math notranslate nohighlight">\(\phi\)</span> and
<span class="math notranslate nohighlight">\(\hat{p}\)</span> to <span class="math notranslate nohighlight">\(\hat{p}\)</span> <span class="math notranslate nohighlight">\(\cos \phi\)</span> +
<span class="math notranslate nohighlight">\(\hat{x}\sin\)</span> <span class="math notranslate nohighlight">\(\phi\)</span>. In other words, the gate simply
rotates the phase space.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Program</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">with</span> <span class="n">prog</span><span class="o">.</span><span class="n">context</span> <span class="k">as</span> <span class="n">q</span><span class="p">:</span>
    <span class="n">Dgate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Rgate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">eng</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">eng</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span><span class="o">.</span><span class="n">state</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">wigner</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="n">X</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;3d&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;RdYlGn&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">rstride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cstride</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="mf">4.8</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../../_images/bdff3b34031f0c6609b3bab043f64b8c722b211130d8d76655fb72570374db1c.png" src="../../../../_images/bdff3b34031f0c6609b3bab043f64b8c722b211130d8d76655fb72570374db1c.png" />
</div>
</div>
<p>Above we apply the rotation gate to a coherent state. When compared to
the squeezed state in the previous example, the rotation gate simply
makes a rotation.</p>
<p>Similarily, the rotation gate is applied with an increasing parameter in
the below animation. |rotation|</p>
<p>.. |rotation| image:: /tutorials/images/rotation.gif</p>
</section>
<section id="displacement-gate">
<h2>Displacement Gate<a class="headerlink" href="#displacement-gate" title="Permalink to this heading">¶</a></h2>
<p>The displacement gate has a specified complex value <span class="math notranslate nohighlight">\(\alpha\)</span>. It
shifts <span class="math notranslate nohighlight">\(\hat{x}\)</span> by a value porportional to <span class="math notranslate nohighlight">\(Re(\alpha)\)</span> and
the <span class="math notranslate nohighlight">\(\hat {p}\)</span> by a value <span class="math notranslate nohighlight">\(Im({\alpha})\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Program</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">with</span> <span class="n">prog</span><span class="o">.</span><span class="n">context</span> <span class="k">as</span> <span class="n">q</span><span class="p">:</span>
    <span class="n">Dgate</span><span class="p">(</span><span class="mf">0.55</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">eng</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">eng</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span><span class="o">.</span><span class="n">state</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">wigner</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="n">X</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;3d&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;RdYlGn&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">rstride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cstride</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="mf">4.8</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../../_images/79731ba864baf6d98462f46b8af31d5566bd7f8e957b179a5b09a9eb0c19e083.png" src="../../../../_images/79731ba864baf6d98462f46b8af31d5566bd7f8e957b179a5b09a9eb0c19e083.png" />
</div>
</div>
<p>As <span class="math notranslate nohighlight">\(\alpha\)</span> increases in value, the state is displaced more to the
right. |disp|</p>
<p>.. |disp| image:: /tutorials/images/displacementgif.gif</p>
</section>
<section id="cubic-phase-gate">
<h2>Cubic Phase Gate<a class="headerlink" href="#cubic-phase-gate" title="Permalink to this heading">¶</a></h2>
<p>The cubic phase gate shifts <span class="math notranslate nohighlight">\(\hat{p}\)</span> by <span class="math notranslate nohighlight">\(\gamma\hat{x}^2\)</span>
where <span class="math notranslate nohighlight">\(\gamma\)</span> is a definable parameter but does not transform
<span class="math notranslate nohighlight">\(\hat{x}\)</span> in the phase space. Below, we decide to set
<span class="math notranslate nohighlight">\(\gamma=2\)</span>.</p>
<p>When running a circuit that contains any non-Gaussian gates, we use the
Fock backend. Depending on the backend used, different arguments will
have to be called. In this example, we define ‘cutoff_dim’ which tells
Strawberry Fields where to limit the Fock space.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Program</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">with</span> <span class="n">prog</span><span class="o">.</span><span class="n">context</span> <span class="k">as</span> <span class="n">q</span><span class="p">:</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">Vgate</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1">#We use the fock backend and define the argument cutoff_dim</span>
<span class="n">eng</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Engine</span><span class="p">(</span><span class="s1">&#39;fock&#39;</span><span class="p">,</span> <span class="n">backend_options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;cutoff_dim&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">})</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">eng</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span><span class="o">.</span><span class="n">state</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">wigner</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="n">X</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;3d&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;RdYlGn&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">rstride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cstride</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="mf">4.8</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../../_images/dabdc302c95e8537f6eb8a2f820d7cd6a712c86d0e87bf4b5b4bdb53cee063f2.png" src="../../../../_images/dabdc302c95e8537f6eb8a2f820d7cd6a712c86d0e87bf4b5b4bdb53cee063f2.png" />
</div>
</div>
<p>Here we can see that the vacuum state has been shifted to a state where
it reaches negative quasi-probability distributions. |cubic|</p>
<p>.. |cubic| image:: /tutorials/images/cubicphasegif.gif</p>
</section>
<section id="kerr-gate">
<h2>Kerr Gate<a class="headerlink" href="#kerr-gate" title="Permalink to this heading">¶</a></h2>
<p>Before we understand how the Kerr gate operates, we should first take
another look at the rotation gate. In the Fock basis, the rotation gate
acts with <span class="math notranslate nohighlight">\(e^{ i\phi \hat{n}}\)</span>. In comparison, the Kerr gates
transforms with <span class="math notranslate nohighlight">\(e^{ i\phi k \hat{n}^2}\)</span>. The <span class="math notranslate nohighlight">\(^2\)</span> value is
what makes this state non-Gaussian and thus transforms the shape of the
state significantly.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Program</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">with</span> <span class="n">prog</span><span class="o">.</span><span class="n">context</span> <span class="k">as</span> <span class="n">q</span><span class="p">:</span>
    <span class="n">kappa</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">Dgate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Kgate</span><span class="p">(</span><span class="n">kappa</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">eng</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">eng</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span><span class="o">.</span><span class="n">state</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">wigner</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="n">X</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;3d&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;RdYlGn&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">rstride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cstride</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="mf">4.8</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../../_images/510138fb7f66b6912bc515b0f90d65244b580ccb31982bc2ad4584a6a8634847.png" src="../../../../_images/510138fb7f66b6912bc515b0f90d65244b580ccb31982bc2ad4584a6a8634847.png" />
</div>
</div>
<p>In the below Wigner function, the state is initially in a coherent
state. |kerr|</p>
<p>We can see it’s coherent structure morphing after the Kerr gate is
applied at different strengths.</p>
<p>.. |kerr| image:: /tutorials/images/kerrgif.gif</p>
<p>For more information about CV gates, see <code class="docutils literal notranslate"><span class="pre">the</span> <span class="pre">CV</span> <span class="pre">gates</span> <span class="pre">section</span> <span class="pre">&lt;https://strawberryfields.ai/photonics/conventions/gates.html&gt;</span></code>__
in the Strawberry Fields documentation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># This cell is added by sphinx-gallery</span>
<span class="c1"># It can be customized to whatever you like</span>
<span class="o">%</span><span class="k">matplotlib</span> inline
</pre></div>
</div>
</div>
</div>
<p>.. role:: html(raw)
:format: html</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="gate-teleportation">
<h1>Gate teleportation<a class="headerlink" href="#gate-teleportation" title="Permalink to this heading">¶</a></h1>
<p>In the quantum state teleportation algorithm, the quantum state is transferred from the sender
to the receiver exactly. However, quantum teleportation can be used in a much more powerful
manner, by simultaneously processing and manipulating the teleported state; this is known as
<strong>gate teleportation</strong>.</p>
<p>But the biggest departure from its namesake is the method in which the gate to be ‘teleported’
is applied; rather than applying a quantum unitary directly to the first qumode in the system,
the unitary is applied via the projective measurement of the first qumode onto a particular basis.
This measurement-based approach provides significant advantages over applying unitary gates
directly, for example by reducing resources, and in the application of experimentally
hard-to-implement gates [[1]<em>]. In fact, gate teleportation forms a universal
quantum computing primitive, and is a precursor to cluster state models of quantum computation
[[2]</em>][[3]_].</p>
<section id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this heading">¶</a></h2>
<p>First described by Gottesman and Chuang [[2]<em>] in the case of qubits, gate
teleportation was generalized for the CV case by Bartlett and Munro in 2003 [[4]</em>].
In an analogous process to the discrete-variable case, you begin with the algorithm for
<strong>local state teleportation</strong>:</p>
<p><img alt="" src="../../../../_images/gate_teleport1.png" /></p>
<p>Note that:</p>
<ul class="simple">
<li><p>Unlike the spatially-separated quantum state teleportation we considered in the previous section,
<strong>local teleportation</strong> can transport the state using only two qumodes; the state we are
teleporting is entangled directly with the squeezed vacuum state in the momentum space through
the use of a controlled-phase gate.</p></li>
<li><p>The state is then teleported to qumode <span class="math notranslate nohighlight">\(q_1\)</span> via a homodyne measurement in the computational
basis (the position quadrature).</p></li>
<li><p>Like in the previous section, to recover the teleported state exactly, we must perform Weyl-Heisenberg
corrections to <span class="math notranslate nohighlight">\(q_1\)</span>; here, that would be <span class="math notranslate nohighlight">\(F^\dagger X(m)^\dagger\)</span>. However, for convenience and
simplicity, we write the circuit without the corrections applied explicitly.</p></li>
</ul>
<p>Rather than simply teleporting the state as-is, we can introduce an arbitrary unitary <span class="math notranslate nohighlight">\(U\)</span> that
acts upon <span class="math notranslate nohighlight">\(\ket{\psi}\)</span>, as follows:</p>
<p><img alt="" src="../../../../_images/gate_teleport2.png" /></p>
<p>Now, the action of the unitary <span class="math notranslate nohighlight">\(U\)</span> is similarly teleported along with the initial state
— this is a trivial extension of the local teleportation circuit. In order to view this in
as a measurement-based universal quantum computing primitive, we make a couple of important changes:</p>
<ul class="simple">
<li><p>The inverse Fourier gate is absorbed into the measurement, making it a homodyne detector in
the momentum quadrature</p></li>
<li><p>The unitary gate <span class="math notranslate nohighlight">\(U\)</span>, if diagonal in the computational basis (i.e., it is of the form
<span class="math notranslate nohighlight">\(U=e^{i f(\hat{x}^i)}\)</span>), commutes with the controlled-phase gate
(<span class="math notranslate nohighlight">\(CZ(s)=e^{i s ~\hat{x_1}\otimes\hat{x_2}/\hbar}\)</span>), and can be moved to the right of it.
It is then also absorbed into the projective measurement.</p></li>
</ul>
<p><img alt="" src="../../../../_images/gate_teleport3.png" /></p>
<p>Additional gates can now be added simply by introducing additional qumodes with the appropriate
projective measurements, all ‘stacked vertically’ (i.e., coupled to the each consecutive qumode
via a controlled-phase gate). From this primitive, the model of cluster state quantum computation
can be derived [[3]_].</p>
<blockquote>
<div><p><strong>Note</strong> What happens if the unitary is <em>not</em> diagonal in the computational basis? In this case,
<strong>feedforward</strong> is required; additional qumodes and projective measurements are introduced,
with successive measurements dependent on the previous result [[5]_].</p>
</div></blockquote>
</section>
<section id="code">
<h2>Code<a class="headerlink" href="#code" title="Permalink to this heading">¶</a></h2>
<p>Consider the following gate teleportation circuit,</p>
<p><img alt="" src="../../../../_images/gate_teleport_ex.png" /></p>
<p>Here, the state <span class="math notranslate nohighlight">\(\ket{\psi}\)</span>, a squeezed state with <span class="math notranslate nohighlight">\(r=0.1\)</span>, is teleported to the
final qumode, with the quadratic phase gate (:class:<code class="docutils literal notranslate"><span class="pre">~strawberryfields.ops.Pgate</span></code>)
<span class="math notranslate nohighlight">\(P(s)=e^{is\hat{x}^2/2\hbar}\)</span> teleported to act on it - with the quadratic phase gate
chosen as it is diagonal in the <span class="math notranslate nohighlight">\(\x\)</span> quadrature. This can be easily implemented
using Strawberry Fields:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># set the random seed</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">strawberryfields</span> <span class="k">as</span> <span class="nn">sf</span>
<span class="kn">from</span> <span class="nn">strawberryfields.ops</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">gate_teleportation</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Program</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="k">with</span> <span class="n">gate_teleportation</span><span class="o">.</span><span class="n">context</span> <span class="k">as</span> <span class="n">q</span><span class="p">:</span>
    <span class="c1"># create initial states</span>
    <span class="n">Squeezed</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Squeezed</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>  <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Squeezed</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>  <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># apply the gate to be teleported</span>
    <span class="n">Pgate</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># conditional phase entanglement</span>
    <span class="n">CZgate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">CZgate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="c1"># projective measurement onto</span>
    <span class="c1"># the position quadrature</span>
    <span class="n">Fourier</span><span class="o">.</span><span class="n">H</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">MeasureX</span>  <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Fourier</span><span class="o">.</span><span class="n">H</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">MeasureX</span>  <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Some important notes:</p>
<ul class="simple">
<li><p>As with the :doc:<code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">teleportation</span> <span class="pre">circuit</span> <span class="pre">&lt;run_teleportation&gt;</span></code>, perfectly squeezed vacuum states
are not physically realizable; preparing the states with a squeezing factor of <span class="math notranslate nohighlight">\(|r|=2\)</span>
(<span class="math notranslate nohighlight">\(\sim 18\text{dB}\)</span>) is a reasonable approximation.</p></li>
<li><p>The Blackbird notation <code class="docutils literal notranslate"><span class="pre">Operator.H</span></code> denotes the Hermitian conjugate of the corresponding
operator.</p></li>
<li><p>Here, we do not make the corrections to the final state; this is left as an exercise to the reader.
For additional details, see the gate teleportation commutation relations derived by van Loock
[[5]_].</p></li>
</ul>
<p>Since all operations in the above gate teleportation circuit are Gaussian, we can use the
<code class="docutils literal notranslate"><span class="pre">&quot;gaussian&quot;</span></code> backend:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eng</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Engine</span><span class="p">(</span><span class="n">backend</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Running the engine, and printing out the reduced state of modes 2
and 3:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">results</span> <span class="o">=</span> <span class="n">eng</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">gate_teleportation</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">cov</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">reduced_gaussian</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Covariance matrix:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Covariance matrix:
 [[ 1.11257261 -0.5851662 ]
 [-0.5851662   1.20659044]]
</pre></div>
</div>
</div>
</div>
<p>We can also extract the measurement results of modes 0 and 1:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-1.0330069405382953 10.86483685522621
</pre></div>
</div>
</div>
</div>
<p>To easily check that the output of the circuit is as expected, we can make sure that it agrees
with the (uncorrected) state</p>
<div class="amsmath math notranslate nohighlight" id="equation-14dc1287-0537-4438-bc42-a7b3634f01fd">
<span class="eqno">(9)<a class="headerlink" href="#equation-14dc1287-0537-4438-bc42-a7b3634f01fd" title="Permalink to this equation">¶</a></span>\[\begin{align}X({q_1})FP(0.5)X(q_0)F \ket{z}.\end{align}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">check</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Program</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">with</span> <span class="n">check</span><span class="o">.</span><span class="n">context</span> <span class="k">as</span> <span class="n">q</span><span class="p">:</span>
    <span class="c1"># compare against the expected output</span>
    <span class="c1"># X(q1/sqrt(2)).F.P(0.5).X(q0/sqrt(0.5)).F.|z&gt;</span>
    <span class="c1"># not including the corrections</span>
    <span class="n">Squeezed</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Fourier</span>       <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Xgate</span><span class="p">(</span><span class="n">m0</span><span class="p">)</span>     <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Pgate</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>    <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Fourier</span>       <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Xgate</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>     <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">eng</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Engine</span><span class="p">(</span><span class="n">backend</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">eng</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">check</span><span class="p">)</span>
<span class="n">expected_cov</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">cov</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Expected covariance matrix:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">expected_cov</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Expected covariance matrix:
 [[ 1.12408144 -0.61070138]
 [-0.61070138  1.22140276]]
</pre></div>
</div>
</div>
</div>
<p>These two states should be identical:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">expected_cov</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
</section>
<section id="id2">
<h2>References<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h2>
<p>.. [1] A. Furusawa and P. van Loock. Quantum Teleportation and Entanglement:
A Hybrid Approach to Optical Quantum Information Processing. Wiley, 2011.
ISBN 9783527635290. URL: https://books.google.ca/books?id=eKxHZ0UHEU4C.</p>
<p>.. [2] D. Gottesman and I. L. Chuang. Demonstrating the viability of universal quantum
computation using teleportation and single-qubit operations. Nature,
402:390–393, Nov 1999. arXiv:quant-ph/9908010, doi:10.1038/46503.</p>
<p>.. [3] Mile Gu, Christian Weedbrook, Nicolas C. Menicucci, Timothy C. Ralph, and
Peter van Loock. Quantum computing with continuous-variable clusters.
Physical Review A, 79:062318, Jun 2009. doi:10.1103/PhysRevA.79.062318.</p>
<p>.. [4] Stephen D. Bartlett and William J. Munro. Quantum teleportation of
optical quantum gates. Physical Review Letters, 90:117901, Mar 2003.
doi:10.1103/PhysRevLett.90.117901.</p>
<p>.. [5] Peter van Loock. Examples of gaussian cluster computation. Journal of the
Optical Society of America B, 24(2):340–346, Feb 2007. doi:10.1364/JOSAB.24.000340.</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="gaussian-cloning">
<h1>Gaussian cloning<a class="headerlink" href="#gaussian-cloning" title="Permalink to this heading">¶</a></h1>
<p>A fundamental concept in quantum mechanics, the <code class="docutils literal notranslate"><span class="pre">no-cloning</span> <span class="pre">theorem</span> <span class="pre">&lt;https://en.wikipedia.org/wiki/No-cloning_theorem&gt;</span></code>_ states that an unknown quantum
state cannot be copied exactly [[2]<em>] - in effect, ruling out any algorithm
that attempts to produce or relies upon the production of perfect copies of an arbitrary
quantum state [[3]</em>]. Nevertheless, the no-cloning theorem does not rule out
the production of <em>approximate</em> quantum state clones. This has led to the development
of so called ‘quantum cloning algorithms’, unitary cloning transformations which provide
identical copies of an arbitrary input state, at the cost of a non-unity fidelity.</p>
<section id="id3">
<h2>Implementation<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h2>
<p>The first approximate cloning algorithm was introduced in the context of discrete-variable
quantum computing by Buzek and Hillery [[4]<em>], and quickly followed up with a CV
implementation by Cerf et al. [[5]</em>]. Here, a class of cloning machines
satisfying <em>displacement covariance</em> are introduced; that is, for two input states
<span class="math notranslate nohighlight">\(\ket{\psi}\)</span> and <span class="math notranslate nohighlight">\(\ket{\phi}\)</span>, with approximate cloned states <span class="math notranslate nohighlight">\(\ket{\psi'}\)</span>
and <span class="math notranslate nohighlight">\(\ket{\phi'}\)</span> respectively,</p>
<div class="amsmath math notranslate nohighlight" id="equation-1a200ac5-e4a4-406d-9c41-83c4085a9ade">
<span class="eqno">(10)<a class="headerlink" href="#equation-1a200ac5-e4a4-406d-9c41-83c4085a9ade" title="Permalink to this equation">¶</a></span>\[\begin{align}D(\alpha)\ket{\psi}=\ket{\phi}~~~\Rightarrow~~~D(\alpha)\ket{\psi'}=\ket{\phi'}\end{align}\]</div>
<p>In other words, cloning fidelity is <strong>invariant</strong> under displacements in the phase space,
and the position and momentum uncertainties of the two clones satisfies the uncertainty inequality</p>
<div class="amsmath math notranslate nohighlight" id="equation-9c034f46-b2a9-4d8c-92aa-fd7f0b95fb1f">
<span class="eqno">(11)<a class="headerlink" href="#equation-9c034f46-b2a9-4d8c-92aa-fd7f0b95fb1f" title="Permalink to this equation">¶</a></span>\[\begin{align}\Delta x_1\Delta p_2 \geq \frac{1}{2}\hbar\end{align}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta x_1\)</span> is the <span class="math notranslate nohighlight">\(x\)</span> quadrature variance of state <span class="math notranslate nohighlight">\(\ket{\psi}\)</span>
and <span class="math notranslate nohighlight">\(\Delta p_2\)</span> is the <span class="math notranslate nohighlight">\(p\)</span> quadrature variance of state <span class="math notranslate nohighlight">\(\ket{\phi}\)</span>.</p>
<p><strong>Gaussian cloning algorithms</strong>, those with the ability to produce two approximate and
identical clones of the input state with theoretically optimum fidelity, are a subclass
of the displacement covariant cloners that also exhibit <strong>rotational covariance</strong>. As a
result, Gaussian cloning fidelity is invariant under both displacement and rotation in the
phase space, and the resulting cloned states have identical <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(p\)</span>
quadrature variances, <span class="math notranslate nohighlight">\(\Delta x_1=\Delta p_1=\Delta x_2=\Delta p_2\)</span>. It is this
subclass which is shown to be the CV equivalent to the universal qubit cloner of Buzek
and Hillery [[5]_].</p>
<section id="circuit-analysis">
<h3>Circuit analysis<a class="headerlink" href="#circuit-analysis" title="Permalink to this heading">¶</a></h3>
<p>Working within this framework, Andersen et al. [[6]_] presented a symmetric
Gaussian cloning algorithm (in addition to experimental results) for optimum theoretical
cloning of coherent states:</p>
<p><img alt="" src="../../../../_images/cloning.png" /></p>
<p>Here, <span class="math notranslate nohighlight">\(\ket{\alpha_0}\)</span> represents an input coherent state, <span class="math notranslate nohighlight">\(\ket{\alpha'}_1\)</span>
and <span class="math notranslate nohighlight">\(\ket{\alpha'}_3\)</span> represent the two identical but approximate clones, and the
beamsplitters are 50-50 beamsplitters (hence the ‘symmetric’ in symmetric cloning algorithm).
Let’s walk through the various stages of the circuit above, and examine what is occuring.</p>
<ol class="arabic">
<li><p>The action of a 50-50 beamsplitter on a coherent state <span class="math notranslate nohighlight">\(\ket{\alpha}\)</span> and a vacuum
state <span class="math notranslate nohighlight">\(\ket{0}\)</span> is
<span class="math notranslate nohighlight">\(BS(\ket{\alpha}\otimes\ket{0}) = \ket{\frac{1}{\sqrt{2}}\alpha}\otimes \ket{\frac{1}{\sqrt{2}}\alpha}\)</span>.
As such, after the two beamsplitters, the circuit exists in the following state:</p>
<div class="math notranslate nohighlight">
\[       \ket{\frac{1}{\sqrt{2}}\alpha_0}\otimes \ket{\frac{1}{2}\alpha_0}\otimes \ket{\frac{1}{2}\alpha_0}.
   \]</div>
</li>
<li><p>Performing the homodyne detection on modes <span class="math notranslate nohighlight">\(q_1\)</span> and <span class="math notranslate nohighlight">\(q_2\)</span> results in
the two normally distributed measurement variables <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> respectively:</p>
<div class="math notranslate nohighlight">
\[
       u\sim N\left(\sqrt{\frac{\hbar}{2}}\text{Re}(\alpha_0),
       \frac{\hbar}{2}\right), ~~~ v\sim N\left(\sqrt{\frac{\hbar}{2}}\text{Im}(\alpha_0),
       \frac{\hbar}{2}\right).
   \]</div>
</li>
<li><p>Two controlled displacements <span class="math notranslate nohighlight">\(X(\sqrt{2}u)=D(u/\sqrt{\hbar})\)</span> and
<span class="math notranslate nohighlight">\(Z(\sqrt{2}v)=D(iv/\sqrt{\hbar})\)</span> are then performed on mode <span class="math notranslate nohighlight">\(q_0\)</span>:</p>
<div class="math notranslate nohighlight">
\[       D\left(\frac{1}{\sqrt{\hbar}}(u+iv)\right)\ket{\frac{1}{\sqrt{2}}\alpha_0}
       = \ket{\frac{1}{\sqrt{2}}\alpha_0 + \frac{1}{\sqrt{\hbar}}(u+iv)} = \ket{\tilde{\alpha_0}}
   \]</div>
<p>Since we are displacing a coherent state, the result of the controlled displacements
remains a pure coherent state. However, since the parameters of the controlled displacements
are themselves random variables, we must describe the resulting coherent state by a rando
variable <span class="math notranslate nohighlight">\(\tilde{\alpha_0} \sim N(\mu, \text{cov})\)</span>.</p>
<p>Here, <span class="math notranslate nohighlight">\(\tilde{\alpha_0}\)</span> is randomly distributed as per a multivariate normal
distribution with vector of means <span class="math notranslate nohighlight">\(\mu=\sqrt{2}(\text{Re}(\alpha_0), \text{Im}(\alpha_0))\)</span>
and covariance matrix <span class="math notranslate nohighlight">\(\text{cov}=\I/2\)</span>.</p>
</li>
<li><p>Finally, we apply another beamsplitter to mode <span class="math notranslate nohighlight">\(q_0\)</span> and mode <span class="math notranslate nohighlight">\(q_3\)</span> in the
vacuum state, to get our two cloned outputs:</p>
<div class="math notranslate nohighlight">
\[       BS(\ket{\tilde{\alpha_0}}\otimes\ket{0}) = \ket{\frac{1}{\sqrt{2}}\tilde{\alpha_0}}\otimes
       \ket{\frac{1}{\sqrt{2}}\tilde{\alpha_0}} = \ket{\alpha'}\otimes \ket{\alpha'}.
   \]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha' \sim N(\mu, \text{cov}), ~~\mu=(\text{Re}(\alpha_0), \text{Im}(\alpha_0)), ~~\text{cov}=\I/4\)</span>.</p>
</li>
</ol>
</section>
<section id="coherent-average-fidelity">
<h3>Coherent average fidelity<a class="headerlink" href="#coherent-average-fidelity" title="Permalink to this heading">¶</a></h3>
<p>If we were to perform the Guassian cloning circuit over an ensemble of identical input
states <span class="math notranslate nohighlight">\(\ket{\alpha_0}\)</span>, the cloned output can be described by the following mixed state,</p>
<div class="amsmath math notranslate nohighlight" id="equation-21591d43-c0c4-464e-9865-ea81abc08a44">
<span class="eqno">(12)<a class="headerlink" href="#equation-21591d43-c0c4-464e-9865-ea81abc08a44" title="Permalink to this equation">¶</a></span>\[\begin{align}\rho = \iint d^2 \alpha' \frac{2}{\pi}e^{-2|\alpha'-\alpha_0|^2}\ket{\alpha'}\bra{\alpha'},\end{align}\]</div>
<p>where the exponential term is the PDF of the random variable <span class="math notranslate nohighlight">\(\alpha'\)</span> from (4) above.
To calculate the average fidelity over the ensemble of the cloned states, it is sufficient
to calculate the inner product</p>
<div class="amsmath math notranslate nohighlight" id="equation-c076607a-a330-4eba-8551-faa956ed6ae1">
<span class="eqno">(13)<a class="headerlink" href="#equation-c076607a-a330-4eba-8551-faa956ed6ae1" title="Permalink to this equation">¶</a></span>\[\begin{align}F = \braketT{\alpha_0}{\rho}{\alpha_0}.\end{align}\]</div>
<p>From the Fock basis decomposition of the coherent state (see <code class="docutils literal notranslate"><span class="pre">coherent_state</span></code>), it can
be easily seen that <span class="math notranslate nohighlight">\(|\braketD{\alpha_0}{\alpha'}|^2 = e^{-|\alpha_0-\alpha'|^2}\)</span>.
Therefore,</p>
<div class="amsmath math notranslate nohighlight" id="equation-a3131327-5c5e-41e6-beed-8009b40309cb">
<span class="eqno">(14)<a class="headerlink" href="#equation-a3131327-5c5e-41e6-beed-8009b40309cb" title="Permalink to this equation">¶</a></span>\[\begin{align}F = \frac{2}{\pi}\iint d^2 \alpha' e^{-2|\alpha'-\alpha_0|^2}
    |\braketD{\alpha_0}{\alpha'}|^2 = \frac{2}{\pi}\iint d^2 \alpha ~e^{-3|\alpha|^2} = \frac{2}{3},\end{align}\]</div>
<p>where we have made the substitution <span class="math notranslate nohighlight">\(\alpha=\alpha'-\alpha_0\)</span>. Note that the
average fidelity is independent of the initial state <span class="math notranslate nohighlight">\(\alpha_0\)</span>.</p>
<blockquote>
<div><p><strong>Note</strong> The above is calculated in the case of unity quantum efficiency <span class="math notranslate nohighlight">\(\eta=1\)</span>.
When <span class="math notranslate nohighlight">\(\eta&lt;1\)</span>, there is non-zero uncertainty in the homodyne measurement,
<span class="math notranslate nohighlight">\(\sigma_H=\frac{1-\eta}{\eta}\)</span>, and in practice the symmetric Gaussian cloning
scheme has coherent state average cloning fidelity given by</p>
</div></blockquote>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$$
 F(\sigma_H)=\frac{2}{3+\sigma_H}
$$

In the case of the Gaussian backend, $\sigma_H=2\times 10^{-4}$
(see `GaussianBackend.measure_homodyne
&lt;strawberryfields.backends.GaussianBackend.measure_homodyne&gt;`).
</pre></div>
</div>
</section>
<section id="displaced-squeezed-states">
<h3>Displaced squeezed states<a class="headerlink" href="#displaced-squeezed-states" title="Permalink to this heading">¶</a></h3>
<p>In addition to coherent states, this cloning scheme was further analysed by
Olivares et al. [[7]_] in the cases of other Gaussian input states,
such as squeezed states and thermal states. In particular, when the input Gaussian
state is a <strong>displaced squeezed state</strong>,</p>
<div class="amsmath math notranslate nohighlight" id="equation-28bc3ccd-e3e3-49f8-9a1a-1737b3359656">
<span class="eqno">(15)<a class="headerlink" href="#equation-28bc3ccd-e3e3-49f8-9a1a-1737b3359656" title="Permalink to this equation">¶</a></span>\[\begin{align}\ket{\psi} = \ket{\alpha,z} = D(\alpha)S(z)\ket{0},\end{align}\]</div>
<p>this scheme provides an optimum fidelity of <span class="math notranslate nohighlight">\(2/3\)</span> <em>only</em> if the squeezing parameter
is known beforehand, as this allows the application of the unitary operation <span class="math notranslate nohighlight">\(S(z)^{-1}\)</span>
to recover a coherent state prior to cloning. Of course, this is not possible if we wish
to clone an arbitrary unknown displaced squeezed state; in this case, the scheme described
above leads to the following fidelity:</p>
<div class="amsmath math notranslate nohighlight" id="equation-112abdfb-749f-4e70-a17f-cb5fc17fba84">
<span class="eqno">(16)<a class="headerlink" href="#equation-112abdfb-749f-4e70-a17f-cb5fc17fba84" title="Permalink to this equation">¶</a></span>\[\begin{align}F(r,\sigma_H) = \frac{4}{\sqrt{(6+2\sigma_H)^2+32(1+\sigma_H)\sinh^2(r)}}\end{align}\]</div>
<p>where <span class="math notranslate nohighlight">\(z=re^{i\phi}\)</span> and <span class="math notranslate nohighlight">\(\sigma_H\)</span> is the uncertainty in the homodyne
measurement. Note that <span class="math notranslate nohighlight">\(F\rightarrow0\)</span> as <span class="math notranslate nohighlight">\(r\rightarrow\infty\)</span>; i.e.,
the more highly squeezed the state, the lower the cloning fidelity.</p>
</section>
</section>
<section id="id4">
<h2>Code<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h2>
<p>The symmetric Gaussian cloning circuit displayed above can be implemented using
Strawberry Fields:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">strawberryfields</span> <span class="k">as</span> <span class="nn">sf</span>
<span class="kn">from</span> <span class="nn">strawberryfields.ops</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">gaussian_cloning</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Program</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="k">with</span> <span class="n">gaussian_cloning</span><span class="o">.</span><span class="n">context</span> <span class="k">as</span> <span class="n">q</span><span class="p">:</span>
    <span class="c1"># state to be cloned</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.7</span><span class="o">+</span><span class="mf">1.2</span><span class="n">j</span>
    <span class="n">Coherent</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># 50-50 beamsplitter</span>
    <span class="n">BS</span> <span class="o">=</span> <span class="n">BSgate</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># symmetric Gaussian cloning scheme</span>
    <span class="n">BS</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">BS</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">MeasureX</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">MeasureP</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">Xgate</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">par</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Zgate</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">par</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># after the final beamsplitter, modes q[0] and q[3]</span>
    <span class="c1"># will contain identical approximate clones of the</span>
    <span class="c1"># initial state Coherent(0.1+0j)</span>
    <span class="n">BS</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>Since all operations and measurements are Gaussian, we can use
the Gaussian backend:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eng</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Engine</span><span class="p">(</span><span class="n">backend</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Modes 1 and 2 are ancilla modes; we are interested in extracting modes
0 and 3.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">results</span> <span class="o">=</span> <span class="n">eng</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">gaussian_cloning</span><span class="p">,</span> <span class="n">modes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>After constructing the circuit and running the engine,
we can call the :doc:<code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">method</span> <span class="pre">&lt;introduction/states&gt;</span></code>
:meth:<code class="docutils literal notranslate"><span class="pre">~strawberryfields.backends.BaseState.fidelity_coherent</span></code>
to calculate the fidelity of the two cloned output states compared to the input coherent
state <span class="math notranslate nohighlight">\(\alpha=0.7+1.2j\)</span>.</p>
<p>Note that we take the square root since the
method is returning the fidelity of both modes multiplied.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fidelity</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">fidelity_coherent</span><span class="p">([</span><span class="mf">0.7</span><span class="o">+</span><span class="mf">1.2</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.7</span><span class="o">+</span><span class="mf">1.2</span><span class="n">j</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fidelity</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.8513397014072269
</pre></div>
</div>
</div>
</div>
<p>While <code class="docutils literal notranslate"><span class="pre">fidelity_coherent</span></code> is supported by both the Gaussian and the Fock
backends, the <code class="docutils literal notranslate"><span class="pre">'gaussian'</span></code> backend additionally supports extracting
the mean displacement of output states, using
:meth:<code class="docutils literal notranslate"><span class="pre">~strawberryfields.backends.BaseGaussianState.displacement</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">alpha</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">displacement</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Checking that they are identical clones up to numerical error:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">1e-15</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>In order to calculate the average fidelity over an ensemble, we will need to run
the circuit multiple times, and calculate the mean fidelity over all runs:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># run the engine over an ensemble</span>
<span class="n">reps</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">reps</span><span class="p">])</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">reps</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>
    <span class="n">eng</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">eng</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">gaussian_cloning</span><span class="p">,</span> <span class="n">modes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">fidelity_coherent</span><span class="p">([</span><span class="mf">0.7</span><span class="o">+</span><span class="mf">1.2</span><span class="n">j</span><span class="p">])</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">displacement</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fidelity of cloned state:&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mean displacement of cloned state:&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mean covariance matrix of cloned state:&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">imag</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Fidelity of cloned state: 0.6598444030393031
Mean displacement of cloned state: (0.7128811228904935+1.2138191837988184j)
Mean covariance matrix of cloned state: [[0.25603526 0.00118158]
 [0.00118158 0.25295683]]
</pre></div>
</div>
</div>
</div>
<p>Plotting the scatter plot of <code class="docutils literal notranslate"><span class="pre">a.real</span></code> vs. <code class="docutils literal notranslate"><span class="pre">a.imag</span></code>, we see that they are indeed
distributed as a multivariate normal distribution, with a mean of <span class="math notranslate nohighlight">\(\sim 0.7+1.2j\)</span>,
and covariance <span class="math notranslate nohighlight">\(\sim I/4\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="n">sns</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s2">&quot;ticks&quot;</span><span class="p">)</span>
<span class="n">sns</span><span class="o">.</span><span class="n">jointplot</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#4CB391&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">ModuleNotFoundError</span><span class="g g-Whitespace">                       </span>Traceback (most recent call last)
<span class="nn">Input In [40],</span> in <span class="ni">&lt;cell line: 1&gt;</span><span class="nt">()</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span> <span class="n">sns</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s2">&quot;ticks&quot;</span><span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span> <span class="n">sns</span><span class="o">.</span><span class="n">jointplot</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;#4CB391&quot;</span><span class="p">)</span>

<span class="ne">ModuleNotFoundError</span>: No module named &#39;seaborn&#39;
</pre></div>
</div>
</div>
</div>
</section>
<section id="id5">
<h2>References<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h2>
<p>.. [1] P. van Loock and Samuel L. Braunstein. Telecloning of continuous quantum variables.
Physical Review Letters, Nov 2001. doi:10.1103/physrevlett.87.247901.</p>
<p>.. [2] W. K. Wootters and W. H. Zurek. A single quantum cannot be cloned.
Nature, 299(5886):802–803, Oct 1982. doi:10.1038/299802a0.</p>
<p>.. [3] D. Dieks. Communication by EPR devices. Physics Letters A, 92(6):271–272,
Nov 1982. doi:10.1016/0375-9601(82)90084-6.</p>
<p>.. [4] V. Bužek and M. Hillery. Quantum copying: beyond the no-cloning theorem.
Physical Review A, 54(3):1844–1852, Sep 1996. doi:10.1103/physreva.54.1844.</p>
<p>.. [5] N. J. Cerf, A. Ipe, and X. Rottenberg. Cloning of continuous quantum variables.
Physical Review Letters, 85(8):1754–1757, Aug 2000. doi:10.1103/physrevlett.85.1754.</p>
<p>.. [6] Ulrik L. Andersen, Vincent Josse, and Gerd Leuchs. Unconditional quantum cloning
of coherent states with linear optics. Physical Review Letters, Jun 2005.
doi:10.1103/physrevlett.94.240503.</p>
<p>.. [7] Stefano Olivares, Matteo G. A. Paris, and Ulrik L. Andersen. Cloning of gaussian
states by linear optics. Physical Review A, Jun 2006. doi:10.1103/physreva.73.062330.</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="hamiltonian-simulation">
<h1>Hamiltonian simulation<a class="headerlink" href="#hamiltonian-simulation" title="Permalink to this heading">¶</a></h1>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;The problem of simulating the dynamics of quantum systems was the original motivation for quantum
computers and remains one of their major potential applications.&quot; - Berry et al. [[1]_]
</pre></div>
</div>
<p>The simulation of atoms, molecules and other biochemical systems is another application uniquely
suited to quantum computation. For example, the ground state energy of large systems, the dynamical
behaviour of an ensemble of molecules, or complex molecular behaviour such as protein folding, are
often computationally hard or downright impossible to determine via classical computation or
experimentation [[2]<em>][[3]</em>].</p>
<p>In the discrete-variable qubit model, efficient methods of Hamiltonian simulation have been
discussed at-length, providing several implementations depending on properties of the Hamiltonian,
and resulting in a linear simulation time [[4]<em>][[5]</em>].
Efficient implementations of Hamiltonian simulation also exist in the CV formulation
[[6]<em>], with specific application to <code class="docutils literal notranslate"><span class="pre">Bose-Hubbard</span> <span class="pre">Hamiltonians</span> <span class="pre">&lt;https://en.wikipedia.org/wiki/Bose%E2%80%93Hubbard_model&gt;</span></code></em> (describing a system of interacting
bosonic particles on a lattice of orthogonal position states [[7]_]). As
such, this method is ideally suited to photonic quantum computation.</p>
<section id="id6">
<h2>Implementation<a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h2>
<p>For a quick example, consider a lattice composed of two adjacent nodes:</p>
<p><img alt="" src="../../../../_images/graph.png" /></p>
<p>This graph is represented by the <span class="math notranslate nohighlight">\(2\times 2\)</span> adjacency matrix
<span class="math notranslate nohighlight">\(A=\begin{bmatrix}0&amp;1\\1&amp;0\end{bmatrix}\)</span>. Here, each node in the graph represents a qumode, so
we can model the dynamics of Bosons on this structure via a 2-qumode CV circuit.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Bose-Hubbard</span> <span class="pre">Hamiltonian</span> <span class="pre">&lt;https://en.wikipedia.org/wiki/Bose%E2%80%93Hubbard_model&gt;</span></code>_ with
on-site interactions is given by</p>
<div class="amsmath math notranslate nohighlight" id="equation-d632b770-53ce-4ba0-a08e-a2988e409eb2">
<span class="eqno">(17)<a class="headerlink" href="#equation-d632b770-53ce-4ba0-a08e-a2988e409eb2" title="Permalink to this equation">¶</a></span>\[\begin{align}H = J\sum_{i}\sum_j A_{ij} \ad_i\a_j + \frac{1}{2}U\sum_i \hat{n}_i(\hat{n}_i-1)= J(\ad_1 \a_2 +
    \ad_2\a_1) + \frac{1}{2}U (  \hat{n}_1^2 - \hat{n}_1 + \hat{n}_2^2 - \hat{n}_2)\end{align}\]</div>
<p>where <span class="math notranslate nohighlight">\(J\)</span> represents the transfer integral or hopping term of the boson between nodes, and
<span class="math notranslate nohighlight">\(U\)</span> is the on-site interaction potential. Here, <span class="math notranslate nohighlight">\(\ad_1 \a_2\)</span> represents a boson
transitioning from node 1 to node 2, while <span class="math notranslate nohighlight">\(\ad_2\a_1\)</span> represents a boson transitioning from
node 2 to node 1, and <span class="math notranslate nohighlight">\(\hat{n}_i=\ad_i\a_i\)</span> is the number operator applied to mode <span class="math notranslate nohighlight">\(i\)</span>.
Applying the Lie-product formula, we find that</p>
<div class="amsmath math notranslate nohighlight" id="equation-8bc87535-2b5d-43f0-bf09-b01a38ae8d65">
<span class="eqno">(18)<a class="headerlink" href="#equation-8bc87535-2b5d-43f0-bf09-b01a38ae8d65" title="Permalink to this equation">¶</a></span>\[\begin{align}e^{-iHt} = \left[\exp\left({-i\frac{ J t}{k}(\ad_1 \a_2 +
    \ad_2\a_1)}\right)\exp\left(-i\frac{Ut}{2k}\hat{n}_1^2\right)\exp\left(-i\frac{Ut}{2k}\hat{n}_2^2\right)
    \exp\left(i\frac{Ut}{2k}\hat{n}_1\right)\exp\left(i\frac{Ut}{2k}\hat{n}_2\right)\right]^k+\mathcal{O}\left(t^2/k\right),\end{align}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{O}\left(t^2/k\right)\)</span> is the order of the error term, derived from the Lie
product formula. Comparing this to the form of various CV gates, we can write this as the product of
<code class="docutils literal notranslate"><span class="pre">symmetric</span> <span class="pre">beamsplitters</span> <span class="pre">&lt;beamsplitter&gt;</span></code> (<code class="docutils literal notranslate"><span class="pre">~strawberryfields.ops.BSgate</span></code>), <code class="docutils literal notranslate"><span class="pre">Kerr</span> <span class="pre">gates</span> <span class="pre">&lt;kerr&gt;</span></code>
(<code class="docutils literal notranslate"><span class="pre">~strawberryfields.ops.Kgate</span></code>), and <code class="docutils literal notranslate"><span class="pre">rotation</span> <span class="pre">gates</span> <span class="pre">&lt;rotation&gt;</span></code>
(<code class="docutils literal notranslate"><span class="pre">~strawberryfields.ops.Rgate</span></code>):</p>
<div class="math notranslate nohighlight">
\[
\begin{align}e^{iHt} = \left[BS\left(\theta,\phi\right)\left(K(r)R(-r)\otimes
    K(r)R(-r)\right)\right]^k+\mathcal{O}\left(t^2/k\right).\end{align}
\]</div>
<p>where <span class="math notranslate nohighlight">\(\theta=-Jt/k\)</span>, <span class="math notranslate nohighlight">\(\phi=\pi/2\)</span>, and <span class="math notranslate nohighlight">\(r=-Ut/2k\)</span>.</p>
<p>For the case <span class="math notranslate nohighlight">\(k=2\)</span>, this can be drawn as the circuit diagram</p>
<p><img alt="" src="../../../../_images/hamsim.png" /></p>
<p>For more complex CV decompositions, including those with interactions, see Kalajdzievski et al.
[[6]_] for more details.</p>
</section>
<section id="id7">
<h2>Code<a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h2>
<p>The Hamiltonian simulation circuit displayed above for the 2-node lattice, can be implemented using
Strawberry Fields:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># set the random seed</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">strawberryfields</span> <span class="k">as</span> <span class="nn">sf</span>
<span class="kn">from</span> <span class="nn">strawberryfields.ops</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">ham_simulation</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Program</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># set the Hamiltonian parameters</span>
<span class="n">J</span> <span class="o">=</span> <span class="mi">1</span>           <span class="c1"># hopping transition</span>
<span class="n">U</span> <span class="o">=</span> <span class="mf">1.5</span>         <span class="c1"># on-site interaction</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">20</span>          <span class="c1"># Lie product decomposition terms</span>
<span class="n">t</span> <span class="o">=</span> <span class="mf">1.086</span>       <span class="c1"># timestep</span>
<span class="n">theta</span> <span class="o">=</span> <span class="o">-</span><span class="n">J</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="n">k</span>
<span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="n">U</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">)</span>

<span class="k">with</span> <span class="n">ham_simulation</span><span class="o">.</span><span class="n">context</span> <span class="k">as</span> <span class="n">q</span><span class="p">:</span>
    <span class="c1"># prepare the initial state</span>
    <span class="n">Fock</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Two node tight-binding</span>
    <span class="c1"># Hamiltonian simulation</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="n">BSgate</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">Kgate</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>  <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Rgate</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Kgate</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>  <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Rgate</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>where, for this example, we have set <code class="docutils literal notranslate"><span class="pre">J=1</span></code>, <code class="docutils literal notranslate"><span class="pre">U=1.5</span></code>, <code class="docutils literal notranslate"><span class="pre">k=20</span></code>, <code class="docutils literal notranslate"><span class="pre">t=1.086</span></code>, <code class="docutils literal notranslate"><span class="pre">theta</span> <span class="pre">=</span> <span class="pre">-J*t/k</span></code>, and <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">=</span> <span class="pre">-U*t/(2*k)</span></code>.</p>
<p>Since are initial state is non-Gaussian, we will initialize the <code class="docutils literal notranslate"><span class="pre">&quot;fock&quot;</span></code>
backend, with a cutoff of 5:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eng</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Engine</span><span class="p">(</span><span class="n">backend</span><span class="o">=</span><span class="s2">&quot;fock&quot;</span><span class="p">,</span> <span class="n">backend_options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;cutoff_dim&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<p>After constructing the circuit and running the engine,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">results</span> <span class="o">=</span> <span class="n">eng</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">ham_simulation</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>the site occupation probabilities can be calculated via the
<code class="docutils literal notranslate"><span class="pre">fock_prob</span></code> state method, which returns the probability of
measuring some output Fock state:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">state</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">state</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;P(|0, 2&gt;) = &quot;</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">fock_prob</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;P(|1, 1&gt;) = &quot;</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">fock_prob</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;P(|2, 0&gt;) = &quot;</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">fock_prob</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
</div>
</div>
<p>As Hamiltonian simulation is particle preserving, these probabilities should add up to one:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">fock_prob</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">state</span><span class="o">.</span><span class="n">fock_prob</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">state</span><span class="o">.</span><span class="n">fock_prob</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>We can compare this result to the analytic matrix exponential <span class="math notranslate nohighlight">\(e^{-iHt}\)</span>, where the matrix
elements of <span class="math notranslate nohighlight">\(H\)</span> can be computed in the Fock basis. Considering the diagonal interaction
terms,</p>
<div class="amsmath math notranslate nohighlight" id="equation-bf4d1ab9-a7f0-480a-8bbf-fe03dbaf1f30">
<span class="eqno">(19)<a class="headerlink" href="#equation-bf4d1ab9-a7f0-480a-8bbf-fe03dbaf1f30" title="Permalink to this equation">¶</a></span>\[\begin{align}&amp; \braketT{0,2}{H}{0,2} = \frac{1}{2}U\braketT{0}{(\hat{n}^2-\hat{n})}{0} +
    \frac{1}{2}U\braketT{2}{(\hat{n}^2-\hat{n})}{2} = \frac{1}{2}U(2^2-2) = U\\[7pt] &amp;
    \braketT{1,1}{H}{1,1} = 0\\[7pt] &amp; \braketT{2,0}{H}{2,0} = U\end{align}\]</div>
<p>as well as the off-diagonal hopping terms,</p>
<div class="amsmath math notranslate nohighlight" id="equation-fa163a93-6dd1-4816-b753-68f252816caa">
<span class="eqno">(20)<a class="headerlink" href="#equation-fa163a93-6dd1-4816-b753-68f252816caa" title="Permalink to this equation">¶</a></span>\[\begin{align}&amp; \braketT{1,1}{H}{0,2} = J\braketT{1,1}{\left(\ad_1\a_2 + \a_1\ad_2\right)}{0,2} =
    J(\sqrt{1}\sqrt{2} + \sqrt{0}\sqrt{3}) = J\sqrt{2}\\[7pt] &amp; \braketT{1,1}{H}{2,0} = J\sqrt{2}\end{align}\]</div>
<p>and taking into account the Hermiticity of the system, we arrive at</p>
<div class="amsmath math notranslate nohighlight" id="equation-6075ba7a-46a3-4be5-9701-3aae894a7d91">
<span class="eqno">(21)<a class="headerlink" href="#equation-6075ba7a-46a3-4be5-9701-3aae894a7d91" title="Permalink to this equation">¶</a></span>\[\begin{align}H = \begin{bmatrix}U&amp;J\sqrt{2}&amp;0\\ J\sqrt{2} &amp; 0 &amp; J\sqrt{2}\\ 0 &amp; J\sqrt{2} &amp; U\end{bmatrix}\end{align}\]</div>
<p>which acts on the Fock basis <span class="math notranslate nohighlight">\(\{\ket{0,2},\ket{1,1},\ket{2,0}\}\)</span>. Using the SciPy matrix
exponential function <code class="docutils literal notranslate"><span class="pre">scipy.linalg.expm</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">expm</span>

<span class="n">H</span> <span class="o">=</span> <span class="n">J</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span> <span class="o">+</span> <span class="n">U</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">init_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>

<span class="n">theoretical_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">expm</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">H</span><span class="p">),</span> <span class="n">init_state</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">theoretical_result</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>which agrees, within the expected error margin, with our Strawberry Fields Hamiltonian simulation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">theoretical_result</span> <span class="o">-</span> <span class="n">result</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-2</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id8">
<h2>References<a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h2>
<p>.. [1] Dominic W. Berry, Andrew M. Childs, and Robin Kothari. Hamiltonian simulation with nearly optimal
dependence on all parameters. In 2015 IEEE 56th Annual Symposium on Foundations of Computer Science.
IEEE, Oct 2015. doi:10.1109/focs.2015.54.</p>
<p>.. [2] Alán Aspuru-Guzik, Anthony D. Dutoi, Peter J. Love, and Martin Head-Gordon. Simulated quantum
computation of molecular energies. Science, 309(5741):1704–1707, 2005. doi:10.1126/science.1113479.</p>
<p>.. [3] James D. Whitfield, Jacob Biamonte, and Alán Aspuru-Guzik. Simulation of electronic structure
Hamiltonians using quantum computers. Molecular Physics, 109(5):735–750, 2011.
doi:10.1080/00268976.2011.552441.</p>
<p>.. [4] Andrew M. Childs and Nathan Wiebe. Hamiltonian simulation using linear combinations of unitary
operations. Quantum Information and Computation, 12(11-12):901–924, 2012. arXiv:1202.5822.</p>
<p>.. [5] Dominic W. Berry, Graeme Ahokas, Richard Cleve, and Barry C. Sanders. Efficient quantum algorithms
for simulating sparse Hamiltonians. Communications in Mathematical Physics, 270(2):359–371, 2006.
doi:10.1007/s00220-006-0150-x.</p>
<p>.. [6] Timjan Kalajdzievski, Christian Weedbrook, and Patrick Rebentrost. Continuous-variable gate
decomposition for the Bose-Hubbard model. 2018. arXiv:1801.06565.</p>
<p>.. [7] Tomasz Sowiński, Omjyoti Dutta, Philipp Hauke, Luca Tagliacozzo, and Maciej Lewenstein. Dipolar
molecules in optical lattices. Physical Review Letters, 108:115301, 2012.
doi:10.1103/PhysRevLett.108.115301.</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="time-domain-photonic-circuits">
<h1>Time-domain photonic circuits<a class="headerlink" href="#time-domain-photonic-circuits" title="Permalink to this heading">¶</a></h1>
<p><em>Authors: Fabian Laudenbach, Josh Izaac, Theodor Isacsson, and Nicolas
Quesada</em></p>
<p>In this tutorial, we will introduce the basic concepts of time-domain photonic circuits
— the same technology underpinning Xanadu’s :doc:<code class="docutils literal notranslate"><span class="pre">quantum</span> <span class="pre">computational</span> <span class="pre">advantage</span> <span class="pre">hardware</span> <span class="pre">&lt;/demos/tutorial_borealis_beginner&gt;</span></code>, Borealis [[#advantage2022]<em>] —
using the time-domain module of StrawberryFields, <code class="docutils literal notranslate"><span class="pre">strawberryfields.tdm</span></code>.
Time-domain multiplexing allows for the creation of massive quantum systems having
millions of entangled modes as shown in a number of recent experimental demonstrations [[#takeda2019]</em>],
[[#yoshikawa2016]<em>], [[#larsen2019]</em>], [[#asavanant2019]<em>].
To motivate this architecture we follow Takeda et al. [[#takeda2019]</em>] and
study the one loop setup shown in the picture below:</p>
<p><img alt="" src="../../../../_images/oneloop.png" /></p>
<p>We will first write a short standard StrawberryFields program implementing
this. Then we will progressively modify the way this circuit is
implemented until we are able to write it directly as a :class:<code class="docutils literal notranslate"><span class="pre">~strawberryfields.TDMProgram</span></code>.</p>
<p>Having understood the basics of time-domain programs we will then construct a generic
single-loop function that can be used to simulate arbitrary long programs using only two
modes! We will use this machinery to investigate bipartite EPR states and then
multipartite GHZ states. An important take away of this tutorial is that one can sample
efficiently Gaussian circuits containing millions of modes with the equivalent
computation effort of sampling Gaussian circuits with just a handful of modes.</p>
<section id="an-instruction-set-for-the-time-domain-architecture">
<h2>An instruction set for the time-domain architecture<a class="headerlink" href="#an-instruction-set-for-the-time-domain-architecture" title="Permalink to this heading">¶</a></h2>
<p>To introduce the time domain architecture we will simulate the setup in
the figure. We can summarize the setup as the following set of
intructions:</p>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">i+1</span></code> mode is squeezed by a certain amount <code class="docutils literal notranslate"><span class="pre">r</span></code>.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">i+1</span></code> mode undergoes a beamsplitter transformation with its
preceding mode, labeled by <code class="docutils literal notranslate"><span class="pre">i</span></code>, by a certain angle <code class="docutils literal notranslate"><span class="pre">alpha[i]</span></code>.
This beamsplitter has the effect of switching in and out of the loop
the modes <code class="docutils literal notranslate"><span class="pre">i+1</span></code> and <code class="docutils literal notranslate"><span class="pre">i</span></code> respectively.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">i+1</span></code> mode has entered the loop after the beamsplitter
transformation and is rotated by angle <code class="docutils literal notranslate"><span class="pre">phi[i]</span></code>.</p></li>
<li><p>After interacting with the <code class="docutils literal notranslate"><span class="pre">i+1</span></code> mode, the mode in the previous
time bin <code class="docutils literal notranslate"><span class="pre">i</span></code> leaves the loop and then its rotated quadrature (by angle
<code class="docutils literal notranslate"><span class="pre">theta[i]</span></code>) is measured using a homodyne detector.</p></li>
</ol>
<p>This circuit falls within the time-domain description because we are
implicitly assuming that the modes are flying through the optical elements
(squeezer, beamsplitter, rotation, measurement) in the figure above.
Note that the loop in the figure corresponds physically to a delay line,
typically implemented using propagation in free space or in an optical fiber.
Thus unlike in many other physical implementations
our modes are not labeled by a position in space but by a time label that
tells us when they arrived to a particular optical element.</p>
<p>Before actually trying to take advantage of the time-domain description
of the circuit we will write a brute force simulation using the
standard :class:<code class="docutils literal notranslate"><span class="pre">~strawberryfields.Program</span></code>.</p>
<p>We will use <code class="docutils literal notranslate"><span class="pre">n</span></code> modes to represent <code class="docutils literal notranslate"><span class="pre">n</span></code> timebins and implement the
setup described by the figure using a standard StrawberryFields
program.</p>
<p>Since we will be using a Gaussian circuit this implies that we will be using
a covariance matrix of size <code class="docutils literal notranslate"><span class="pre">2n</span></code> times <code class="docutils literal notranslate"><span class="pre">2n</span></code> to represent our state. Thus,
if we have for example <code class="docutils literal notranslate"><span class="pre">n=1000</span></code> modes we will have on the order of four million
real numbers stored in memory. We will however, just stick to <code class="docutils literal notranslate"><span class="pre">n=20</span></code> for this
concrete example.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">strawberryfields</span> <span class="k">as</span> <span class="nn">sf</span>
<span class="kn">from</span> <span class="nn">strawberryfields.ops</span> <span class="kn">import</span> <span class="n">Sgate</span><span class="p">,</span> <span class="n">BSgate</span><span class="p">,</span> <span class="n">Rgate</span><span class="p">,</span> <span class="n">MeasureHomodyne</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<p>Below we assume that the parameters of the squeezing gate <span class="math notranslate nohighlight">\((S)\)</span>
and the angles of the beamsplitter <span class="math notranslate nohighlight">\((BS)\)</span> and rotation <span class="math notranslate nohighlight">\(R\)</span>
do not change with the timebin.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># We set the seed to facilitate later comparison</span>
<span class="c1"># since the samples are stochastic.</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">20</span>

<span class="n">r</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">length</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">length</span>
<span class="n">phi</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">length</span>
<span class="n">theta</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">length</span>

<span class="n">prog0</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Program</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="k">with</span> <span class="n">prog0</span><span class="o">.</span><span class="n">context</span> <span class="k">as</span> <span class="n">q</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">Sgate</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">BSgate</span><span class="p">(</span><span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">Rgate</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">MeasureHomodyne</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">eng0</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Engine</span><span class="p">(</span><span class="s2">&quot;gaussian&quot;</span><span class="p">)</span>
<span class="n">result0</span> <span class="o">=</span> <span class="n">eng0</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">prog0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can look at an unrolled version of the program above in terms of
a circuit diagram as</p>
<p><img alt="" src="../../../../_images/unrolled.png" /></p>
<p>where, for clarity, we have reduced the number of displayed modes to <code class="docutils literal notranslate"><span class="pre">n=5</span></code>.</p>
<p>Finally, we can also look at the samples:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">result0</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In this program we follow each and every time-bin mode (a total of
<code class="docutils literal notranslate"><span class="pre">n=20</span></code> modes) as they progress through the different operations.
However, at most only two modes are interacting at the same time. The
rest of the modes either have not been squeezed (and thus are in the
vacuum state) or have been measured (and thus reset to vacuum).</p>
<section id="reducing-simulation-resources-shifting-modes">
<h3>Reducing simulation resources: shifting modes<a class="headerlink" href="#reducing-simulation-resources-shifting-modes" title="Permalink to this heading">¶</a></h3>
<p>Instead of keeping track of the modes using labels telling us their time
bin, we can label them in terms of the position that they occupy in the
circuit above. A convenient choice of labels is to look at the two modes
that enter into the beamsplitter. We can use <code class="docutils literal notranslate"><span class="pre">0</span></code> for the mode that
enters in the top port of the beamsplitter and which has been
circulating in the loop. We can use the label <code class="docutils literal notranslate"><span class="pre">1</span></code> for the mode that
has just been squeezed and is about to enter the beamsplitter in the
bottom port. These two modes, which have fixed positions in the circuit,
we call concurrent modes; they are, at all times, the only two modes
that are not in vacuum in the circuit.</p>
<p>To make a closed loop of modes going in and out of the circuit one can
recycle the mode that is measured (mode <code class="docutils literal notranslate"><span class="pre">0</span></code>) and plug it back in as a
vacuum mode re-entering the circuit. As it turns out the Gaussian
backend of Strawberry Fields automatically resets to vacuum a mode that
has been measured thus the resetting is automatically taken care of.</p>
<p>To implement the recycling we will need a function that takes the mode
that is measured (which sits at the  beginning of the mode list <code class="docutils literal notranslate"><span class="pre">q</span></code>)
and moves it back to the end of the list after it is measured.
This functionality is
provided by the function <code class="docutils literal notranslate"><span class="pre">shift_by</span></code> in the module
<code class="docutils literal notranslate"><span class="pre">strawberryfields.tdm</span></code> as illustrated below:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">strawberryfields.tdm</span> <span class="kn">import</span> <span class="n">shift_by</span>

<span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">shift_by</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We are now ready to simulate an <code class="docutils literal notranslate"><span class="pre">n=20</span></code> mode circuit using only two
concurrent modes:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>  <span class="c1"># We set the seed to facilitate comparison</span>
<span class="n">prog1</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Program</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">20</span>
<span class="k">with</span> <span class="n">prog1</span><span class="o">.</span><span class="n">context</span> <span class="k">as</span> <span class="n">q</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">Sgate</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">BSgate</span><span class="p">(</span><span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">Rgate</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">MeasureHomodyne</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Note that only position 0 of q is measured</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">shift_by</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">eng1</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Engine</span><span class="p">(</span><span class="s2">&quot;gaussian&quot;</span><span class="p">)</span>
<span class="n">result1</span> <span class="o">=</span> <span class="n">eng1</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">prog1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result1</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Even though we measured <code class="docutils literal notranslate"><span class="pre">n-1</span></code> times we only get 2 values. This is
because the <code class="docutils literal notranslate"><span class="pre">samples</span></code> attribute only contains the last ever measured
value(s) in our modes; since we only have two concurrent modes we only get
two numbers. To obtain the complete sample record we use the attribute
<code class="docutils literal notranslate"><span class="pre">samples_dict</span></code>, which contains all measured samples inside of a dict.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">result1</span><span class="o">.</span><span class="n">samples_dict</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Note that we obtain the same samples as in <code class="docutils literal notranslate"><span class="pre">result0.samples</span></code> except
that they are ordered in a slightly different arrangement. We can put
them in the correct order by using <code class="docutils literal notranslate"><span class="pre">reshape_samples</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">strawberryfields.tdm</span> <span class="kn">import</span> <span class="n">reshape_samples</span>

<span class="n">reshape_samples</span><span class="p">(</span><span class="n">result1</span><span class="o">.</span><span class="n">samples_dict</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The second argument <code class="docutils literal notranslate"><span class="pre">[0]</span></code> gives the label of the
concurrent mode where a measurement happened,
while the third argument <code class="docutils literal notranslate"><span class="pre">[2]</span></code> indicates, for this simple one loop program,
that there are only two concurrent modes in a single loop.
Finally, the last argument gives the information on the number of
time bins measured. Notice that it is <code class="docutils literal notranslate"><span class="pre">n-1</span></code> and not <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>All the measurement outcomes are now attached to the only mode
that we ever measured, namely <code class="docutils literal notranslate"><span class="pre">0</span></code>. Note that in <code class="docutils literal notranslate"><span class="pre">result1.samples_dict</span></code>
the samples are attached to different modes. This is an artifact of the
recycling.</p>
<p>By recycling the modes we are now able to simulate very long circuits
with just two modes. Going back to our hypothetical one thousand mode example,
we would need to keep in memory millions of real numbers, instead by using
a time-domain strategy where we only worry about concurrent modes we only ever
need to consider covariances matrices of size four by four, which results
in massive speed and memory gains!</p>
</section>
<section id="the-tdmprogram">
<h3>The TDMProgram<a class="headerlink" href="#the-tdmprogram" title="Permalink to this heading">¶</a></h3>
<p>Rather than performing the mode shifting and sample reshaping manually,
Strawberry Fields provides the <code class="docutils literal notranslate"><span class="pre">~strawberryfields.TDMProgram</span></code> program class
for automating this procedure, making it easy to construct and simulate time-domain
multiplexing algorithms.</p>
<p>In this class one needs to specify the number of
active modes (<code class="docutils literal notranslate"><span class="pre">N=2</span></code> for the example above) and then the class takes
care of automatically shifting the modes and reshaping the samples. Thus
the program above could have been rewritten as</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>  <span class="c1"># We set the seed to facilitate comparison</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># Number of concurrent modes</span>
<span class="n">prog2</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">TDMProgram</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>

<span class="k">with</span> <span class="n">prog2</span><span class="o">.</span><span class="n">context</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span> <span class="k">as</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="n">Sgate</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">BSgate</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">Rgate</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">MeasureHomodyne</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">eng2</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Engine</span><span class="p">(</span><span class="s2">&quot;gaussian&quot;</span><span class="p">)</span>
<span class="n">result2</span> <span class="o">=</span> <span class="n">eng2</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">prog2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result2</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In a <code class="docutils literal notranslate"><span class="pre">TDMProgram</span></code> we need to specify the number of concurrent modes
<code class="docutils literal notranslate"><span class="pre">N</span></code>. Then we pass to the <code class="docutils literal notranslate"><span class="pre">context</span></code> the sequences of
the different parameters that will be used in the program, in our case
the lists <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">phi</span></code> and <code class="docutils literal notranslate"><span class="pre">theta</span></code>. The three variables in the
list <code class="docutils literal notranslate"><span class="pre">p</span></code> will cycle through the corresponding values of these lists.
For example, <code class="docutils literal notranslate"><span class="pre">p[0]</span></code> will go through the values of <code class="docutils literal notranslate"><span class="pre">alpha</span></code> as the
simulation progresses.</p>
</section>
</section>
<section id="a-single-loop-architecture">
<h2>A single-loop architecture<a class="headerlink" href="#a-single-loop-architecture" title="Permalink to this heading">¶</a></h2>
<p>We will now write a simple function that
encapsulates the single loop architecture using a <code class="docutils literal notranslate"><span class="pre">TDMprogram</span></code>. Then we
will use it to generate samples of interesting quantum states and
investigate their correlations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">singleloop</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">shots</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Single loop program.</span>

<span class="sd">    Args:</span>
<span class="sd">        r (float): squeezing parameter</span>
<span class="sd">        alpha (Sequence[float]): beamsplitter angles</span>
<span class="sd">        phi (Sequence[float]): rotation angles</span>
<span class="sd">        theta (Sequence[float]): homodyne measurement angles</span>
<span class="sd">        shots (int): number of times the circuit is sampled</span>
<span class="sd">    Returns:</span>
<span class="sd">        list: homodyne samples from the single loop simulation</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">prog</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">TDMProgram</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">prog</span><span class="o">.</span><span class="n">context</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span> <span class="k">as</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="n">Sgate</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">BSgate</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">Rgate</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">MeasureHomodyne</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">eng</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Engine</span><span class="p">(</span><span class="s2">&quot;gaussian&quot;</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">eng</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
    <span class="c1"># We only want the samples from concurrent mode 0</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">samples_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>We can use the function we just developed to reproduce for the fourth
time the results of our very simple experiment:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>  <span class="c1"># We set the seed to facilitate comparison</span>
<span class="n">singleloop</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># We want 1 shot</span>
</pre></div>
</div>
</div>
</div>
<section id="generation-of-epr-states">
<h3>Generation of EPR states<a class="headerlink" href="#generation-of-epr-states" title="Permalink to this heading">¶</a></h3>
<p>With the single loop architecture we can easily generate
Einstein-Podolsky-Rosen (EPR) states [[#einstein1935]_]. In this section we will create
this bipartite state and probe it using homodyne measurements.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">phi</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">theta</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># We will measure the positions by setting theta = [0,0]</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">2500</span>

<span class="n">samplesEPRxx</span> <span class="o">=</span> <span class="n">singleloop</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">shots</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>To process the samples we simply transpose the array in which they
are stored. This gives us easier access to the values corresponding
to the two halves of an EPR state.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">samplesxx</span> <span class="o">=</span> <span class="n">samplesEPRxx</span><span class="o">.</span><span class="n">T</span>
<span class="n">x0</span> <span class="o">=</span> <span class="n">samplesxx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">x1</span> <span class="o">=</span> <span class="n">samplesxx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># We now want to look at the samples</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$x_0$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$x_</span><span class="si">{1}</span><span class="s2">$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We can put this observation in more quantitative terms by looking at the
variance of <span class="math notranslate nohighlight">\(x_1-x_0\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sample_var_xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">x0</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span>
<span class="n">sample_var_xx</span>
</pre></div>
</div>
</div>
</div>
<p>As it turns out the variance of the operator <span class="math notranslate nohighlight">\(N_1 = x_1 - x_0\)</span> is
related to the amount of squeezing used to prepare the state. One can
easily find that <span class="math notranslate nohighlight">\(\text{Var}(N_1) = 2 e^{-2 r}\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">expected_var_xx</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
<span class="n">expected_var_xx</span>
</pre></div>
</div>
</div>
</div>
<p>In the literature, the operator <span class="math notranslate nohighlight">\(N\)</span> for which one finds a relation
like the one above, is called a <em>Nullifier</em> of the state. A way to
understand this name is that the variance of this operator approaches
zero (or <em>nullifies</em>) as the squeezing in the state grows [[#takeda2019]_].</p>
<p>The EPR state has a second nullifier, <span class="math notranslate nohighlight">\(N_2 = p_1+p_2\)</span>. We can
confirm this by running our circuit again, but this time measuring
in the <span class="math notranslate nohighlight">\(P\)</span> quadrature</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">theta</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">]</span>  <span class="c1"># Now we homodyne the p-quadratures by setting thr angle to pi/2</span>
<span class="n">samplesEPRpp</span> <span class="o">=</span> <span class="n">singleloop</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">shots</span><span class="p">)</span>

<span class="n">samplespp</span> <span class="o">=</span> <span class="n">samplesEPRpp</span><span class="o">.</span><span class="n">T</span>
<span class="n">p0</span> <span class="o">=</span> <span class="n">samplespp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">p1</span> <span class="o">=</span> <span class="n">samplespp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$p_0$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$p_</span><span class="si">{1}</span><span class="s2">$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We now calculate the sample variance and the expected variance,
except for the effect of finite size statistics, they are almost identical</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">p0</span> <span class="o">+</span> <span class="n">p1</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="generating-ghz-states">
<h3>Generating GHZ states<a class="headerlink" href="#generating-ghz-states" title="Permalink to this heading">¶</a></h3>
<p>The GHZ states (named after Greenberger, Horne and Zeilinger) [[#greenberger2007]<em>] can be
thought as an <span class="math notranslate nohighlight">\(n\)</span>-partite generalization of the EPR states [[#vanloock1999]</em>]. We
will prepare these states using the single loop architecture
encapsulated in the function <code class="docutils literal notranslate"><span class="pre">singleloop</span></code> defined before.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">vac_modes</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># This is an ancilla mode that is used at the beginning of the protocol</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">r</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">vac_modes</span><span class="p">)</span>
<span class="p">]</span>
<span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">phi</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">vac_modes</span><span class="p">)</span>
<span class="n">phi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>
<span class="n">theta</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
    <span class="n">n</span> <span class="o">+</span> <span class="n">vac_modes</span>
<span class="p">)</span>  <span class="c1"># We will measure first all the states in the X quadrature</span>

<span class="n">singleloop</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">shots</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Note that all the <em>sampled</em> positions are the
same. We can also sample our state in the <span class="math notranslate nohighlight">\(p\)</span> basis</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">theta</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">vac_modes</span><span class="p">)</span>  <span class="c1"># Now we measure in p quadrature</span>

<span class="n">samplep</span> <span class="o">=</span> <span class="n">singleloop</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">shots</span><span class="p">)</span>
<span class="n">samplep</span>
</pre></div>
</div>
</div>
</div>
<p>There does not seem to be anything interesting going on when we look at
the <span class="math notranslate nohighlight">\(p\)</span> quadratures, yet if we consider the sum of the sampled
values of the momenta we find that the momenta add up to approximately
zero:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">samplep</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>  <span class="c1"># Note that we exclude the first element, the &quot;vacuum mode&quot;</span>
</pre></div>
</div>
</div>
</div>
<p>Indeed, like for the EPR state defined before, one can introduce
nullifiers for the GHZ states such as
<span class="math notranslate nohighlight">\(N_k = x_k - x_n\)</span> for <span class="math notranslate nohighlight">\(1 \leq k &lt; n\)</span>,</p>
<p>We now generate many samples and statistically verify that the variances
of the nullifier decay exponentially with the amount of squeezing</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Collect x-samples</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">theta</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">vac_modes</span><span class="p">)</span>
<span class="n">samplesGHZx</span> <span class="o">=</span> <span class="n">singleloop</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">shots</span><span class="p">)</span>

<span class="n">nullifier_X</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">sample</span><span class="p">:</span> <span class="p">(</span><span class="n">sample</span> <span class="o">-</span> <span class="n">sample</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">vac_modes</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">val_nullifier_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">([</span><span class="n">nullifier_X</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">samplesGHZx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The sample variances of the X nullifiers are</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">val_nullifier_X</span>
</pre></div>
</div>
</div>
</div>
<p>While their expected value is</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="conclusion-and-final-remarks">
<h2>Conclusion and final remarks<a class="headerlink" href="#conclusion-and-final-remarks" title="Permalink to this heading">¶</a></h2>
<p>We have introduced the basic ideas of time-domain circuits by gradually
transforming a simple one-loop <code class="docutils literal notranslate"><span class="pre">n</span></code>-mode optical setup from a brute
force simulator to a time-domain simulator using the :class:<code class="docutils literal notranslate"><span class="pre">~strawberryfields.TDMProgram</span></code>.
Using the later class we achieve significant computational savings: a brute force
Gaussian simulator requires resources scaling quadratically with the number of modes,
a time-domain approach requires only constant (and very modest) resources.
We have used this highly efficient implementation to study the correlations
of EPR and GHZ states, the canonical bipartite and multipartite entangled
states in the continuous-variable domain.</p>
</section>
<section id="id9">
<h2>References<a class="headerlink" href="#id9" title="Permalink to this heading">¶</a></h2>
<p>.. [#advantage2022]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>`Quantum computational advantage with a programmable photonic processor &lt;https://xanadu.ai/qca-paper&gt;`__.
</pre></div>
</div>
<p>.. [#takeda2019]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>S. Takeda, T. Kan and A. Furusawa. On-demand photonic entanglement synthesizer.
Science Advances, 2019. doi:10.1126/sciadv.aaw4530 .
</pre></div>
</div>
<p>.. [#yoshikawa2016]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>J. Yoshikawa, S. Yokoyama, T. Kaji, C. Sornphiphatphong, Y. Shiozawa, K. Makino and A. Furusawa.
Generation of one-million-mode continuous-variable cluster state by unlimited time-domain multiplexing.
APL Photonics, 2016. doi:10.1063/1.4962732 .
</pre></div>
</div>
<p>.. [#larsen2019]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>M. V. Larsen, X. Guo, C. R. Breum, J. S. Neergaard-Nielsen and U. L. Andersen.
Deterministic generation of a two-dimensional cluster state.
Science, 2019. doi:10.1126/science.aay4354 .
</pre></div>
</div>
<p>.. [#asavanant2019]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>W.Asavanant, Y. Shiozawa, S. Yokoyama, B. Charoensombutamon, H. Emura, R. N. Alexander, S. Takeda, J. Yoshikawa, N. C. Menicucci, H. Yonezawa and A. Furusawa.
Generation of time-domain-multiplexed two-dimensional cluster state.
Science, 2019. doi:10.1126/science.aay2645 .
</pre></div>
</div>
<p>.. [#einstein1935]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>A. Einstein, B. Podolsky and N. Rosen. Can quantum-mechanical description of physical reality be considered complete?
Physical Review, 1935. doi:10.1103/PhysRev.47.777 .
</pre></div>
</div>
<p>.. [#greenberger2007]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>D. M. Greenberger, M. A. Horne and A. Zeilinger. Going beyond Bell&#39;s Theorem
arXiv:0712.0921, 2007.
</pre></div>
</div>
<p>.. [#vanloock1999]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>P. van Loock, S. L. Braunstein. Multipartite Entanglement for Continuous Variables: A Quantum Teleportation Network
Physical Review Letters, 2000. doi:10.1103/PhysRevLett.84.3482 .
</pre></div>
</div>
</section>
</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../../../../_sources/courses/PHYS437/Hands-On/hands-on-9/Hands-on-9.ipynb.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright (CC BY 3.0) https://creativecommons.org/ .<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.3.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>
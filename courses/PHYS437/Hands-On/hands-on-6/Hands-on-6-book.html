<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Hands-on 6 : &#8212; Practical Quantum Computing for Scientists 2022.02.24 alpha documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/sphinx_highlight.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Hands-on 7" href="../hands-on-7/Hands-on-7-book.html" />
    <link rel="prev" title="Hands-on 5" href="../hands-on-5/Hands-on-5-book.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../../../../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../../../../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../../../_static/bootstrap-sphinx.js"></script>

  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default ">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../../index.html">
          Practical QC for Scientists</a>
        <span class="navbar-text navbar-version pull-left"><b>2022.02.24</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../index.html">437</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../../index.html">Contents <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../../index.html">Courses</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../index.html">PHYS 437</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../PHYS710/index.html">PHYS 710</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../archives/archives.html">Archives</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../help/index.html">HOWTOs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../help/IBM_quantum.html">Using IBM quantum Cloud</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <section class="tex2jax_ignore mathjax_ignore" id="hands-on-6">
<h1>Hands-on 6 :<a class="headerlink" href="#hands-on-6" title="Permalink to this heading">¶</a></h1>
<section id="entanglement-purification-the-bbpssw-protocol">
<h2>Entanglement Purification: The BBPSSW Protocol<a class="headerlink" href="#entanglement-purification-the-bbpssw-protocol" title="Permalink to this heading">¶</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">qiskit.tools.jupyter</span>
<span class="o">%</span><span class="k">qiskit_version_table</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><h3>Version Information</h3><table><tr><th>Qiskit Software</th><th>Version</th></tr><tr><td><code>qiskit-terra</code></td><td>0.22.0</td></tr><tr><td><code>qiskit-aer</code></td><td>0.11.0</td></tr><tr><td><code>qiskit-ibmq-provider</code></td><td>0.19.2</td></tr><tr><td><code>qiskit</code></td><td>0.39.0</td></tr><tr><th>System information</th></tr><tr><td>Python version</td><td>3.8.13</td></tr><tr><td>Python compiler</td><td>GCC 7.5.0</td></tr><tr><td>Python build</td><td>default, Mar 28 2022 11:38:47</td></tr><tr><td>OS</td><td>Linux</td></tr><tr><td>CPUs</td><td>24</td></tr><tr><td>Memory (Gb)</td><td>62.648441314697266</td></tr><tr><td colspan='2'>Thu Oct 20 12:40:30 2022 +03</td></tr></table></div></div>
</div>
</section>
<section id="part-i-introduction-to-entanglement-purification-and-the-bbpssw-protocol">
<h2>Part I: Introduction to Entanglement Purification and the BBPSSW Protocol<a class="headerlink" href="#part-i-introduction-to-entanglement-purification-and-the-bbpssw-protocol" title="Permalink to this heading">¶</a></h2>
<section id="concept">
<h3>1.1 Concept<a class="headerlink" href="#concept" title="Permalink to this heading">¶</a></h3>
<p>The concept of <strong>entanglement purification</strong> was introduced by C. H. Bennett <em>et al.</em> [1]. Following the names of the authors, the original protocol is also called the <strong>BBPSSW protocol</strong>. The basic idea of entanglement purification is to create an (almost) maximally entangled Bell state by distilling entanglement from a larger number of qubit pairs that are not maximally entangled. For this reason, this concept is also referred to as <strong>entanglement distillation</strong>. Purification usually has to be performed by two remote parties, so only local operations, measurements and classical two-way communication are allowed for entanglement purification protocols.</p>
<p>Many applications of quantum information processing, such as quantum teleportation [2] or entanglement-based quantum cryptography [3], use the maximally entangled <em>Bell states</em> <span class="math notranslate nohighlight">\(\{|\Phi^{\pm}\rangle, |\Psi^{\pm}\rangle\}\)</span>,</p>
<div class="math notranslate nohighlight">
\[\begin{split} |\Phi^{\pm}\rangle = \frac{1}{\sqrt{2}}(|00\rangle \pm |11\rangle), \\
|\Psi^{\pm}\rangle = \frac{1}{\sqrt{2}}(|01\rangle \pm |10\rangle). \end{split}\]</div>
<p>The feasibility or security of these protocols depends on the “quality” of the available Bell states. However, real sources of entangled qubit pairs or real lossy quantum channels are very likely to produce imperfect Bell states due to preparation errors or imperfect qubit transmission. The aim of entanglement purification is to compensate for this loss in entanglement and restore a maximally entangled Bell state. That is why entanglement purification is also a fundamental component of a quantum repeater [4].</p>
<p>At the beginning we assume a source <span class="math notranslate nohighlight">\(S\)</span> of entangled qubit pairs, which generates two-qubit states <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span> with some <strong>state fidelity</strong> <span class="math notranslate nohighlight">\(F\)</span> towards the maximally-entangled Bell state <span class="math notranslate nohighlight">\(|\Psi^-\rangle\)</span>,</p>
<div class="math notranslate nohighlight">
\[
F = \langle \Psi^- | \rho_\textrm{S} | \Psi^- \rangle.
\]</div>
<p>As already mentioned, imperfection can be caused by the production process itself or by the transmission of the qubits via lossy quantum channels.</p>
<p>The two parties that each have one of the qubits of the source state <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span> are usually called Alice and Bob. The whole scenario is shown in the following figure:</p>
<a class="reference internal image-reference" href="../../../../_images/fig01.png"><img alt="../../../../_images/fig01.png" src="../../../../_images/fig01.png" style="width: 400px;" /></a>
<p>The basic idea of the BBPSSW protocol is that Alice and Bob take two copies of the state <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span> and perform certain quantum operations locally on their qubits to finally generate a single two-qubit state with larger fidelity <span class="math notranslate nohighlight">\(F' &gt; F\)</span>. When this is achieved, the process can be iterated to produce even larger fidelities until a maximally entangled Bell state <span class="math notranslate nohighlight">\(| \Psi^- \rangle\)</span> is obtained.</p>
<p>In the following section we will explain the BBPSSW protocol step by step and show how Alice and Bob can increase the entanglement of the state <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span>.</p>
</section>
<section id="quantum-protocol">
<h3>1.2 Quantum Protocol<a class="headerlink" href="#quantum-protocol" title="Permalink to this heading">¶</a></h3>
<section id="step-1-creation-of-a-werner-state-through-random-bilateral-rotation">
<h4>Step 1: Creation of a Werner State through Random Bilateral Rotation<a class="headerlink" href="#step-1-creation-of-a-werner-state-through-random-bilateral-rotation" title="Permalink to this heading">¶</a></h4>
<p>From the two-qubit source state <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span> the two parties Alice and Bob must first create a so-called <strong>Werner state</strong> <span class="math notranslate nohighlight">\(W_F\)</span>,</p>
<div class="math notranslate nohighlight">
\[
W_F = F |\Psi^-\rangle \langle \Psi^-| + \frac{1-F}{3}\left(|\Psi^+\rangle \langle \Psi^+|+|\Phi^+\rangle \langle \Phi^+|+|\Phi^-\rangle \langle \Phi^-|\right).  
\]</div>
<p>Such a state is diagonal in the Bell basis <span class="math notranslate nohighlight">\(\{ |\Phi^{+}\rangle, |\Phi^{-}\rangle, |\Psi^{+}\rangle, |\Psi^{-}\rangle \}\)</span>, has a fidelity of <span class="math notranslate nohighlight">\(F\)</span> towards the Bell state <span class="math notranslate nohighlight">\(|\Psi^-\rangle\)</span>, and overlaps equally with the other three Bell states by <span class="math notranslate nohighlight">\((1-F)/3\)</span>.</p>
<p>Alice and Bob can achieve this by applying a so-called <strong>twirl</strong> operation [5] that keeps the <span class="math notranslate nohighlight">\(|\Psi^-\rangle\)</span> component of the state <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span>, balances the components of the other three Bell states, and removes all off-diagonal elements. A twirl can be implemented by bilateral operations <span class="math notranslate nohighlight">\(B_k (k \in \{x, y, z\})\)</span> that rotate each qubit of the pair by an angle of <span class="math notranslate nohighlight">\(\pi/2\)</span> around the <span class="math notranslate nohighlight">\(k\)</span> axis. A random selection from the following set <span class="math notranslate nohighlight">\(\{ U_i \}\)</span> of 12 combinations of bilateral rotations <span class="math notranslate nohighlight">\(B_k\)</span>,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\{U_i\}
=
\{
I, \\ B_x B_x, \\ B_y B_y, \\ B_z B_z, \\
B_x B_y, \\ B_y B_z, \\ B_z B_x, \\ B_y B_x, 
\\ B_x B_y B_x B_y, \\ B_y B_z B_y B_z, \\ B_z B_x B_z B_x, \\ B_y B_x B_y B_x
\},  
\end{split}\]</div>
<p>transforms the state <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span> into the arithmetic average</p>
<div class="math notranslate nohighlight">
\[
W_F = \frac{1}{12} \sum_{i=1}^{12} U_i \rho_\textrm{S} U_i^\dagger,
\]</div>
<p>which will be exactly the desired Werner state <span class="math notranslate nohighlight">\(W_F\)</span>. Here <span class="math notranslate nohighlight">\(I\)</span> denotes the identity operation. An intuitive explanation of the twirl, which comes from molecular physics, can be found in Ref. [2] and is left to the interested reader.</p>
<p>Since Alice and Bob randomly select an operation from the set <span class="math notranslate nohighlight">\(\{ U_i \}\)</span> in a realistic quantum communication scenario, we will also randomly select such an operation in the later implementation in Qiskit. In order to obtain the arithmetic average, we will have to perform several runs of the purification protocol.</p>
<p>We summarize the quantum operations performed locally by Alice and Bob in a graphical illustration for the sake of clarity:</p>
<a class="reference internal image-reference" href="../../../../_images/fig02.png"><img alt="../../../../_images/fig02.png" src="../../../../_images/fig02.png" style="width: 1000px;" /></a>
<p>Here Alice’s and Bob’s qubit are referred to as <span class="math notranslate nohighlight">\(q_A\)</span> and <span class="math notranslate nohighlight">\(q_B\)</span>, and <span class="math notranslate nohighlight">\(U_{i, A(B)}\)</span> denotes Alice’s (Bob’s) single-qubit part of the randomly selected operation <span class="math notranslate nohighlight">\(U_i\)</span>.</p>
</section>
<section id="step-2-exchange-of-psi-rangle-and-phi-rangle-components">
<h4>Step 2: Exchange of <span class="math notranslate nohighlight">\(|\Psi^-\rangle\)</span> and <span class="math notranslate nohighlight">\(|\Phi^+\rangle\)</span> Components<a class="headerlink" href="#step-2-exchange-of-psi-rangle-and-phi-rangle-components" title="Permalink to this heading">¶</a></h4>
<p>After Alice and Bob have prepared the state <span class="math notranslate nohighlight">\(W_F\)</span>, one of the parties rotates its qubit by an angle of <span class="math notranslate nohighlight">\(\pi\)</span> around the <span class="math notranslate nohighlight">\(y\)</span> axis, which corresponds to using a <span class="math notranslate nohighlight">\(Y\)</span> gate,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
Y = 
\begin{pmatrix}
0 &amp; -i \\
i &amp; 0 \\
\end{pmatrix}.
\end{split}\]</div>
<p>The result of such a unilateral rotation is that the components of <span class="math notranslate nohighlight">\(|\Psi^-\rangle\)</span> and <span class="math notranslate nohighlight">\(|\Phi^+\rangle\)</span> are exchanged in the Werner state <span class="math notranslate nohighlight">\(W_F\)</span>. Therefore, the operation creates a state <span class="math notranslate nohighlight">\(\rho_F\)</span>,</p>
<div class="math notranslate nohighlight">
\[
\rho_F = F |\Phi^+\rangle \langle \Phi^+| + \frac{1-F}{3}\left(|\Psi^+\rangle \langle \Psi^+|+|\Psi^-\rangle \langle \Psi^-|+|\Phi^-\rangle \langle \Phi^-|\right), 
\]</div>
<p>where total phases were omitted in this representation. Without loss of generality, we assume that Alice performs this unilateral rotation, so that the quantum circuit of the protocol up to this point looks like this:</p>
<a class="reference internal image-reference" href="../../../../_images/fig03.png"><img alt="../../../../_images/fig03.png" src="../../../../_images/fig03.png" style="width: 1000px;" /></a>
</section>
<section id="step-3-application-of-bilateral-cnot-gate">
<h4>Step 3: Application of Bilateral CNOT Gate<a class="headerlink" href="#step-3-application-of-bilateral-cnot-gate" title="Permalink to this heading">¶</a></h4>
<p>Now that Alice and Bob can prepare the states <span class="math notranslate nohighlight">\(\rho_F\)</span> from the source states <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span>, they will use two copies of <span class="math notranslate nohighlight">\(\rho_F\)</span> to increase the entanglement of one of these copies. In the first step, the two parties must apply a so-called bilateral CNOT gate to the two qubit pairs <span class="math notranslate nohighlight">\(\rho_F\)</span>.</p>
<p>A bilateral CNOT gate means that Alice and Bob each apply a CNOT gate to the two qubits they have locally available. The qubit from the first pair serves as the control qubit in the local CNOT operation, while the corresponding qubit from the second pair serves as the target qubit. Remember: In a CNOT gate, the state of the target qubit is flipped if and only if the control qubit is in the state <span class="math notranslate nohighlight">\(|1\rangle\)</span>.</p>
<p>If we now consider all four qubits from the two source qubit pairs <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span>, the local quantum circuits of Alice and Bob look like this:</p>
<a class="reference internal image-reference" href="../../../../_images/fig04.png"><img alt="../../../../_images/fig04.png" src="../../../../_images/fig04.png" style="width: 1000px;" /></a>
<p>Here we have denoted Alice’s (Bob’s) control qubit <span class="math notranslate nohighlight">\(q_{A(B),c}\)</span> and the corresponding target qubit <span class="math notranslate nohighlight">\(q_{A(B),t}\)</span>.</p>
</section>
<section id="step-4-measurement-of-target-qubits">
<h4>Step 4: Measurement of Target Qubits<a class="headerlink" href="#step-4-measurement-of-target-qubits" title="Permalink to this heading">¶</a></h4>
<p>In the second step, Alice and Bob measure the target qubits <span class="math notranslate nohighlight">\(q_{A,t}\)</span> and <span class="math notranslate nohighlight">\(q_{B,t}\)</span> in the computational basis <span class="math notranslate nohighlight">\(\{|0\rangle, |1\rangle \}\)</span>:</p>
<a class="reference internal image-reference" href="../../../../_images/fig05.png"><img alt="../../../../_images/fig05.png" src="../../../../_images/fig05.png" style="width: 1000px;" /></a>
<p>After performing the measurements, Alice and Bob compare their measurement results. If both measurement results are the same, i.e. the target qubits were projected into state <span class="math notranslate nohighlight">\(|00\rangle\)</span> or <span class="math notranslate nohighlight">\(|11\rangle\)</span>, the purification was successful and the control qubits are retained. Otherwise they will be discarded.</p>
<p>To see that the purification process is successful exactly in this case, one must calculate the fidelity <span class="math notranslate nohighlight">\(F'\)</span> of the resulting state of the control qubits, which we will call <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span>,</p>
<div class="math notranslate nohighlight">
\[
F' = \langle \Phi^+ | \rho'_{F'}| \Phi^+ \rangle.
\]</div>
<p>Note that the state <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span> does not have the same form as <span class="math notranslate nohighlight">\(\rho_{F}\)</span>, which is why we chose this notation. We will not elaborate on the calculation of <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span> in this introduction, as it is not required for the implementation in Qiskit, but only provide the result for <span class="math notranslate nohighlight">\(F'\)</span>[1],</p>
<div class="math notranslate nohighlight">
\[
F' \equiv F'(F) = \langle \Phi^+ | \rho'_{F'}| \Phi^+ \rangle = \frac{F^2 + \frac{1}{9}(1-F)^2}{F^2 + \frac{2}{3}F(1-F) + \frac{5}{9}(1-F)^2}.
\]</div>
<p>Since the function <span class="math notranslate nohighlight">\(F'(F)\)</span> is required at several points in this tutorial, we define the corresponding function <code class="docutils literal notranslate"><span class="pre">output_fidelity</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">output_fidelity</span><span class="p">(</span><span class="n">F_in</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns output fidelity of BBPSSW protocol.</span>
<span class="sd">    </span>
<span class="sd">    Keyword arguments:</span>
<span class="sd">    F_in -- input fidelity</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">F_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">F_in</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">F_in</span><span class="p">)</span><span class="o">/</span><span class="mi">9</span><span class="p">)</span> \
            <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">F_in</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">F_in</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">F_in</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">F_in</span><span class="p">)</span><span class="o">/</span><span class="mi">9</span><span class="p">)</span>
 
    <span class="k">return</span> <span class="n">F_out</span>
</pre></div>
</div>
</div>
</div>
<p>The output fidelity <span class="math notranslate nohighlight">\(F'\)</span> is larger than the input fidelity for <span class="math notranslate nohighlight">\(1/2 &lt; F &lt; 1\)</span>, which you can see very well when plotting the function <span class="math notranslate nohighlight">\(F'(F)\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">F_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">F_in</span><span class="p">,</span> <span class="n">F_in</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;$F&#39; = F$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">F_in</span><span class="p">,</span> <span class="n">output_fidelity</span><span class="p">(</span><span class="n">F_in</span><span class="p">),</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;$F&#39;(F)$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Input Fidelity $F$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Output Fidelity $F&#39;$&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../../_images/aad5179ed7004cada0f22a04c60860c1c6c42ba9c8eae8d0a914b812ec7d6a74.png" src="../../../../_images/aad5179ed7004cada0f22a04c60860c1c6c42ba9c8eae8d0a914b812ec7d6a74.png" />
</div>
</div>
<p>So, if the input fidelity <span class="math notranslate nohighlight">\(F\)</span> of the source state <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span> is larger than 1/2, Alice and Bob can distill entanglement from two copies of that state and increase the fidelity of one of those copies. The two parties can then use two qubit pairs whose fidelity has already been increased to create another qubit pair with even higher fidelity, and so on. By iterating the procedure of the BBPSSW protocol described above, the fidelity of a two-qubit state can thus be brought arbitrarily close to 1, which in turn corresponds to a maximally-entangled Bell state.</p>
</section>
<section id="step-5-restoration-of-werner-state">
<h4>Step 5: Restoration of Werner State<a class="headerlink" href="#step-5-restoration-of-werner-state" title="Permalink to this heading">¶</a></h4>
<p>Note that the state <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span> does not usually have the form of <span class="math notranslate nohighlight">\(\rho_{F}\)</span>, i.e. it can contain off-diagonal elements in the Bell basis and the components of <span class="math notranslate nohighlight">\(|\Phi^{-}\rangle\)</span>, <span class="math notranslate nohighlight">\(|\Psi^{+}\rangle\)</span> and <span class="math notranslate nohighlight">\(|\Psi^{-}\rangle\)</span> differ in size. But in order to perform a subsequent purification round, we must bring <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span> into the form of <span class="math notranslate nohighlight">\(\rho_{F}\)</span>, i.e. we must create something like a state <span class="math notranslate nohighlight">\(\rho_{F'}\)</span>,</p>
<div class="math notranslate nohighlight">
\[
\rho_{F'} = F' |\Phi^+\rangle \langle \Phi^+| + \frac{1-F'}{3}\left(|\Psi^+\rangle \langle \Psi^+|+|\Psi^-\rangle \langle \Psi^-|+|\Phi^-\rangle \langle \Phi^-|\right).  
\]</div>
<p>This can be achieved by performing the above steps backwards again. In the state <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span>, the components of <span class="math notranslate nohighlight">\(|\Psi^-\rangle\)</span> and <span class="math notranslate nohighlight">\(|\Phi^+\rangle\)</span> are first swapped again by a unilateral <span class="math notranslate nohighlight">\(Y\)</span> gate (see step 2). Then another twirl operation is performed to create a Werner state <span class="math notranslate nohighlight">\(W_{F'}\)</span>,</p>
<div class="math notranslate nohighlight">
\[
W_{F'} = F' |\Psi^-\rangle \langle \Psi^-| + \frac{1-F'}{3}\left(|\Psi^+\rangle \langle \Psi^+|+|\Phi^+\rangle \langle \Phi^+|+|\Phi^-\rangle \langle \Phi^-|\right).  
\]</div>
<p>This state <span class="math notranslate nohighlight">\(W_{F'}\)</span> can now serve as the initial state for a new round of entanglement purification, , since we can easily create the state <span class="math notranslate nohighlight">\(\rho_{F'}\)</span> from it.</p>
<p>In the following implementation in Qiskit we will shorten the purification protocol and omit this fifth step. We only want to do a single purification round here and therefore do not convert the output state <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span> of the control qubits back to the Werner form <span class="math notranslate nohighlight">\(W_{F'}\)</span> after the target qubits have been measured. Instead, we will directly evaluate the fidelity of the control qubits to the Bell state <span class="math notranslate nohighlight">\(| \Phi^+ \rangle\)</span>,</p>
<div class="math notranslate nohighlight">
\[
\langle \Phi^+ | \rho'_{F'}| \Phi^+ \rangle = F' = \langle \Psi^- | W_{F'}| \Psi^- \rangle,
\]</div>
<p>because we know the twirl operation leaves the <span class="math notranslate nohighlight">\(|\Psi^- \rangle\)</span> component unchanged.</p>
<p>Herewith we finish the introductory part and turn to the implementation in Qiskit. We will explain in detail how steps 1 - 4 described above can be implemented in Qiskit to determine the state <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span> and calcutate the final <span class="math notranslate nohighlight">\(F'\)</span> fidelity.</p>
</section>
</section>
</section>
<section id="part-ii-implementation-of-quantum-circuit-for-bbpssw-protocol-in-qiskit">
<h2>Part II: Implementation of Quantum Circuit for BBPSSW Protocol in Qiskit<a class="headerlink" href="#part-ii-implementation-of-quantum-circuit-for-bbpssw-protocol-in-qiskit" title="Permalink to this heading">¶</a></h2>
<hr class="docutils" />
<section id="basic-code-imports">
<h3>2.1 Basic Code Imports<a class="headerlink" href="#basic-code-imports" title="Permalink to this heading">¶</a></h3>
<p>To use Qiskit in this initial part of the tutorial in which we create a quantum circuit for the BBPSSW protocol, we must first import the necessary base code from the Qiskit module:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import Qiskit</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">ClassicalRegister</span>

<span class="c1"># Import Parameter class</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit</span> <span class="kn">import</span> <span class="n">Parameter</span>
</pre></div>
</div>
</div>
</div>
<p>We also need the external library <code class="docutils literal notranslate"><span class="pre">deepcopy</span></code> and use the constant <span class="math notranslate nohighlight">\(\pi\)</span> from the <code class="docutils literal notranslate"><span class="pre">math</span></code> library:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="definitions">
<h3>2.2 Definitions<a class="headerlink" href="#definitions" title="Permalink to this heading">¶</a></h3>
<p>As described in <strong>Part I</strong>, to demonstrate entanglement purification, the fidelity of quantum states towards a maximally-entangled Bell state must be calculated. This calculation is later performed with an integrated Qiskit function that returns the fidelity between two states when specified as numpy arrays.</p>
<p>We therefore define the four Bell states in the basis <span class="math notranslate nohighlight">\(\{|00\rangle, |01\rangle, |10\rangle, |11\rangle\}\)</span> as numpy arrays:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">phi_plus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>   <span class="c1"># | Phi^+ &gt;</span>
<span class="n">phi_minus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># | Phi^- &gt;</span>
<span class="n">psi_plus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>   <span class="c1"># | Psi^+ &gt;</span>
<span class="n">psi_minus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># | Psi^- &gt;</span>
</pre></div>
</div>
</div>
</div>
<p>We will also have to check later how well we can initialize a Werner state <span class="math notranslate nohighlight">\(W_F\)</span>. For this we define a function <code class="docutils literal notranslate"><span class="pre">Werner_state</span></code> which returns a numpy array corresponding to a Werner state with a given fidelity <span class="math notranslate nohighlight">\(F\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Werner_state</span><span class="p">(</span><span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns Werner state of fidelity F.</span>
<span class="sd">    </span>
<span class="sd">    Keyword arguments:</span>
<span class="sd">    F -- fidelity of Werner state, range [0, 1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">F</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">F</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Fidelity must be between 0 and 1.&#39;</span><span class="p">)</span>
    
    <span class="n">state</span> <span class="o">=</span> <span class="n">F</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">psi_minus</span><span class="p">,</span> <span class="n">psi_minus</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> \
            <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">F</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">phi_plus</span><span class="p">,</span> <span class="n">phi_plus</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> \
                        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">phi_minus</span><span class="p">,</span> <span class="n">phi_minus</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> \
                        <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">psi_plus</span><span class="p">,</span> <span class="n">psi_plus</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">state</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="quantum-register-and-quantum-circuit">
<h3>2.3 Quantum Register and Quantum Circuit<a class="headerlink" href="#quantum-register-and-quantum-circuit" title="Permalink to this heading">¶</a></h3>
<p>This section describes how to implement the quantum circuit for entanglement purififcation in Qiskit. For a better understanding, we divide the quantum circuit into its individual parts according to the individual steps in <strong>Part I</strong>. This means that we first simulate the source of the entangled qubits to create two qubits in the source state <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span>. We then integrate steps 1 (random bilateral rotation) to 3 (bilateral CNOT gate) individually. Step 4 (measurement of target qubits) will then be dealt with separately later, as the implementation is a little trickier here.</p>
<section id="quantum-register">
<h4>2.3.1 Quantum Register<a class="headerlink" href="#quantum-register" title="Permalink to this heading">¶</a></h4>
<p>The BBPSSW protocol works with two entangled qubit pairs. In order to implement this protocol, we therefore need a quantum register consisting of four qubits on which our quantum circuit to be defined runs.</p>
<p>In Qiskit a quantum register is an instance of the class <code class="docutils literal notranslate"><span class="pre">QuantumRegister</span></code> and we can create a register with four qubits in the following way:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qr</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="circuit-for-initialization-of-source-state">
<h4>2.3.2 Circuit for Initialization of Source State<a class="headerlink" href="#circuit-for-initialization-of-source-state" title="Permalink to this heading">¶</a></h4>
<p>First of all we have to create qubit pairs in the state <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span>. Our goal at the beginning is therefore to simulate the source <span class="math notranslate nohighlight">\(S\)</span>, which produces entangled qubits in the state <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span>, which have an initial fidelity <span class="math notranslate nohighlight">\(F &gt; 1/2\)</span>. Remember that such a high fidelity is required for the purification protocol to work.</p>
<p>To achieve this, we will implement a quantum circuit that creates the following state <span class="math notranslate nohighlight">\(|\psi_\textrm{S} \rangle\)</span> between two qubits,</p>
<div class="math notranslate nohighlight">
\[
|\psi_\textrm{S}\rangle = \cos\left(\frac{\theta}{2}\right) |01\rangle - \sin\left(\frac{\theta}{2}\right) |10\rangle ,
\]</div>
<p>where the two amplitudes are parametrized by an angle <span class="math notranslate nohighlight">\(\theta\)</span> (<span class="math notranslate nohighlight">\(- \pi/2 &lt; \theta &lt; \pi/2\)</span>). From the state vector <span class="math notranslate nohighlight">\(|\psi_\textrm{S} \rangle\)</span> we can then calculate the density matrix <span class="math notranslate nohighlight">\(\rho_\textrm{S} = |\psi_\textrm{S}\rangle\langle \psi_\textrm{S}|\)</span>,</p>
<div class="math notranslate nohighlight">
\[
\rho_\textrm{S} = |\psi_\textrm{S}\rangle\langle \psi_\textrm{S} |
=
\cos^2\left(\frac{\theta}{2}\right) |01\rangle \langle 01|
-
\cos\left(\frac{\theta}{2}\right)\sin\left(\frac{\theta}{2}\right) 
\left( |01\rangle\langle 10| + |10\rangle\langle 01| \right)
+
\sin^2\left(\frac{\theta}{2}\right) |10\rangle \langle 10|.
\]</div>
<p>The fidelity of <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span> towards the Bell state <span class="math notranslate nohighlight">\(| \Psi^- \rangle\)</span>, which corresponds to the initial fidelity <span class="math notranslate nohighlight">\(F\)</span>, is then given by</p>
<div class="math notranslate nohighlight">
\[
F \equiv F(\theta) = \langle \Psi^- | \rho_\textrm{S} | \Psi^- \rangle  = \frac{1}{2} \left( \sin(\theta) + 1 \right).
\]</div>
<p>We define a function <code class="docutils literal notranslate"><span class="pre">F_to_theta</span></code>, which returns the angle <span class="math notranslate nohighlight">\(\theta\)</span> for a given fidelity <span class="math notranslate nohighlight">\(F\)</span>, since we will need this calculation several times in the tutorial:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">F_to_theta</span><span class="p">(</span><span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the angle theta corresponding to an input fidelity F.</span>
<span class="sd">    </span>
<span class="sd">    Keyword arguments:</span>
<span class="sd">    F -- fidelity between 0 and 1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">F</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">F</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Fidelity must be between 0 and 1.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">F</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">theta</span>
</pre></div>
</div>
</div>
</div>
<p>In Qiskit quantum circuits are objects of the <code class="docutils literal notranslate"><span class="pre">QuantumCircuit</span></code> class. We can create a quantum circuit on our quantum register <code class="docutils literal notranslate"><span class="pre">qr</span></code> by creating an instance of the <code class="docutils literal notranslate"><span class="pre">QuantumCircuit</span></code> class in the following way:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">source_circ</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">qr</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The quantum circuit <code class="docutils literal notranslate"><span class="pre">source_circ</span></code> shall finally generate two pairs of qubits in the state <span class="math notranslate nohighlight">\(|\psi_\textrm{S}\rangle\)</span> in the quantum register <code class="docutils literal notranslate"><span class="pre">qr</span></code>, but is so far an empty quantum circuit, because we have not introduced quantum gates yet. With the method <code class="docutils literal notranslate"><span class="pre">draw</span></code> quantum circuits can be visualized nicely and we can get a better picture of what our circuit does:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">source_circ</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">MissingOptionalLibraryError</span><span class="g g-Whitespace">               </span>Traceback (most recent call last)
<span class="nn">Input In [12],</span> in <span class="ni">&lt;cell line: 1&gt;</span><span class="nt">()</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">source_circ</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>

<span class="nn">File ~/Prog/miniconda3/envs/qml/lib/python3.8/site-packages/qiskit/circuit/quantumcircuit.py:1957,</span> in <span class="ni">QuantumCircuit.draw</span><span class="nt">(self, output, scale, filename, style, interactive, plot_barriers, reverse_bits, justify, vertical_compression, idle_wires, with_layout, fold, ax, initial_state, cregbundle, wire_order)</span>
<span class="g g-Whitespace">   </span><span class="mi">1954</span> <span class="c1"># pylint: disable=cyclic-import</span>
<span class="g g-Whitespace">   </span><span class="mi">1955</span> <span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">circuit_drawer</span>
<span class="ne">-&gt; </span><span class="mi">1957</span> <span class="k">return</span> <span class="n">circuit_drawer</span><span class="p">(</span>
<span class="g g-Whitespace">   </span><span class="mi">1958</span>     <span class="bp">self</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1959</span>     <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1960</span>     <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1961</span>     <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1962</span>     <span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1963</span>     <span class="n">interactive</span><span class="o">=</span><span class="n">interactive</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1964</span>     <span class="n">plot_barriers</span><span class="o">=</span><span class="n">plot_barriers</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1965</span>     <span class="n">reverse_bits</span><span class="o">=</span><span class="n">reverse_bits</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1966</span>     <span class="n">justify</span><span class="o">=</span><span class="n">justify</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1967</span>     <span class="n">vertical_compression</span><span class="o">=</span><span class="n">vertical_compression</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1968</span>     <span class="n">idle_wires</span><span class="o">=</span><span class="n">idle_wires</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1969</span>     <span class="n">with_layout</span><span class="o">=</span><span class="n">with_layout</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1970</span>     <span class="n">fold</span><span class="o">=</span><span class="n">fold</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1971</span>     <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1972</span>     <span class="n">initial_state</span><span class="o">=</span><span class="n">initial_state</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1973</span>     <span class="n">cregbundle</span><span class="o">=</span><span class="n">cregbundle</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1974</span>     <span class="n">wire_order</span><span class="o">=</span><span class="n">wire_order</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1975</span> <span class="p">)</span>

<span class="nn">File ~/Prog/miniconda3/envs/qml/lib/python3.8/site-packages/qiskit/visualization/circuit/circuit_visualization.py:263,</span> in <span class="ni">circuit_drawer</span><span class="nt">(circuit, scale, filename, style, output, interactive, plot_barriers, reverse_bits, justify, vertical_compression, idle_wires, with_layout, fold, ax, initial_state, cregbundle, wire_order)</span>
<span class="g g-Whitespace">    </span><span class="mi">248</span>     <span class="k">return</span> <span class="n">_generate_latex_source</span><span class="p">(</span>
<span class="g g-Whitespace">    </span><span class="mi">249</span>         <span class="n">circuit</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">250</span>         <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span>
   <span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">260</span>         <span class="n">wire_order</span><span class="o">=</span><span class="n">wire_order</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">261</span>     <span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">262</span> <span class="k">elif</span> <span class="n">output</span> <span class="o">==</span> <span class="s2">&quot;mpl&quot;</span><span class="p">:</span>
<span class="ne">--&gt; </span><span class="mi">263</span>     <span class="n">image</span> <span class="o">=</span> <span class="n">_matplotlib_circuit_drawer</span><span class="p">(</span>
<span class="g g-Whitespace">    </span><span class="mi">264</span>         <span class="n">circuit</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">265</span>         <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">266</span>         <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">267</span>         <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">268</span>         <span class="n">plot_barriers</span><span class="o">=</span><span class="n">plot_barriers</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">269</span>         <span class="n">reverse_bits</span><span class="o">=</span><span class="n">reverse_bits</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">270</span>         <span class="n">justify</span><span class="o">=</span><span class="n">justify</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">271</span>         <span class="n">idle_wires</span><span class="o">=</span><span class="n">idle_wires</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">272</span>         <span class="n">with_layout</span><span class="o">=</span><span class="n">with_layout</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">273</span>         <span class="n">fold</span><span class="o">=</span><span class="n">fold</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">274</span>         <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">275</span>         <span class="n">initial_state</span><span class="o">=</span><span class="n">initial_state</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">276</span>         <span class="n">cregbundle</span><span class="o">=</span><span class="n">cregbundle</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">277</span>         <span class="n">wire_order</span><span class="o">=</span><span class="n">wire_order</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">278</span>     <span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">279</span> <span class="k">else</span><span class="p">:</span>
<span class="g g-Whitespace">    </span><span class="mi">280</span>     <span class="k">raise</span> <span class="n">VisualizationError</span><span class="p">(</span>
<span class="g g-Whitespace">    </span><span class="mi">281</span>         <span class="s2">&quot;Invalid output type </span><span class="si">%s</span><span class="s2"> selected. The only valid choices &quot;</span>
<span class="g g-Whitespace">    </span><span class="mi">282</span>         <span class="s2">&quot;are text, latex, latex_source, and mpl&quot;</span> <span class="o">%</span> <span class="n">output</span>
<span class="g g-Whitespace">    </span><span class="mi">283</span>     <span class="p">)</span>

<span class="nn">File ~/Prog/miniconda3/envs/qml/lib/python3.8/site-packages/qiskit/visualization/circuit/circuit_visualization.py:643,</span> in <span class="ni">_matplotlib_circuit_drawer</span><span class="nt">(circuit, scale, filename, style, plot_barriers, reverse_bits, justify, idle_wires, with_layout, fold, ax, initial_state, cregbundle, wire_order)</span>
<span class="g g-Whitespace">    </span><span class="mi">640</span> <span class="k">if</span> <span class="n">fold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="g g-Whitespace">    </span><span class="mi">641</span>     <span class="n">fold</span> <span class="o">=</span> <span class="mi">25</span>
<span class="ne">--&gt; </span><span class="mi">643</span> <span class="n">qcd</span> <span class="o">=</span> <span class="n">_matplotlib</span><span class="o">.</span><span class="n">MatplotlibDrawer</span><span class="p">(</span>
<span class="g g-Whitespace">    </span><span class="mi">644</span>     <span class="n">qubits</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">645</span>     <span class="n">clbits</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">646</span>     <span class="n">nodes</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">647</span>     <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">648</span>     <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">649</span>     <span class="n">reverse_bits</span><span class="o">=</span><span class="n">reverse_bits</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">650</span>     <span class="n">plot_barriers</span><span class="o">=</span><span class="n">plot_barriers</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">651</span>     <span class="n">layout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">652</span>     <span class="n">fold</span><span class="o">=</span><span class="n">fold</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">653</span>     <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">654</span>     <span class="n">initial_state</span><span class="o">=</span><span class="n">initial_state</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">655</span>     <span class="n">cregbundle</span><span class="o">=</span><span class="n">cregbundle</span> <span class="k">if</span> <span class="n">cregbundle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">True</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">656</span>     <span class="n">global_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">657</span>     <span class="n">calibrations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">658</span>     <span class="n">qregs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">659</span>     <span class="n">cregs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">660</span>     <span class="n">with_layout</span><span class="o">=</span><span class="n">with_layout</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">661</span>     <span class="n">circuit</span><span class="o">=</span><span class="n">circuit</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">662</span> <span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">663</span> <span class="k">return</span> <span class="n">qcd</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

<span class="nn">File ~/Prog/miniconda3/envs/qml/lib/python3.8/site-packages/qiskit/utils/classtools.py:117,</span> in <span class="ni">_WrappedMethod.__get__.&lt;locals&gt;.out</span><span class="nt">(*args, **kwargs)</span>
<span class="g g-Whitespace">    </span><span class="mi">115</span> <span class="k">for</span> <span class="n">callback</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_before</span><span class="p">:</span>
<span class="g g-Whitespace">    </span><span class="mi">116</span>     <span class="n">callback</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="ne">--&gt; </span><span class="mi">117</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">118</span> <span class="k">for</span> <span class="n">callback</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_after</span><span class="p">:</span>
<span class="g g-Whitespace">    </span><span class="mi">119</span>     <span class="n">callback</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="nn">File ~/Prog/miniconda3/envs/qml/lib/python3.8/site-packages/qiskit/utils/classtools.py:116,</span> in <span class="ni">_WrappedMethod.__get__.&lt;locals&gt;.out</span><span class="nt">(*args, **kwargs)</span>
<span class="g g-Whitespace">    </span><span class="mi">113</span> <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">114</span> <span class="k">def</span> <span class="nf">out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="g g-Whitespace">    </span><span class="mi">115</span>     <span class="k">for</span> <span class="n">callback</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_before</span><span class="p">:</span>
<span class="ne">--&gt; </span><span class="mi">116</span>         <span class="n">callback</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">117</span>     <span class="n">retval</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">118</span>     <span class="k">for</span> <span class="n">callback</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_after</span><span class="p">:</span>

<span class="nn">File ~/Prog/miniconda3/envs/qml/lib/python3.8/site-packages/qiskit/utils/lazy_tester.py:39,</span> in <span class="ni">_RequireNow.__call__</span><span class="nt">(self, *_args, **_kwargs)</span>
<span class="g g-Whitespace">     </span><span class="mi">38</span> <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">_args</span><span class="p">,</span> <span class="o">**</span><span class="n">_kwargs</span><span class="p">):</span>
<span class="ne">---&gt; </span><span class="mi">39</span>     <span class="bp">self</span><span class="o">.</span><span class="n">_tester</span><span class="o">.</span><span class="n">require_now</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_feature</span><span class="p">)</span>

<span class="nn">File ~/Prog/miniconda3/envs/qml/lib/python3.8/site-packages/qiskit/utils/lazy_tester.py:223,</span> in <span class="ni">LazyDependencyManager.require_now</span><span class="nt">(self, feature)</span>
<span class="g g-Whitespace">    </span><span class="mi">221</span> <span class="k">if</span> <span class="bp">self</span><span class="p">:</span>
<span class="g g-Whitespace">    </span><span class="mi">222</span>     <span class="k">return</span>
<span class="ne">--&gt; </span><span class="mi">223</span> <span class="k">raise</span> <span class="n">MissingOptionalLibraryError</span><span class="p">(</span>
<span class="g g-Whitespace">    </span><span class="mi">224</span>     <span class="n">libname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">feature</span><span class="p">,</span> <span class="n">pip_install</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_install</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_msg</span>
<span class="g g-Whitespace">    </span><span class="mi">225</span> <span class="p">)</span>

<span class="ne">MissingOptionalLibraryError</span>: &quot;The &#39;pylatexenc&#39; library is required to use &#39;MatplotlibDrawer&#39;. You can install it with &#39;pip install pylatexenc&#39;.&quot;
</pre></div>
</div>
</div>
</div>
<p>We can see how the quantum register <code class="docutils literal notranslate"><span class="pre">qr</span></code> is constructed from the four qubits <span class="math notranslate nohighlight">\(q0_0\)</span> to <span class="math notranslate nohighlight">\(q0_3\)</span>. (q0 is actually the name of the register itself.) Note that the qubit label starts with index 0 according to the indexing in Python.</p>
<p>We will create a source state <span class="math notranslate nohighlight">\(|\psi_\textrm{S}\rangle\)</span> between qubits <span class="math notranslate nohighlight">\(q0_0\)</span> (qubit 0) and <span class="math notranslate nohighlight">\(q0_1\)</span> (qubit 1) and between qubits <span class="math notranslate nohighlight">\(q0_2\)</span> (qubit 2) and <span class="math notranslate nohighlight">\(q0_3\)</span> (qubit 3). Qubit 0 and qubit 1 should serve as control qubits, while the target qubits are qubit 2 and qubit 3. If we compare this with the representation in the introductory <strong>Part I</strong>, we find the following correspondences:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Qubit</p></th>
<th class="head text-center"><p>Notation</p></th>
<th class="head text-center"><p>Notation in Qiskit</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>Control qubit Alice</p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(q_{A,c}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(q0_0\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>Control qubit Bob</p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(q_{B,c}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(q0_1\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>Target qubit Alice</p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(q_{A,t}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(q0_2\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>Target qubit Bob</p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(q_{B,t}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(q0_3\)</span></p></td>
</tr>
</tbody>
</table>
<p>The following shows how to set the control pair to <span class="math notranslate nohighlight">\(|\psi_\textrm{S}\rangle\)</span>. The implementation for the target pair is left as an exercise.</p>
<p>By default, all qubits are initialized to the state <span class="math notranslate nohighlight">\(|0\rangle\)</span>, i.e. the state <span class="math notranslate nohighlight">\(|\psi_\textrm{control}\rangle\)</span> of the control pair is</p>
<div class="math notranslate nohighlight">
\[
|\psi_\textrm{control}\rangle = |0\rangle_{0} |0\rangle_{1},
\]</div>
<p>where the index is to denote the corresponding qubit. As first step we flip qubit 1 using a Pauli-<span class="math notranslate nohighlight">\(X\)</span> gate,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
X = 
\begin{pmatrix}
0 &amp; 1 \\
1 &amp; 0 \\
\end{pmatrix}.
\end{split}\]</div>
<p>In Qiskit a Pauli-<span class="math notranslate nohighlight">\(X\)</span> gate can be implemented in a quantum circuit with the method <code class="docutils literal notranslate"><span class="pre">x</span></code> of the class<code class="docutils literal notranslate"><span class="pre">QuantumCircuit</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">source_circ</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">qr</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</pre></div>
</div>
</div>
</div>
<p>Every qubit <span class="math notranslate nohighlight">\(i\)</span> in the register can be called with <code class="docutils literal notranslate"><span class="pre">qr[i]</span></code>. So <code class="docutils literal notranslate"><span class="pre">x(qr[1])</span></code> implements an <span class="math notranslate nohighlight">\(X\)</span> gate on qubit 1. If we draw the quantum circuit again, we see that a single-qubit gate <span class="math notranslate nohighlight">\(X\)</span> is applied to qubit <span class="math notranslate nohighlight">\(q0_1\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">source_circ</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../../_images/bd0e10c3ffd2d175cf92a4762c208c083496d008aa693b6daaff1e016b869eb3.png" src="../../../../_images/bd0e10c3ffd2d175cf92a4762c208c083496d008aa693b6daaff1e016b869eb3.png" />
</div>
</div>
<p>After applying the <span class="math notranslate nohighlight">\(X\)</span> gate, the control pair is in the state</p>
<div class="math notranslate nohighlight">
\[
|\psi_\textrm{control}\rangle = |0\rangle_{0} |1\rangle_{1}.
\]</div>
<p>We then apply a specific single-qubit gate from the general single-qubit rotations <span class="math notranslate nohighlight">\(u(\theta, \phi, \lambda)\)</span> to qubit 0,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
u(\theta, \phi , \lambda) = \begin{pmatrix}
\cos(\theta/2) &amp; -e^{i\lambda}\sin(\theta/2) \\
e^{i\phi}\sin(\theta/2) &amp; e^{i\lambda+i\phi}\cos(\theta/2) 
\end{pmatrix}.
\end{split}\]</div>
<p>We set the parameters <span class="math notranslate nohighlight">\(\phi = \pi\)</span> and <span class="math notranslate nohighlight">\(\lambda = 0\)</span>,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
u(\theta, \phi = \pi , \lambda = 0) = \begin{pmatrix}
\cos(\theta/2) &amp; -\sin(\theta/2) \\
-\sin(\theta/2) &amp; -\cos(\theta/2) \\
\end{pmatrix},
\end{split}\]</div>
<p>to bring the control qubits into the following state</p>
<div class="math notranslate nohighlight">
\[
|\psi_\textrm{control}\rangle = \cos\left(\frac{\theta}{2}\right) |0\rangle_{0} |1\rangle_{1} - \sin\left(\frac{\theta}{2}\right) |1\rangle_{0} |1\rangle_{1}.
\]</div>
<p>Such a one-qubit rotation is realized with the method <code class="docutils literal notranslate"><span class="pre">u</span></code>, to which we pass the rotation parameters as input arguments:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a parameter theta</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">)</span>

<span class="c1"># Implement a parametrized single-qubit gate u on qubit 0</span>
<span class="n">source_circ</span><span class="o">.</span><span class="n">u</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">qr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</pre></div>
</div>
</div>
</div>
<p>Later in this tutorial, we will perform entanglement purification for different input fidelities <span class="math notranslate nohighlight">\(F\)</span>, i.e. for different values of <span class="math notranslate nohighlight">\(\theta\)</span>. Therefore, we have defined a parameter called <code class="docutils literal notranslate"><span class="pre">theta</span></code>, which is an instance of the class <code class="docutils literal notranslate"><span class="pre">Parameter</span></code> and to which a value can be assigned when the quantum circuit is executed. The input parameters of the method <code class="docutils literal notranslate"><span class="pre">u</span></code> are the angles <span class="math notranslate nohighlight">\(\theta\)</span>, <span class="math notranslate nohighlight">\(\phi\)</span> and <span class="math notranslate nohighlight">\(\lambda\)</span>, and the qubit to which the gate is applied. If we draw the circuit again, we now see another single-qubit operation <span class="math notranslate nohighlight">\(U\)</span> applied to qubit <span class="math notranslate nohighlight">\(q0_0\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">source_circ</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../../_images/3ca7012fda8934336cf6bca693b6dd65f21eb7c6183bd1bf544dc04e2efddf2b.png" src="../../../../_images/3ca7012fda8934336cf6bca693b6dd65f21eb7c6183bd1bf544dc04e2efddf2b.png" />
</div>
</div>
<p>Now we have to use a CNOT gate between qubit 0 and qubit 1, where qubit 1 is flipped if qubit 0 is in the state <span class="math notranslate nohighlight">\(|1\rangle\)</span> to create the desired source state <span class="math notranslate nohighlight">\(|\psi_\textrm{S}\rangle\)</span>,</p>
<div class="math notranslate nohighlight">
\[
|\psi_\textrm{control}\rangle =
|\psi_\textrm{S}\rangle =
\cos\left(\frac{\theta}{2}\right) |0\rangle_{0} |1\rangle_{1} - \sin\left(\frac{\theta}{2}\right) |1\rangle_{0} |0\rangle_{1}.
\]</div>
<p>In Qiskit a CNOT gate can be added to a quantum circuit using the method <code class="docutils literal notranslate"><span class="pre">cx</span></code>, which uses the control and the target qubit as input arguments:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Implement a CNOT between qubit 0 as control qubit and qubit 1 as target qubit</span>
<span class="n">source_circ</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qr</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</pre></div>
</div>
</div>
</div>
<p>(To avoid any misunderstandings here due to the term control and target qubit: The CNOT used here serves to generate the source state <span class="math notranslate nohighlight">\(|\psi_\textrm{S}\rangle\)</span> and has nothing to do with the bilateral CNOT of the BBPSSW protocol.)</p>
<p>The complete quantum circuit to simulate a source of entangled qubit pairs and generate the state <span class="math notranslate nohighlight">\(|\psi_\textrm{S}\rangle\)</span> between qubits <span class="math notranslate nohighlight">\(q0_0\)</span> and <span class="math notranslate nohighlight">\(q0_1\)</span> looks like this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">source_circ</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../../_images/307bf13d9bcefe3966b73ea084ebc11cc10e3ecfb32ab9b6787efcd7b97153e6.png" src="../../../../_images/307bf13d9bcefe3966b73ea084ebc11cc10e3ecfb32ab9b6787efcd7b97153e6.png" />
</div>
</div>
<p>Since we need two copies of the state <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span> to perform entanglement purification, we also need to set qubits 2 and 3 to the source state <span class="math notranslate nohighlight">\(|\psi_\textrm{S}\rangle\)</span>,</p>
<div class="math notranslate nohighlight">
\[
|\psi_\textrm{target}\rangle =
|\psi_\textrm{S}\rangle =
\cos\left(\frac{\theta}{2}\right) |0\rangle_{2} |1\rangle_{3} - \sin\left(\frac{\theta}{2}\right) |1\rangle_{2} |0\rangle_{3}.
\]</div>
<p>We call this state <span class="math notranslate nohighlight">\(|\psi_\textrm{target}\rangle\)</span> because the two qubits are the target pair of the BBPSSW protocol.</p>
</section>
<section id="send-it-after-class-1">
<h4>Send it after class 1<a class="headerlink" href="#send-it-after-class-1" title="Permalink to this heading">¶</a></h4>
<p>Add the necessary quantum gates to the circuit <code class="docutils literal notranslate"><span class="pre">source_circ</span></code> so that the state <span class="math notranslate nohighlight">\(|\psi_\textrm{S}\rangle\)</span> is generated between qubits 2 and 3. The implementation can be done in analogy to the above steps in which this state was generated between the control qubits.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">###</span>
<span class="c1">### Enter your code below</span>
<span class="c1">###</span>

<span class="c1"># Implement a Pauli-X gate on qubit 3</span>
<span class="n">source_circ</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">qr</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

<span class="c1"># Implement a single-qubit gate u on qubit 2</span>
<span class="n">source_circ</span><span class="o">.</span><span class="n">u</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">pi</span> <span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">qr</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

<span class="c1"># Implement a CNOT between qubit 2 as control qubit and qubit 3 as target qubit</span>
<span class="n">source_circ</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">qr</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">qr</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
</pre></div>
</div>
</div>
</div>
<p>You can check your solution for Exercise 1 by drawing the circuit <code class="docutils literal notranslate"><span class="pre">source_circ</span></code> and comparing the two parts that create the state <span class="math notranslate nohighlight">\(|\psi_\textrm{S}\rangle\)</span> between the control and the target qubits:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">source_circ</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>A single-qubit rotation <span class="math notranslate nohighlight">\(U(\textrm{theta}, \pi, 0)\)</span> should now also be applied to qubit <span class="math notranslate nohighlight">\(q0_2\)</span>, an <span class="math notranslate nohighlight">\(X\)</span> gate should also be applied to qubit <span class="math notranslate nohighlight">\(q0_3\)</span> and a CNOT should be applied between the two qubits.</p>
<p>To clearly define which qubits are the control pair and which qubits are the target pair of the BBPSSW protocol, we define the two arrays <code class="docutils literal notranslate"><span class="pre">control_qubits</span></code> and <code class="docutils literal notranslate"><span class="pre">target_qubits</span></code>, which contain the corresponding qubits:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">control_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="n">qr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span class="n">target_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="n">qr</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">qr</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="implementation-of-twirl-operation-by-random-bilateral-rotation">
<h4>2.3.3 Implementation of Twirl Operation by Random Bilateral Rotation<a class="headerlink" href="#implementation-of-twirl-operation-by-random-bilateral-rotation" title="Permalink to this heading">¶</a></h4>
<p>To implement the twirl operation, we create another instance of a quantum circuit called <code class="docutils literal notranslate"><span class="pre">twirl_circ</span></code> that performs the random bilateral rotation explained in step 1 of <strong>Sec. 1.2</strong>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">twirl_circ</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">qr</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Remember: To implement the twirl, Alice and Bob randomly select an element from the set of 12 bilateral operations <span class="math notranslate nohighlight">\(\{U_i\}\)</span> and apply the corresponding rotations locally to their qubit.</p>
<p>To implement an operation randomly selected from <span class="math notranslate nohighlight">\(\{U_i\}\)</span>, we define an auxiliary function <code class="docutils literal notranslate"><span class="pre">bilateral_rotation</span></code>. This function has the following input parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">circuit</span></code>: The instance of a quantum circuit to which the rotations are to be added.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qubits</span></code>: A list of qubits, each of which is rotated.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rot_idx</span></code>: An integer number that numbers the elements of the set <span class="math notranslate nohighlight">\(\{U_i\}\)</span>. For example, <code class="docutils literal notranslate"><span class="pre">rot_idx</span> <span class="pre">=</span> <span class="pre">0</span></code> corresponds to the identity operation, <code class="docutils literal notranslate"><span class="pre">rot_idx</span> <span class="pre">=</span> <span class="pre">1</span></code> corresponds <span class="math notranslate nohighlight">\(B_x B_x\)</span>, and so on.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bilateral_rotation</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">qubits</span><span class="p">,</span> <span class="n">rot_idx</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adds a bilateral rotation to a quantum circuit.</span>
<span class="sd">    </span>
<span class="sd">    Keyword arguments:</span>
<span class="sd">    circuit --  quantum circuit to which the rotations are added</span>
<span class="sd">    qubits -- alist of qubits, each of which is rotated</span>
<span class="sd">    rot_idx -- integer that numbers the rotations from the set of all rotations, ranges from 0 to 11</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="n">qubits</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rot_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        
        <span class="k">elif</span> <span class="n">rot_idx</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">rot_idx</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">rot_idx</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">rot_idx</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">rot_idx</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">rot_idx</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">rot_idx</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">rot_idx</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">rot_idx</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">rot_idx</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">rot_idx</span> <span class="o">==</span> <span class="mi">11</span><span class="p">:</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">qubit</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Input argument rot_idx has to be an integer between 0 and 11.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The single-qubit rotations around the <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> axes required for the bilateral rotation can be implemented in Qiskit with the following methods:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rx</span></code>: Rotation about the <span class="math notranslate nohighlight">\(x\)</span> axis.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ry</span></code>: Rotation about the <span class="math notranslate nohighlight">\(y\)</span> axis.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rz</span></code>: Rotation about the <span class="math notranslate nohighlight">\(z\)</span> axis.</p></li>
</ul>
<p>The angle of rotation and the respective qubit must be specified as input arguments.</p>
<p>Remember that the bilateral operations <span class="math notranslate nohighlight">\(B_k\)</span> from which the elements of <span class="math notranslate nohighlight">\(\{ U_i\}\)</span> are constructed are rotations around the <span class="math notranslate nohighlight">\(k\)</span> axis by an angle of <span class="math notranslate nohighlight">\(\pi/2\)</span> and that the rotations are applied to both qubits of the entangled pair. With this knowledge it is understandable how the operations in the function <code class="docutils literal notranslate"><span class="pre">bilateral_rotation</span></code> are built up from single-qubit rotations <code class="docutils literal notranslate"><span class="pre">rx</span></code>, <code class="docutils literal notranslate"><span class="pre">ry</span></code> and <code class="docutils literal notranslate"><span class="pre">rz</span></code> by angles of <span class="math notranslate nohighlight">\(\pi/2\)</span>.</p>
<p>Now we add a random bilateral rotation to the circuit <code class="docutils literal notranslate"><span class="pre">twirl_circ</span></code> with the function <code class="docutils literal notranslate"><span class="pre">bilateral_rotation</span></code>, once for the control qubit pair and once for the target qubit pair:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a random integer between 0 and 11</span>
<span class="n">random_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># Add a random bilateral rotation to the circuit, applied to qubits 0 and 1 (control qubits)</span>
<span class="n">bilateral_rotation</span><span class="p">(</span><span class="n">twirl_circ</span><span class="p">,</span> <span class="n">control_qubits</span><span class="p">,</span> <span class="n">random_idx</span><span class="p">)</span>

<span class="c1"># Add a random bilateral rotation to the circuit, applied to qubits 2 and 3 (target qubits)</span>
<span class="n">bilateral_rotation</span><span class="p">(</span><span class="n">twirl_circ</span><span class="p">,</span> <span class="n">target_qubits</span><span class="p">,</span> <span class="n">random_idx</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The circuit <code class="docutils literal notranslate"><span class="pre">twirl_circ</span></code> thus has the following structure:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">twirl_circ</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>If this operation is applied to a large number of qubit pairs in the state <span class="math notranslate nohighlight">\(|\psi_\textrm{S}\rangle\)</span>, the average output state is a Werner state <span class="math notranslate nohighlight">\(W_F\)</span> (see step 1, <strong>Sec. 1.2</strong>),</p>
<div class="math notranslate nohighlight">
\[
W_F = F |\Psi^-\rangle \langle \Psi^-| + \frac{1-F}{3}\left(|\Psi^+\rangle \langle \Psi^+|+|\Phi^+\rangle \langle \Phi^+|+|\Phi^-\rangle \langle \Phi^-|\right).  
\]</div>
<p>This means that on average the control and target pairs are brought into a Werner state after the circuit <code class="docutils literal notranslate"><span class="pre">twirl_circ</span></code> has been applied.</p>
</section>
<section id="exchange-of-psi-rangle-and-phi-rangle-components">
<h4>2.3.4 Exchange of <span class="math notranslate nohighlight">\(|\Psi^-\rangle\)</span> and <span class="math notranslate nohighlight">\(|\Phi^+\rangle\)</span> Components<a class="headerlink" href="#exchange-of-psi-rangle-and-phi-rangle-components" title="Permalink to this heading">¶</a></h4>
<p>The next step is that Alice applies a unilateral <span class="math notranslate nohighlight">\(\pi\)</span> rotation around the <span class="math notranslate nohighlight">\(y\)</span> axis to her qubits, so that the components of <span class="math notranslate nohighlight">\(|\Psi^-\rangle\)</span> and <span class="math notranslate nohighlight">\(|\Phi^+\rangle\)</span> are exchanged in the control and the target pair, which leads to the transformation of a Werner state <span class="math notranslate nohighlight">\(W_F\)</span> into the state <span class="math notranslate nohighlight">\(\rho_F\)</span> (see step 2, <strong>Sec 1.2</strong>),</p>
<div class="math notranslate nohighlight">
\[
\rho_F = F |\Phi^+\rangle \langle \Phi^+| + \frac{1-F}{3}\left(|\Psi^+\rangle \langle \Psi^+|+|\Psi^-\rangle \langle \Psi^-|+|\Phi^-\rangle \langle \Phi^-|\right). 
\]</div>
<p>This means that the rotations are applied to one qubit of the control pair and one qubit of the target pair. Such a rotation corresponds to a Pauli-<span class="math notranslate nohighlight">\(Y\)</span> gate, i.e. a bit flip and a phase flip gate,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
Y = 
\begin{pmatrix}
0 &amp; -i \\
i &amp; 0 \\
\end{pmatrix}.
\end{split}\]</div>
<p>With Qiskit, such a rotation can be applied to a qubit with the method <code class="docutils literal notranslate"><span class="pre">y</span></code> on a circuit. We create a new quantum circuit called <code class="docutils literal notranslate"><span class="pre">purification_circ</span></code> and add the <span class="math notranslate nohighlight">\(Y\)</span> gates to the corresponding qubits:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">purification_circ</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">qr</span><span class="p">)</span>

<span class="c1"># Implement a Pauli-Y gate on Alice&#39;s control qubit</span>
<span class="n">purification_circ</span><span class="o">.</span><span class="n">y</span><span class="p">(</span><span class="n">control_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1"># Implement a Pauli-Y gate on Alice&#39;s target qubit</span>
<span class="n">purification_circ</span><span class="o">.</span><span class="n">y</span><span class="p">(</span><span class="n">target_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</pre></div>
</div>
</div>
</div>
<p>We call this quantum circuit <code class="docutils literal notranslate"><span class="pre">purification_circ</span></code>, because this operation is actually the first part of the BBPSSW protocol, which starts from qubit pairs in the Werner state <span class="math notranslate nohighlight">\(W_F\)</span>. (In the next section we therefore add the bilateral CNOT gate to this circuit.)</p>
<p>In this quantum circuit, the single-qubit operations <span class="math notranslate nohighlight">\(Y\)</span> are applied to the qubits <span class="math notranslate nohighlight">\(q0_0\)</span> and <span class="math notranslate nohighlight">\(q0_2\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">purification_circ</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>If the quantum circuit <code class="docutils literal notranslate"><span class="pre">purification_circ</span></code> is applied to two qubit pairs in the Werner state <span class="math notranslate nohighlight">\(W_F\)</span>, this results in two qubit pairs in the state <span class="math notranslate nohighlight">\(\rho_F\)</span>.</p>
</section>
<section id="application-of-bilateral-cnot-gate">
<h4>2.3.5 Application of Bilateral CNOT Gate<a class="headerlink" href="#application-of-bilateral-cnot-gate" title="Permalink to this heading">¶</a></h4>
<p>The next step of the BBPSSW protocol is that Alice and Bob apply a bilateral CNOT gate. This means that Alice and Bob each perform a CNOT gate between the two qubits they hold locally (step 3, <strong>Sec 1.2</strong>).</p>
</section>
<section id="send-it-after-class-2">
<h4>Send it after class 2<a class="headerlink" href="#send-it-after-class-2" title="Permalink to this heading">¶</a></h4>
<p>We have already defined the arrays <code class="docutils literal notranslate"><span class="pre">control_qubits</span></code> and <code class="docutils literal notranslate"><span class="pre">target_qubits</span></code> above, which contain the qubits of the control and the target pair. The first element of these arrays is Alice’s qubit and the second is Bob’s.</p>
<p>Add the bilateral CNOT operation to the quantum circuit <code class="docutils literal notranslate"><span class="pre">purification_circ</span></code> by applying CNOT gates between the corresponding elements of the <code class="docutils literal notranslate"><span class="pre">control_qubits</span></code> and <code class="docutils literal notranslate"><span class="pre">target_qubits</span></code> arrays. I.e. a CNOT between Alice’s qubits and a CNOT between Bob’s qubits. Remember that in Qiskit a CNOT gate is implemented using the method <code class="docutils literal notranslate"><span class="pre">cx</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">###</span>
<span class="c1">### Enter your code below</span>
<span class="c1">###</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">purification_circ</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">control_qubits</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">target_qubits</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>If you now draw the circuit <code class="docutils literal notranslate"><span class="pre">purification_circ</span></code>, you should see two CNOT gates in addition to the two <span class="math notranslate nohighlight">\(Y\)</span> gates, one between qubits <span class="math notranslate nohighlight">\(q0_0\)</span> and <span class="math notranslate nohighlight">\(q0_2\)</span>, and one between qubits <span class="math notranslate nohighlight">\(q0_1\)</span> and <span class="math notranslate nohighlight">\(q0_3\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">purification_circ</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In the subsequent step of the BBPSSW protocol (step 4, <strong>Sec 1.2</strong>) the target qubits (qubits 2 and 3) should be measured in the computational basis. The measurement results must then be compared a successful round of entanglement purification.</p>
<p>We will implement this step during the process of quantum state tomography, but this is described and explained below (<strong>Sec 2.4</strong>). Briefly summarized: It will work in such a way that we will only perform state tomography of the control qubits if the results of the measurements of the target qubits are the same.</p>
<p>We would like to point out once again that after the bilateral CNOT gate and the measurement of the target qubits, the control qubit pair must be returned to Werner form in order to perform a subsequent purification round (step 5, <strong>Sec. 1.2</strong>). As already explained, this step is not necessary to prove an increase in fidelity and can therefore be omitted for our purposes.</p>
</section>
<section id="concatenation-of-quantum-circuits">
<h4>2.3.6 Concatenation of Quantum Circuits<a class="headerlink" href="#concatenation-of-quantum-circuits" title="Permalink to this heading">¶</a></h4>
<p>We have divided the entire quantum circuit for the BBPSSW protocol into three parts for the initialization of the entangled qubit pairs (<code class="docutils literal notranslate"><span class="pre">source_circ</span></code>), the twirl operation (<code class="docutils literal notranslate"><span class="pre">twirl_circ</span></code>) and the purification step itself (<code class="docutils literal notranslate"><span class="pre">purification_circ</span></code>).</p>
<p>(Note that this was only done for educational reasons. We could have built all gates into a single quantum circuit from the beginning.)</p>
<p>In Qiskit it is possible to concatenate quantum circuits simply by adding. Therefore, the entire quantum circuit for the purification experiment can be constructed from the three circuits <code class="docutils literal notranslate"><span class="pre">source_circ</span></code>, <code class="docutils literal notranslate"><span class="pre">twirl_circ</span></code>, and <code class="docutils literal notranslate"><span class="pre">purification_circ</span></code> as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">experiment_circ</span> <span class="o">=</span> <span class="n">source_circ</span> <span class="o">+</span> <span class="n">twirl_circ</span> <span class="o">+</span> <span class="n">purification_circ</span>
</pre></div>
</div>
</div>
</div>
<p>Overall, the complete circuit for the BBPSSW protocol has the following structure:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">experiment_circ</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can now compare this with the quantum circuits from the introductory part (<strong>Part I</strong>). The gates up to the first CNOTs are not part of Alice’s and Bob’s circuits presented in the introduction. This is because these gates are needed to first simulate the source that creates the source states <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span>. Then we recognize the single-qubit parts <span class="math notranslate nohighlight">\(U_{i,A(B)}\)</span> of the bilateral rotation <span class="math notranslate nohighlight">\(U_i\)</span>, which of course depend here on the random index <code class="docutils literal notranslate"><span class="pre">random_idx</span></code> chosen above. (Only in the case of <code class="docutils literal notranslate"><span class="pre">random_idx</span> <span class="pre">=</span> <span class="pre">0</span></code> do you actually see no parts of the bilateral rotation, as this corresponds to the identity operation.) Then the unilateral rotations Alice performs are implemented on the qubits <span class="math notranslate nohighlight">\(q0_0\)</span> and <span class="math notranslate nohighlight">\(q0_2\)</span>, followed by the bilateral CNOT.</p>
</section>
</section>
<section id="conditional-quantum-state-tomography">
<h3>2.4 (Conditional) Quantum State Tomography<a class="headerlink" href="#conditional-quantum-state-tomography" title="Permalink to this heading">¶</a></h3>
<p>Finally, we want to find out the state <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span> of the control qubit pair, i.e. the state of the qubits 0 and 1, so that we can calculate its fidelity <span class="math notranslate nohighlight">\(F'\)</span> (see step 4, <strong>Sec 1.2</strong>),</p>
<div class="math notranslate nohighlight">
\[
F' = \langle \Phi^+ | \rho'_{F'} | \Phi^+ \rangle.
\]</div>
<p>To reconstruct the density matrix <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span>, we can use methods of <strong>quantum tomography</strong>. The library for tomography is part of the Qiskit element <strong>Ignis</strong>, which is a framework for handling noise in quantum circuits. Qiskit Ignis offers methods for the implementation of state and process tomography. For the purification protocol we only have to implement <strong>quantum state tomography</strong> and will therefore concentrate on it in this tutorial.</p>
<p>The functions and classes necessary for performing quantum state tomography can be imported from the tomography library:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.ignis.verification.tomography</span> <span class="kn">import</span> <span class="n">state_tomography_circuits</span><span class="p">,</span> <span class="n">StateTomographyFitter</span>
</pre></div>
</div>
</div>
</div>
<p>In order to perform quantum state tomography, we must first generate tomography circuits with the function <code class="docutils literal notranslate"><span class="pre">state_tomography_circuits</span></code>. From the measurement results of these tomography circuits we can then reconstruct the state <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span> with methods of the fitter class <code class="docutils literal notranslate"><span class="pre">StateTomographyFitter</span></code>.</p>
<p>The tomography circuits themselves consist of the original circuit to which specific gates and qubit measurements are attached. The function <code class="docutils literal notranslate"><span class="pre">state_tomography_circuits</span></code> therefore has the following input arguments:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">circuit</span></code>: Quantum circuit on which the tomography is performed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">measured_qubits</span></code>: List of qubits whose quantum state is being reconstructed.</p></li>
</ul>
<p>In our case we want to reconstruct the state of the control qubits after executing the circuit <code class="docutils literal notranslate"><span class="pre">experiment_circ</span></code>. The desired state tomography circuits can therefore be generated as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tomography_circs</span> <span class="o">=</span> <span class="n">state_tomography_circuits</span><span class="p">(</span><span class="n">experiment_circ</span><span class="p">,</span> <span class="n">control_qubits</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">tomography_circs</span></code> is a list of quantum circuits and from the measurement results of all these circuits the state <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span> can be reconstructed.</p>
<p>As an example, the first tomography circuit looks like this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tomography_circs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can recognize the circuit <code class="docutils literal notranslate"><span class="pre">experiment_circ</span></code> up to the bilateral CNOT gate and see that two additional Hadamard gates are applied to the qubits <span class="math notranslate nohighlight">\(q0_0\)</span> and <span class="math notranslate nohighlight">\(q0_1\)</span>. The control qubits are then measured in the computational basis and the measurement results are stored in a classical register <span class="math notranslate nohighlight">\(c0\)</span>. This classical register was also added by the function <code class="docutils literal notranslate"><span class="pre">state_tomography_circuits</span></code> and its size corresponds to the number of qubits whose quantum state is to be reconstructed.</p>
<p>From the execution results of <code class="docutils literal notranslate"><span class="pre">tomography_circs</span></code> we would reconstruct the density matrix of the control qubits if no measurement was performed on the target qubits. Thus, one can and should rightly remark that <strong>Step 4 (Measurement of Target Qubits)</strong> of the BBPSSW protocol is missing in the quantum circuit <code class="docutils literal notranslate"><span class="pre">experiment_circ</span></code>. Remember that purification only worked if the target qubits were measured and the measurements gave the same results. This is a crucial step, which must, of course, also be taken into account here! For this purpose, we will perform <strong>conditional quantum state tomography</strong> and adapt a strategy presented in [6] to our needs.</p>
<p>By conditional state tomography, we mean here that the tomography is only performed if the target qubits were previously measured either both in the state <span class="math notranslate nohighlight">\(|0\rangle\)</span> or both in the state <span class="math notranslate nohighlight">\(|1\rangle\)</span>. This corresponds exactly to the discarding of all failed purifications. Therefore we have to add the measurements of the target qubits before building the tomography circuits with the function <code class="docutils literal notranslate"><span class="pre">state_tomography_circuits</span></code>.</p>
<p>Now an instance of the class <code class="docutils literal notranslate"><span class="pre">StateTomographyFitter</span></code>, from which we can finally reconstruct a density matrix, is constructed from a set of tomography circuits and the corresponding execution results. The constructor of the class <code class="docutils literal notranslate"><span class="pre">StateTomographyFitter</span></code> needs as input argument a set of quantum circuits in the form of the tomography circuits <code class="docutils literal notranslate"><span class="pre">tomography_circs</span></code>, which contain exactly one classical register <span class="math notranslate nohighlight">\(c0\)</span> consisting of two classical bits. However, if we first add the additional measurements of the target qubits, we introduce another classical register to store the measurement results. And in this case we can no longer construct the fitter directly, since the tomography circuits would now contain two classical registers.</p>
<p>What we will do instead is to make a copy of the circuit <code class="docutils literal notranslate"><span class="pre">experiment_circ</span></code>, add the measurements of the target qubits, and create a set of corresponding tomography circuits. These circuits are then actually executed. The results of this execution can then be edited to keep only those cases where the target qubits were measured with the same results. The edited results can then be fed into the fitter along with our original circuits <code class="docutils literal notranslate"><span class="pre">tomography_circs</span></code> to reconstruct the state <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span> of the control qubits.</p>
<p>The following shows how to create these ancilla circuits and <strong>Part III</strong> explains in detail how to edit the execution results correctly.</p>
<p>The conditional state tomography is thus implemented as follows. First we make a copy of our original circuit <code class="docutils literal notranslate"><span class="pre">experiment_circ</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ancilla_circ</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">experiment_circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We call this circuit <code class="docutils literal notranslate"><span class="pre">ancilla_circ</span></code> because it helps to generate the information needed to reconstruct <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span>.</p>
<p>We then add a classical register to <code class="docutils literal notranslate"><span class="pre">ancilla_circ</span></code> which is an instance of the class <code class="docutils literal notranslate"><span class="pre">ClassicalRegister</span></code> to store the results of the measurement of the target qubits. We need a two-bit register here:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a classical register cr consisting of two bits</span>
<span class="n">cr</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Add the classical register to the circuit</span>
<span class="n">ancilla_circ</span><span class="o">.</span><span class="n">add_register</span><span class="p">(</span><span class="n">cr</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we must actually add the measurements of the target qubits. A measurement process can be added to a quantum circuit using the method <code class="docutils literal notranslate"><span class="pre">measure</span></code>. The method requires two input arguments, namely the qubit to be measured and the bit in a classical register for storing the measurement result.</p>
<p>The desired measurement of the target qubits can therefore be implemented as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Implement a measurement of Alice&#39;s target qubit and store the result in bit 0</span>
<span class="n">ancilla_circ</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">target_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1"># Implement a measurement of Bob&#39;s target qubit and store the result in bit 1</span>
<span class="n">ancilla_circ</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">target_qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cr</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s have a look at the circuit <code class="docutils literal notranslate"><span class="pre">ancilla_circ</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ancilla_circ</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>From the circuit diagram we can see that a classical register <span class="math notranslate nohighlight">\(c1\)</span> has been added to the circuit <code class="docutils literal notranslate"><span class="pre">ancilla_circ</span></code> compared to the original circuit <code class="docutils literal notranslate"><span class="pre">experiment_circ</span></code> and that the qubits <span class="math notranslate nohighlight">\(q0_2\)</span> and <span class="math notranslate nohighlight">\(q0_3\)</span> are measured after the bilateral CNOT.</p>
<p>For the circuit <code class="docutils literal notranslate"><span class="pre">ancilla_circ</span></code> we also create tomography circuits <code class="docutils literal notranslate"><span class="pre">ancilla_tomography_circs</span></code> using the function <code class="docutils literal notranslate"><span class="pre">state_tomography_circuits</span></code> to reconstruct the state of the control qubits:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ancilla_tomography_circs</span> <span class="o">=</span> <span class="n">state_tomography_circuits</span><span class="p">(</span><span class="n">ancilla_circ</span><span class="p">,</span> <span class="n">control_qubits</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>It is now these ancilla circuits <code class="docutils literal notranslate"><span class="pre">ancilla_tomography_circs</span></code> that are actually executed. As an example we draw one of the ancilla circuits:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ancilla_tomography_circs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We have already seen that the target qubits <span class="math notranslate nohighlight">\(q0_2\)</span> and <span class="math notranslate nohighlight">\(q0_3\)</span> are measured in the classical register <span class="math notranslate nohighlight">\(c1\)</span>. In addition, the results for the tomography of the control qubits <span class="math notranslate nohighlight">\(q0_0\)</span> and <span class="math notranslate nohighlight">\(q0_1\)</span> are stored in the automatically added classical register <span class="math notranslate nohighlight">\(c2\)</span>.</p>
<p>At this point, we already import a usefull function from the Python toolkit Mitiq [7], which removes all barriers from a quantum circuit:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#from mitiq.mitiq_qiskit.conversions import _remove_barriers</span>
<span class="kn">from</span> <span class="nn">qiskit.transpiler.passes</span> <span class="kn">import</span> <span class="n">RemoveBarriers</span>
</pre></div>
</div>
</div>
</div>
<p>The reason for removing the barriers is that circuits as shown above cannot be executed on real IBMQ hardware because no gates are allowed after measurements. Although in the example circuit <code class="docutils literal notranslate"><span class="pre">ancilla_tomography_circs[0]</span></code> above the two Hadamard gates on qubits 0 and 1 “follow” measurements on qubits 2 and 3, this circuit is still considered to be not executable on real IBMQ hardware. Therefore we will simply remove the barrier and by this make it executable:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#_remove_barriers(ancilla_tomography_circs[0]).draw(output=&#39;mpl&#39;)</span>
<span class="n">ancilla_tomography_circs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">RemoveBarriers</span><span class="p">()(</span><span class="n">ancilla_tomography_circs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">ancilla_tomography_circs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>At the end of this Part II, we are at the point where we have generated all the quantum circuits necessary to implement the full BBPSSW protocol. In the following part we can therefore continue with the simulation of the purification experiment and have our implementation run with the simulator integrated in Qiskit.</p>
</section>
</section>
<section id="part-iii-simulation-of-the-bbpssw-protocol-using-qiskit">
<h2>Part III: Simulation of the BBPSSW Protocol using Qiskit<a class="headerlink" href="#part-iii-simulation-of-the-bbpssw-protocol-using-qiskit" title="Permalink to this heading">¶</a></h2>
<hr class="docutils" />
<p>In this part we will simulate the quantum circuit for the BBPSSW protocol. For this we use a simulator that is integrated in Qiskit. In the first section we simulate the BBPSSW protocol for a single quantum system. To finally demonstrate a successful purification, we calculate an average of many quantum systems to generate approximately the state <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span> and extract the purified fidelity <span class="math notranslate nohighlight">\(F'\)</span>.</p>
<p>To execute a quantum circuit in Qiskit, we must first select a backend on which on which to run the quantum program. Such a backend can either be a simulator or a real IBM Q device.</p>
<p>The QASM simulator is part of the Qiskit element <strong>Aer</strong> and to use it we need to import the following libraries:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">Aer</span><span class="p">,</span> <span class="n">execute</span>
</pre></div>
</div>
</div>
</div>
<p>To select the simulator as backend for the execution of the quantum circuit, we use the method <code class="docutils literal notranslate"><span class="pre">get_backend</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">backend_QASM</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<section id="single-quantum-system">
<h3>3.1 Single Quantum System<a class="headerlink" href="#single-quantum-system" title="Permalink to this heading">¶</a></h3>
<p>In the following we will first execute the circuits <code class="docutils literal notranslate"><span class="pre">tomography_circs</span></code> and reconstruct the density matrix for the control qubits. This is done mainly for educational reasons to introduce the functionality of the class <code class="docutils literal notranslate"><span class="pre">StateTomographyFitter</span></code>. Then we run the ancilla circuits <code class="docutils literal notranslate"><span class="pre">ancilla_tomography_circs</span></code> and explain how to edit the execution results to be able to use the fitter.</p>
<p>We can execute a quantum circuit with the function <code class="docutils literal notranslate"><span class="pre">execute</span></code>, which requires the following input arguments:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">circuits</span></code>: A single quantum circuit or a list of quantum circuits to be executed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">backend</span></code>: The backend to run the circuits.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shots</span></code>: Number of repeated executions of each circuit.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">parameter_binds</span></code>: List of parameter-value pairs (given as python dictionary) that bind the parameters to specific values.</p></li>
</ul>
<p>To simulate the circuits <code class="docutils literal notranslate"><span class="pre">tomography_circs</span></code> with an input fidelity of e.g. <span class="math notranslate nohighlight">\(F=0.75\)</span>, we can execute the following code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">tomography_circs</span><span class="p">,</span> <span class="n">backend_QASM</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">parameter_binds</span><span class="o">=</span><span class="p">[{</span><span class="n">theta</span><span class="p">:</span> <span class="n">F_to_theta</span><span class="p">(</span><span class="mf">0.75</span><span class="p">)}])</span>
</pre></div>
</div>
</div>
</div>
<p>Here the parameter <span class="math notranslate nohighlight">\(\theta\)</span> is bound to the value corresponding to a fidelity of <span class="math notranslate nohighlight">\(F = 0.75\)</span> via the function <code class="docutils literal notranslate"><span class="pre">F_to_theta</span></code> defined at the beginning of the tutorial.</p>
<p>What is returned after the simulation is an object of the class <code class="docutils literal notranslate"><span class="pre">AerJob</span></code>, which we call <code class="docutils literal notranslate"><span class="pre">job</span></code> and from which we can extract the results of the simulation with the method <code class="docutils literal notranslate"><span class="pre">result</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job_results</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Now that we have performed the tomography circuits, we can reconstruct the density matrix of the control qubits using methods from quantum state tomography. All this is implemented in Qiskit by the class <code class="docutils literal notranslate"><span class="pre">StateTomographyFitter</span></code>.</p>
<p>Using the object <code class="docutils literal notranslate"><span class="pre">job_results</span></code> we first create a fitter object of the class <code class="docutils literal notranslate"><span class="pre">StateTomographyFitter</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fitter</span> <span class="o">=</span> <span class="n">StateTomographyFitter</span><span class="p">(</span><span class="n">job_results</span><span class="p">,</span> <span class="n">tomography_circs</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The fitter provides a method <code class="docutils literal notranslate"><span class="pre">fit</span></code> that returns the reconstructed density matrix that we call <code class="docutils literal notranslate"><span class="pre">rho_fit</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rho_fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>The two-qubit state <code class="docutils literal notranslate"><span class="pre">rho_fit</span></code> is returned as a 4x4 numpay array. Although for all further steps we only need this array, it might be helpful to explain a way to visualize quantum states in Qiskit simply for better illustration. We would like to mention the function <code class="docutils literal notranslate"><span class="pre">plot_state_city</span></code> which draws two bar blots of the real and imaginary parts of <code class="docutils literal notranslate"><span class="pre">rho_fit</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.tools.visualization</span> <span class="kn">import</span> <span class="n">plot_state_city</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_state_city</span><span class="p">(</span><span class="n">rho_fit</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now that we have seen how to use Qiskit’s tools for quantum state tomography, we can proceed and perform conditional quantum state tomography.</p>
<p>We start with the same steps as above, i.e. we first execute the ancillas <code class="docutils literal notranslate"><span class="pre">ancilla_tomography_circs</span></code> and retrieve the job results:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">ancilla_tomography_circs</span><span class="p">,</span> <span class="n">backend_QASM</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">parameter_binds</span><span class="o">=</span><span class="p">[{</span><span class="n">theta</span><span class="p">:</span> <span class="n">F_to_theta</span><span class="p">(</span><span class="mf">0.75</span><span class="p">)}])</span>
<span class="n">ancilla_results</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>So far the results object <code class="docutils literal notranslate"><span class="pre">ancilla_results</span></code> also contains results of unsuccessful executions (i.e. where the target qubits were measured with different outcomes) and it has a structure from which we cannot directly reconstruct the density matrix of the control qubits. So what we need to do is:</p>
<ol class="arabic simple">
<li><p>Discard the results of unsuccessful executions.</p></li>
<li><p>Remove the parts in the object <code class="docutils literal notranslate"><span class="pre">ancilla_results</span></code> that prevent us from using the fitter.</p></li>
</ol>
<p>To better see excatly what needs to be done, we compare the property <code class="docutils literal notranslate"><span class="pre">results</span></code> of the <code class="docutils literal notranslate"><span class="pre">job_results</span></code> and the <code class="docutils literal notranslate"><span class="pre">ancilla_results</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job_results</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ancilla_results</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>The property <code class="docutils literal notranslate"><span class="pre">results</span></code> is a list containing information about the results of each circuit executed.</p>
<p>First, the property <code class="docutils literal notranslate"><span class="pre">counts</span></code> must be adjusted so that all events where the target qubits had different outcomes are removed and the counts for the outcomes of the control qubits are corrected accordingly. In the following, we will explain in more detail what we mean by this.</p>
<p>We can get the counts as a dictionary using the method <code class="docutils literal notranslate"><span class="pre">get_counts</span></code>. For the first circuit in <code class="docutils literal notranslate"><span class="pre">ancilla_tomography_circs</span></code> the counts dictionary can be created like this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ancilla_results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In the bit strings, the left-most bit corresponds to the measurement outcome of qubit <span class="math notranslate nohighlight">\(q0_3\)</span> and the right-most bit to the outcome of qubit <span class="math notranslate nohighlight">\(q0_0\)</span>. Therefore, the first two bits are the outcomes of the target qubits and so we must remove all key-value pairs whose first two bits in the key are either <code class="docutils literal notranslate"><span class="pre">'01'</span></code> or <code class="docutils literal notranslate"><span class="pre">'10'</span></code>. In addition, we need to correct the counts of the control qubit outcomes. In the results <code class="docutils literal notranslate"><span class="pre">job_result</span></code>, the counts are:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job_results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Of course, here we can only have the events <code class="docutils literal notranslate"><span class="pre">'00'</span></code>, <code class="docutils literal notranslate"><span class="pre">'01'</span></code>, <code class="docutils literal notranslate"><span class="pre">'10'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'11'</span></code> because we only measure two qubits. From the counts of the <code class="docutils literal notranslate"><span class="pre">ancilla_results</span></code>, we must therefore add the counts of the successful events which have the same outcome of the control-qubit measurement. For example, if there were events such as <code class="docutils literal notranslate"><span class="pre">'00</span> <span class="pre">11'</span></code> and <code class="docutils literal notranslate"><span class="pre">'11</span> <span class="pre">11'</span></code>, then the counts of these events must be added for a control qubit outcome of <code class="docutils literal notranslate"><span class="pre">'11'</span></code>.</p>
<p>To store the edited counts, we first create an empty dictionary <code class="docutils literal notranslate"><span class="pre">conditional_counts</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">conditional_counts</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
</div>
<p>Then we loop through all entries in the dictionary <code class="docutils literal notranslate"><span class="pre">ancilla_results.get_counts(0)</span></code> and process the counts exactly as we described above:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">result</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">ancilla_results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="c1"># Get measurement out comes</span>
    <span class="n">target_measurement</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">control_measurement</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1"># Keep counts if target qubits were measured &#39;00&#39; or &#39;11&#39;</span>
    <span class="k">if</span> <span class="n">target_measurement</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;00&#39;</span><span class="p">,</span> <span class="s1">&#39;11&#39;</span><span class="p">):</span>
            
            <span class="c1"># Add counts to existing events or create new key-value pair</span>
            <span class="k">if</span> <span class="n">control_measurement</span> <span class="ow">in</span> <span class="n">conditional_counts</span><span class="p">:</span>
                <span class="n">conditional_counts</span><span class="p">[</span><span class="n">control_measurement</span><span class="p">]</span> <span class="o">=</span> <span class="n">conditional_counts</span><span class="p">[</span><span class="n">control_measurement</span><span class="p">]</span> <span class="o">+</span> <span class="n">count</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">conditional_counts</span><span class="p">[</span><span class="n">control_measurement</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
</pre></div>
</div>
</div>
</div>
<p>The edited counts dictionary, which only contains successful purification events, will then look like this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">conditional_counts</span>
</pre></div>
</div>
</div>
</div>
<p>We can now set the <code class="docutils literal notranslate"><span class="pre">conditional_counts</span></code> as the field <code class="docutils literal notranslate"><span class="pre">counts</span></code> of some other results object, e.g. following the above steps as <code class="docutils literal notranslate"><span class="pre">counts</span></code> of <code class="docutils literal notranslate"><span class="pre">ancilla_results.results[0].data</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ancilla_results</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">counts</span> <span class="o">=</span> <span class="n">conditional_counts</span>
</pre></div>
</div>
</div>
</div>
<p>If we compare the results <code class="docutils literal notranslate"><span class="pre">job_results.results.results[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">ancilla_results.results[0]</span></code> further, we have to do the following additional steps:</p>
<ul class="simple">
<li><p>Remove the bits from the classical register <span class="math notranslate nohighlight">\(c1\)</span> in <code class="docutils literal notranslate"><span class="pre">clbit_labels</span></code> and in <code class="docutils literal notranslate"><span class="pre">creg_sizes</span></code>.</p></li>
<li><p>Set the value of <code class="docutils literal notranslate"><span class="pre">memory_slots</span></code> to 2.</p></li>
</ul>
<p>In the following we will implement all steps explained above for all results in <code class="docutils literal notranslate"><span class="pre">ancilla_results</span></code>. We store the processed results in an object called <code class="docutils literal notranslate"><span class="pre">conditional_results</span></code>, which we create from the result object <code class="docutils literal notranslate"><span class="pre">ancilla_results</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">conditional_results</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">ancilla_results</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The implementation of the code is given below:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ancilla_results</span><span class="o">.</span><span class="n">results</span><span class="p">):</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">ancilla_results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
    <span class="n">conditional_counts</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="c1"># Keep counts of successful purifications</span>
    <span class="k">for</span> <span class="n">result</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">target_measurement</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">control_measurement</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">target_measurement</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;00&#39;</span><span class="p">,</span> <span class="s1">&#39;11&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">control_measurement</span> <span class="ow">in</span> <span class="n">conditional_counts</span><span class="p">:</span>
                <span class="n">conditional_counts</span><span class="p">[</span><span class="n">control_measurement</span><span class="p">]</span> <span class="o">=</span> <span class="n">conditional_counts</span><span class="p">[</span><span class="n">control_measurement</span><span class="p">]</span> <span class="o">+</span> <span class="n">count</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">conditional_counts</span><span class="p">[</span><span class="n">control_measurement</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
    
    <span class="c1"># Create new counts property from conditional_counts</span>
    <span class="n">conditional_results</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">counts</span> <span class="o">=</span> <span class="n">conditional_counts</span>
    
    <span class="c1"># Remove classical bits in ancilla register</span>
    <span class="n">old_labels</span> <span class="o">=</span> <span class="n">conditional_results</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">clbit_labels</span>
    <span class="n">conditional_results</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">clbit_labels</span> <span class="o">=</span> <span class="n">old_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="c1"># Remove ancilla register</span>
    <span class="n">old_sizes</span> <span class="o">=</span> <span class="n">conditional_results</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">creg_sizes</span>
    <span class="n">conditional_results</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">creg_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    
    <span class="c1"># Set memory_slots to 2</span>
    <span class="n">conditional_results</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">memory_slots</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<p>If we look at the new results <code class="docutils literal notranslate"><span class="pre">conditional_results</span></code>, we see that they now have the same form as the <code class="docutils literal notranslate"><span class="pre">job_results</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">conditional_results</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>(To the best knowledge of the author, the property <code class="docutils literal notranslate"><span class="pre">shots</span></code> does not need to be adjusted and the fitter will take care of a possibly smaller number of remaining events.)</p>
<p>At this point it is certainly helpful to summarize again which steps we have performed above and why. Remember: All the above steps were necessary because we cannot directly use the results of the ancilla tomography circuit execution to reconstruct the density matrix of the control qubits using the Qiskit functions for quantum state tomography. Therefore we took a small detour and carried out the following steps to perform conditional quantum state tomography:</p>
<ol class="arabic simple">
<li><p>Executed the ancilla tomography circuits <code class="docutils literal notranslate"><span class="pre">ancilla_tomography_circs</span></code>.</p></li>
<li><p>Edited the results of this execution so that all failed purifications were discarded.</p></li>
<li><p>Further edited the results to obtain the object <code class="docutils literal notranslate"><span class="pre">conditional_results</span></code>, which has the same structure as a result coming from the execution of the tomography circuits <code class="docutils literal notranslate"><span class="pre">tomography_circs</span></code>.</p></li>
</ol>
<p>Now we are ready to use the Qiskit features to reconstruct the density matrix of the control qubits, only considering the cases of successful purification.</p>
<p>Again with the class <code class="docutils literal notranslate"><span class="pre">StateTomographyFitter</span></code> we reconstruct the density matrix with the method <code class="docutils literal notranslate"><span class="pre">fit</span></code>, but this time we provide the result object <code class="docutils literal notranslate"><span class="pre">conditional_results</span></code> instead of <code class="docutils literal notranslate"><span class="pre">job_results</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">conditional_rho_fit</span> <span class="o">=</span> <span class="n">StateTomographyFitter</span><span class="p">(</span><span class="n">conditional_results</span><span class="p">,</span> <span class="n">tomography_circs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>The state <code class="docutils literal notranslate"><span class="pre">conditional_rho_fit</span></code> is now the reconstructed state of the control qubits, if only cases of successful purification are considered:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_state_city</span><span class="p">(</span><span class="n">conditional_rho_fit</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The state <code class="docutils literal notranslate"><span class="pre">conditional_rho_fit</span></code> depends on the bilateral rotation contained in the twirl circuit <code class="docutils literal notranslate"><span class="pre">twirl_circ</span></code>, since Alice and Bob randomly choose which bilateral rotation is performed at the beginning.</p>
<p>Remember that the reason for this was that the BBPSSW protocol works on Werner states <span class="math notranslate nohighlight">\(W_F\)</span> and these are arithmetic averages of bilaterally-rotated density matrices,</p>
<div class="math notranslate nohighlight">
\[
W_F = \frac{1}{12} \sum_{i=1}^{12} U_i \rho_\textrm{S} U_i^\dagger .
\]</div>
<p>In practice, Alice and Bob choose a random element from the set <span class="math notranslate nohighlight">\(\{U_i\}\)</span> of bilateral operations and apply it to a source state <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span>. If Alice and Bob apply this random operation to a number <span class="math notranslate nohighlight">\(N\)</span> of source states <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span>, then the average state for large <span class="math notranslate nohighlight">\(N\)</span> is approximately a Werner state,</p>
<div class="math notranslate nohighlight">
\[
W_F \approx \frac{1}{N} \sum_{n=1}^N \rho_n,
\]</div>
<p>where <span class="math notranslate nohighlight">\(\rho_n\)</span> denotes the state after the bilateral rotation.</p>
<p>The interesting figure is therefore not a single control-qubit state <code class="docutils literal notranslate"><span class="pre">conditional_rho_fit</span></code> after execution of the BBPSSW protocol, but rather an average of these states over many execution runs <span class="math notranslate nohighlight">\(N\)</span> with randomly selected operations <span class="math notranslate nohighlight">\(U_i\)</span> in the twirl circuit <code class="docutils literal notranslate"><span class="pre">twirl_circ</span></code>. Therefore, in the following section we examine a large number of sources <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span> and calculate the average result of the BBPSSW protocol to demonstrate its working principle.</p>
</section>
<section id="ensemble-average">
<h3>3.2 Ensemble Average<a class="headerlink" href="#ensemble-average" title="Permalink to this heading">¶</a></h3>
<section id="definition-of-auxiliary-functions">
<h4>3.2.1 Definition of Auxiliary Functions<a class="headerlink" href="#definition-of-auxiliary-functions" title="Permalink to this heading">¶</a></h4>
<p>To make the following section easier to read, we define some helpful functions to implement the tomography for the case of an ensemble. Essentially, these functions summarize the steps from the previous section in a compact way.</p>
<p>First we define a function <code class="docutils literal notranslate"><span class="pre">experiment_circuit</span></code>, which has the index of the bilateral rotation as input parameter and returns a corresponding experiment circuit for the whole purification procedure:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">experiment_circuit</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns experiment circuit corresponding to an index.</span>
<span class="sd">    </span>
<span class="sd">    Keyword arguments:</span>
<span class="sd">    index -- integer between 0 and 11</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    experiment_circ -- quantum circuit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="mi">11</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Index for bilateral rotation exceeds range of possible values.&quot;</span><span class="p">)</span>
        
    <span class="c1"># Create twirl circuit from the bilateral rotations</span>
    <span class="n">twirl_circ</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">qr</span><span class="p">)</span>
    <span class="n">bilateral_rotation</span><span class="p">(</span><span class="n">twirl_circ</span><span class="p">,</span> <span class="n">control_qubits</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">bilateral_rotation</span><span class="p">(</span><span class="n">twirl_circ</span><span class="p">,</span> <span class="n">target_qubits</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    
    <span class="n">experiment_circ</span> <span class="o">=</span> <span class="n">source_circ</span> <span class="o">+</span> <span class="n">twirl_circ</span> <span class="o">+</span> <span class="n">purification_circ</span>
    
    <span class="k">return</span> <span class="n">experiment_circ</span>
</pre></div>
</div>
</div>
</div>
<p>Next we define a function <code class="docutils literal notranslate"><span class="pre">ancilla_circuit</span></code> which takes a quantum circuit and returns a corresponding ancilla circuit which is a copy of the original circuit and in which certain qubits are measured:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">ancilla_circuit</span><span class="p">(</span><span class="n">quantum_circuit</span><span class="p">,</span> <span class="n">qubits</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return an ancilla circuit that includes additional measurements.</span>
<span class="sd">    </span>
<span class="sd">    Keyword arguments:</span>
<span class="sd">    quantum_circuit -- single quantum circuit</span>
<span class="sd">    qubits -- list of qubits to be measured</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    ancilla_circ -- ancilla quantum circuit including measurement of qubits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Copy original circuit</span>
    <span class="n">ancilla_circ</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">quantum_circuit</span><span class="p">)</span>
    
    <span class="c1"># Add classical register</span>
    <span class="n">cr</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">))</span>
    <span class="n">ancilla_circ</span><span class="o">.</span><span class="n">add_register</span><span class="p">(</span><span class="n">cr</span><span class="p">)</span>
    
    <span class="c1"># Measure qubits</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">qubits</span><span class="p">):</span>
        <span class="n">ancilla_circ</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="n">cr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">ancilla_circ</span>
</pre></div>
</div>
</div>
</div>
<p>To perform conditional quantum state tomography, we have seen that the ancilla tomography circuits must be executed, and we need the tomography circuits for the original experiment circuit along with the execution results to fit the state of the control qubits. For this purpose we define a function <code class="docutils literal notranslate"><span class="pre">conditional_tomography_circuits</span></code>, which returns both sets of tomography circuits:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">conditional_tomography_circuits</span><span class="p">(</span><span class="n">quantum_circuit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns all tomography circuits for conditional quantum state tomography. </span>
<span class="sd">    </span>
<span class="sd">    Keyword arguments:</span>
<span class="sd">    quantum_circuit -- single quantum circuit</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    tomography_circs -- tomography circuits for quantum circuit</span>
<span class="sd">    ancilla_tomography_circs -- ancilla tomography circuits with additional measurements on target qubits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create ancilla circuit</span>
    <span class="n">ancilla_circ</span> <span class="o">=</span> <span class="n">ancilla_circuit</span><span class="p">(</span><span class="n">quantum_circuit</span><span class="p">,</span> <span class="n">target_qubits</span><span class="p">)</span>
    
    <span class="c1"># Create tomography circuits</span>
    <span class="n">tomography_circs</span> <span class="o">=</span> <span class="n">state_tomography_circuits</span><span class="p">(</span><span class="n">quantum_circuit</span><span class="p">,</span> <span class="n">control_qubits</span><span class="p">)</span>
    <span class="n">ancilla_tomography_circs</span> <span class="o">=</span> <span class="n">state_tomography_circuits</span><span class="p">(</span><span class="n">ancilla_circ</span><span class="p">,</span> <span class="n">control_qubits</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">tomography_circs</span><span class="p">,</span> <span class="n">ancilla_tomography_circs</span>
</pre></div>
</div>
</div>
</div>
<p>We have also seen how to edit the results of the execution of ancilla tomography circuits so that all shots that do not meet the condition for successful purification are discarded. We summarize those steps in the function <code class="docutils literal notranslate"><span class="pre">purification_shots</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">purification_shots</span><span class="p">(</span><span class="n">job_results</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Keep counts for successful purifications and return corresponding result.</span>
<span class="sd">    </span>
<span class="sd">    Keyword arguments:</span>
<span class="sd">    job_results -- execution results</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    conditional_results -- results without unsuccessful shots</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Copy original results</span>
    <span class="n">conditional_results</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">job_results</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">job_results</span><span class="o">.</span><span class="n">results</span><span class="p">):</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">job_results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
        <span class="n">conditional_counts</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># Keep counts of successful purifications</span>
        <span class="k">for</span> <span class="n">result</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">target_measurement</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">control_measurement</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">target_measurement</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;00&#39;</span><span class="p">,</span> <span class="s1">&#39;11&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">control_measurement</span> <span class="ow">in</span> <span class="n">conditional_counts</span><span class="p">:</span>
                    <span class="n">conditional_counts</span><span class="p">[</span><span class="n">control_measurement</span><span class="p">]</span> <span class="o">=</span> <span class="n">conditional_counts</span><span class="p">[</span><span class="n">control_measurement</span><span class="p">]</span> <span class="o">+</span> <span class="n">count</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">conditional_counts</span><span class="p">[</span><span class="n">control_measurement</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
        
        <span class="c1"># Adapt the properties of conditional_results accordingly</span>
        <span class="n">conditional_results</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">counts</span> <span class="o">=</span> <span class="n">conditional_counts</span>
        <span class="n">conditional_results</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">clbit_labels</span> <span class="o">=</span> <span class="n">conditional_results</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">clbit_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">conditional_results</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">creg_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">conditional_results</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">creg_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">conditional_results</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">memory_slots</span> <span class="o">=</span> <span class="mi">2</span>
            
    <span class="k">return</span> <span class="n">conditional_results</span>
</pre></div>
</div>
</div>
</div>
<p>In order to reconstruct a density matrix from tomography results, we have seen that an instance of the class <code class="docutils literal notranslate"><span class="pre">StateTomographyFitter</span></code> must be initiated from the tomography circuits and the corresponding execution results. In the following steps of the tutorial it is therefore helpful to save the tomography circuits and the corresponding execution job in some way and we choose a Python dictionary for it. To easily create a dictionary of the desired structure, we define the function <code class="docutils literal notranslate"><span class="pre">job_dictionary</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">job_dictionary</span><span class="p">(</span><span class="n">circuits</span><span class="p">,</span> <span class="n">job</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns dictionary.</span>
<span class="sd">    </span>
<span class="sd">    Keyword arguments:</span>
<span class="sd">    circuits -- list of quantum circuits</span>
<span class="sd">    job -- execution job, should correspond to execution of keyword argument &#39;circuits&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">job_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">job_dict</span><span class="p">[</span><span class="s2">&quot;circuits&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">circuits</span>
    <span class="n">job_dict</span><span class="p">[</span><span class="s2">&quot;job&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">job</span>
    
    <span class="k">return</span> <span class="n">job_dict</span>
</pre></div>
</div>
</div>
</div>
<p>The reason why we do not save the execution results directly becomes apparent at a later point. In short, running a job on a real device can take time because other users’ jobs can also be in the queue. By saving the job object itself, we can regularly check its state until its execution is complete.</p>
<p>When a job has been executed, a density matrix can be reconstructed from a dictionary returned by the above function using the function <code class="docutils literal notranslate"><span class="pre">rho_from_dict</span></code> defined below. An additional input argument <code class="docutils literal notranslate"><span class="pre">cond_tomo</span></code> also allows to specify whether conditional tomography should be performed (i.e. all unsuccessful purification shots are discarded from the tomography results) or not:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rho_from_dict</span><span class="p">(</span><span class="n">job_dict</span><span class="p">,</span> <span class="n">cond_tomo</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns a reconstructed density matrix using quantum state tomography.</span>
<span class="sd">    </span>
<span class="sd">    Keyword arguments:</span>
<span class="sd">    job_dict -- dictionary containing execution job and corresponding quantum circuits</span>
<span class="sd">    cond_tomo -- boolean that indicates whether conditional tomography is being performed (cond_tomo=True)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    rho_fit -- reconstructed density matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cond_tomo</span><span class="p">:</span>
        <span class="c1"># Conditional quantum state tomography</span>
        <span class="n">conditional_results</span> <span class="o">=</span> <span class="n">purification_shots</span><span class="p">(</span><span class="n">job_dict</span><span class="p">[</span><span class="s2">&quot;job&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>
        <span class="n">rho_fit</span> <span class="o">=</span> <span class="n">StateTomographyFitter</span><span class="p">(</span><span class="n">conditional_results</span><span class="p">,</span> <span class="n">job_dict</span><span class="p">[</span><span class="s2">&quot;circuits&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Regular quantum state tomography</span>
        <span class="n">rho_fit</span> <span class="o">=</span> <span class="n">StateTomographyFitter</span><span class="p">(</span><span class="n">job_dict</span><span class="p">[</span><span class="s2">&quot;job&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">result</span><span class="p">(),</span> <span class="n">job_dict</span><span class="p">[</span><span class="s2">&quot;circuits&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">rho_fit</span>
</pre></div>
</div>
</div>
</div>
<p>We summarize some of the previous functions and the execution of the tomography circuits in the function <code class="docutils literal notranslate"><span class="pre">execute_purification</span></code>, which returns exactly the dictionary containing the execution job and the corresponding tomography circuits:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">execute_purification</span><span class="p">(</span><span class="n">F_in</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">shots</span><span class="p">,</span> <span class="n">noise_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">coupling_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basis_gates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">remove_barriers</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Execute entire BBPSSW protocol on a target backend.</span>
<span class="sd">    </span>
<span class="sd">    Keyword arguments:</span>
<span class="sd">    F_in            -- input fidelity</span>
<span class="sd">    index           -- integer between 0 and 11, defines bilateral rotation</span>
<span class="sd">    backend         -- backend to execute circuits</span>
<span class="sd">    shots           -- number of shots per execution</span>
<span class="sd">    noise_model     -- noise model for simulation of real device (required for noisy simulation)</span>
<span class="sd">    coupling_map    -- list that specifies the qubit couplings (required for noisy simulation)</span>
<span class="sd">    basis_gates     -- set of basis gates on real device (required for noisy simulation)</span>
<span class="sd">    remove_barriers -- bool; if True, removes all barriers from the circuits</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    job_dict -- dictionary containing execution job and tomography circuits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create experiment circuit and corresponding tomography circuits</span>
    <span class="n">experiment_circ</span> <span class="o">=</span> <span class="n">experiment_circuit</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="n">tomography_circs</span><span class="p">,</span> <span class="n">ancilla_tomography_circs</span> <span class="o">=</span> <span class="n">conditional_tomography_circuits</span><span class="p">(</span><span class="n">experiment_circ</span><span class="p">)</span>
    
    <span class="c1"># Remove barriers</span>
    <span class="k">if</span> <span class="n">remove_barriers</span><span class="p">:</span>
        <span class="n">ancilla_tomography_circs</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">_remove_barriers</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span> <span class="k">for</span> <span class="n">circ</span> <span class="ow">in</span> <span class="n">ancilla_tomography_circs</span><span class="p">]</span>
    
    <span class="c1"># Execute tomography circuits on simulator (w/ noise parameters) or real device (w/o noise parameters)</span>
    <span class="k">if</span> <span class="n">backend</span><span class="o">.</span><span class="n">configuration</span><span class="p">()</span><span class="o">.</span><span class="n">simulator</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">ancilla_tomography_circs</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">,</span>
                      <span class="n">noise_model</span><span class="o">=</span><span class="n">noise_model</span><span class="p">,</span> <span class="n">coupling_map</span><span class="o">=</span><span class="n">coupling_map</span><span class="p">,</span> <span class="n">basis_gates</span><span class="o">=</span><span class="n">basis_gates</span><span class="p">,</span>
                      <span class="n">parameter_binds</span><span class="o">=</span><span class="p">[{</span><span class="n">theta</span><span class="p">:</span> <span class="n">F_to_theta</span><span class="p">(</span><span class="n">F_in</span><span class="p">)}])</span>
    <span class="k">else</span><span class="p">:</span>   
        <span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">ancilla_tomography_circs</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">,</span>
                      <span class="n">parameter_binds</span><span class="o">=</span><span class="p">[{</span><span class="n">theta</span><span class="p">:</span> <span class="n">F_to_theta</span><span class="p">(</span><span class="n">F_in</span><span class="p">)}])</span>
    
    <span class="c1"># Construct job dictionary</span>
    <span class="n">job_dict</span> <span class="o">=</span> <span class="n">job_dictionary</span><span class="p">(</span><span class="n">tomography_circs</span><span class="p">,</span> <span class="n">job</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">job_dict</span>
</pre></div>
</div>
</div>
</div>
<p>In the function <code class="docutils literal notranslate"><span class="pre">execute_purification</span></code> we already consider the case of a simulation with noise, which will be dealt with in the next part (<strong>Part IV: Noise in the simulation model</strong>). To perform such a simulation, we need additional objects (<code class="docutils literal notranslate"><span class="pre">noise_model</span></code>, <code class="docutils literal notranslate"><span class="pre">coupling_map</span></code> and <code class="docutils literal notranslate"><span class="pre">basis_gates</span></code>), which are already included in the above function. We will explain what these objects are when required in the tutorial.</p>
<p>In addition, we have already prepared the case that the circuits will run on a real IBM Q device. If the desired backend is a real device, i.e. the property <code class="docutils literal notranslate"><span class="pre">backend.configuration().simulator</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, we do not pass the parameters for a noisy simulation (<code class="docutils literal notranslate"><span class="pre">noise_model</span></code>, <code class="docutils literal notranslate"><span class="pre">coupling_map</span></code> and <code class="docutils literal notranslate"><span class="pre">basis_gates</span></code>) to the Qiskit function <code class="docutils literal notranslate"><span class="pre">execute</span></code>.</p>
<p>With the auxiliary functions defined above, we essentially perform the following two steps to purify entanglement (whether as a unitary or noisy simulation, or on a real device):</p>
<ol class="arabic simple">
<li><p>Create and execute quantum circuits using <code class="docutils literal notranslate"><span class="pre">execute_purification</span></code>.</p></li>
<li><p>Reconstruct a density matrix using <code class="docutils literal notranslate"><span class="pre">rho_from_dict</span></code>.</p></li>
</ol>
</section>
<section id="simulation">
<h4>3.2.2 Simulation<a class="headerlink" href="#simulation" title="Permalink to this heading">¶</a></h4>
<p>In Section <strong>3.1 Single Quantum System</strong> we have executed the BBPSSW protocol for a single system consisting of two qubit pairs in the state <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span>. In this case, the result of the protocol, i.e. the state of the control qubits, depends on the randomly selected bilateral rotation.</p>
<p>However, we are interested in the state <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span>, which is the average state of the control qubits after applying the BBPSSW protocol. To get this state <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span> in our simulation, we calculate the average</p>
<div class="math notranslate nohighlight">
\[
\rho'_{F'} \approx \frac{1}{N} \sum_{n=1}^{N} \rho_n',
\]</div>
<p>where <span class="math notranslate nohighlight">\(\rho_n'\)</span> denotes the control-qubit state after the application of the BBPSSW protocol to a single system in execution run <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(N\)</span> is the total number of execution runs. (This is equivalent to applying the protocol to <span class="math notranslate nohighlight">\(N\)</span> quantum systems and averaging across all systems.) Here, each execution run varies in the random selection of the bilateral rotation. The number of <span class="math notranslate nohighlight">\(N\)</span> runs must therefore be large enough to make the result independent of the selected rotations. (We would get the exact state <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span> in the limit <span class="math notranslate nohighlight">\(N \rightarrow \infty\)</span>.)</p>
<p>With the functions defined above, the implementation in Qiskit for <span class="math notranslate nohighlight">\(N=100\)</span> runs and an initial fidlity of <span class="math notranslate nohighlight">\(F = 0.75\)</span> looks like this to approximately get the average state <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">F</span> <span class="o">=</span> <span class="mf">0.75</span>

<span class="c1"># Empty list for storing the reconstructed density matrices of all runs</span>
<span class="n">fitted_states</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># Perform runs</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="c1"># Create experiment circuit and corresponding tomography circuits</span>
    <span class="n">random_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
    <span class="n">experiment_circ</span> <span class="o">=</span> <span class="n">experiment_circuit</span><span class="p">(</span><span class="n">random_idx</span><span class="p">)</span>
    <span class="n">tomography_circs</span><span class="p">,</span> <span class="n">ancilla_tomography_circs</span> <span class="o">=</span> <span class="n">conditional_tomography_circuits</span><span class="p">(</span><span class="n">experiment_circ</span><span class="p">)</span>
    
    <span class="c1"># Execute ancilla tomography circuits on simulator</span>
    <span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">ancilla_tomography_circs</span><span class="p">,</span> <span class="n">backend_QASM</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">parameter_binds</span><span class="o">=</span><span class="p">[{</span><span class="n">theta</span><span class="p">:</span> <span class="n">F_to_theta</span><span class="p">(</span><span class="n">F</span><span class="p">)}])</span>
    <span class="n">job_results</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
    
    <span class="c1"># Keep counts of successful purifications</span>
    <span class="n">conditional_results</span> <span class="o">=</span> <span class="n">purification_shots</span><span class="p">(</span><span class="n">job_results</span><span class="p">)</span>

    <span class="c1"># Reconstruct density matrix of control qubits</span>
    <span class="n">rho_fit</span> <span class="o">=</span> <span class="n">StateTomographyFitter</span><span class="p">(</span><span class="n">conditional_results</span><span class="p">,</span> <span class="n">tomography_circs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
    
    <span class="c1"># Add reconstructed density matrix to list</span>
    <span class="n">fitted_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rho_fit</span><span class="p">)</span>
    
<span class="c1"># Calculate average density matrix</span>
<span class="n">rho_average</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fitted_states</span><span class="p">)</span><span class="o">/</span><span class="n">N</span>
</pre></div>
</div>
</div>
</div>
<p>Also here we can depict the average state <code class="docutils literal notranslate"><span class="pre">rho_average</span></code>, e.g. by representing its real and imaginary parts:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_state_city</span><span class="p">(</span><span class="n">rho_average</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now we want to see how well our simulation worked and calculate the fidelity <span class="math notranslate nohighlight">\(F'\)</span>,</p>
<div class="math notranslate nohighlight">
\[
F' = \langle \Phi^+ | \rho'_{F'} | \Phi^+ \rangle.
\]</div>
<p>We can use the Qiskit function <code class="docutils literal notranslate"><span class="pre">state_fidelity</span></code> which returns the fidelity between two quantum states given as input arguments.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.quantum_info</span> <span class="kn">import</span> <span class="n">state_fidelity</span>
</pre></div>
</div>
</div>
</div>
<p>The output fidelity <span class="math notranslate nohighlight">\(F'\)</span> can thus be obtained from the state <code class="docutils literal notranslate"><span class="pre">rho_average</span></code> by</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">simulated_output_fidelity</span> <span class="o">=</span> <span class="n">state_fidelity</span><span class="p">(</span><span class="n">rho_average</span><span class="p">,</span> <span class="n">phi_plus</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We compare the fidelity <code class="docutils literal notranslate"><span class="pre">simulated_output_fidelity</span></code> coming from our simulation with the theoretical output value of the BBPSSW protocol:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input fidelity =&#39;</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Theoretical output fidelity = </span><span class="si">{:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output_fidelity</span><span class="p">(</span><span class="n">F</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Simulated output fidelity = </span><span class="si">{:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">simulated_output_fidelity</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>The output fidelity of the simulation is close to the theoretically expected one, which can also be seen from plotting the result:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">F_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">F_in</span><span class="p">,</span> <span class="n">F_in</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;$F&#39; = F$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">F_in</span><span class="p">,</span> <span class="n">output_fidelity</span><span class="p">(</span><span class="n">F_in</span><span class="p">),</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;$F&#39;(F)$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">simulated_output_fidelity</span><span class="p">,</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;QASM simulator&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Input Fidelity $F$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Output Fidelity $F&#39;$&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p>After seeing that our Qiskit implementation of the BBPSSW protocol works, we will perform entanglement purification for different input fidelities <span class="math notranslate nohighlight">\(F\)</span> in the range between 0.5 and 1. We define these fidelities in a numpy array <code class="docutils literal notranslate"><span class="pre">input_fidelities</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">input_fidelities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We simulate the BBPSSW protocol for all fidelities using the previously defined function <code class="docutils literal notranslate"><span class="pre">execute_purification</span></code>, which further shortens the implementation. We also reconstruct the density matrix in each run with the previously defined function <code class="docutils literal notranslate"><span class="pre">rho_from_dict</span></code>, in which we set the input argument to <code class="docutils literal notranslate"><span class="pre">cond_tomo=True</span></code>, since we want to perform conditional quantum state tomography here. All calculated output fidelities are then stored in a list called <code class="docutils literal notranslate"><span class="pre">output_fidelities</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>

<span class="c1"># Empty list for storing all output fidelities</span>
<span class="n">output_fidelities</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">fidelity</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">input_fidelities</span><span class="p">):</span>
    <span class="n">fitted_states</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="c1"># Create circuits, execute circuits on simulator, reconstruct density matrix of control qubits</span>
        <span class="n">random_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">job_dict</span> <span class="o">=</span> <span class="n">execute_purification</span><span class="p">(</span><span class="n">fidelity</span><span class="p">,</span> <span class="n">random_idx</span><span class="p">,</span> <span class="n">backend_QASM</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">remove_barriers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">rho_fit</span> <span class="o">=</span> <span class="n">rho_from_dict</span><span class="p">(</span><span class="n">job_dict</span><span class="p">,</span> <span class="n">cond_tomo</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">fitted_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rho_fit</span><span class="p">)</span>
        
    <span class="c1"># Calculate average density matrix</span>
    <span class="n">rho_average</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fitted_states</span><span class="p">)</span><span class="o">/</span><span class="n">N</span>
    
    <span class="c1"># Calculate fidelity towards Phi^+ and add fidelity to list</span>
    <span class="n">output_fidelities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">state_fidelity</span><span class="p">(</span><span class="n">rho_average</span><span class="p">,</span> <span class="n">phi_plus</span><span class="p">))</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_fidelities</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; simulation runs done.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>If we now compare the purified fidelities with the input fidelities, we can see a good agreement between the simulated results and the theoretical expectation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">F_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">F_in</span><span class="p">,</span> <span class="n">F_in</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;$F&#39; = F$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">F_in</span><span class="p">,</span> <span class="n">output_fidelity</span><span class="p">(</span><span class="n">F_in</span><span class="p">),</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;$F&#39;(F)$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">input_fidelities</span><span class="p">,</span> <span class="n">output_fidelities</span><span class="p">,</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;QASM simulator&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Input Fidelity $F$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Output Fidelity $F&#39;$&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p>From the simulation, in which we have not included any error sources, we see that the implementation of the BBPSSW protocol for entanglement purification works.</p>
<p>The ultimate goal is to run the BBPSSW protocol on a real IBM Q device. But before we do this, we will include noise in our simulation model to consider imperfections in the quantum computation and see how much the effects of noise affect output fidelity.</p>
</section>
</section>
</section>
<section id="part-iv-including-noise-in-the-simulation-model">
<h2>Part IV: Including Noise in the Simulation Model<a class="headerlink" href="#part-iv-including-noise-in-the-simulation-model" title="Permalink to this heading">¶</a></h2>
<hr class="docutils" />
<p>In this part we will simulate the quantum circuit for the BBPSSW protocol using a model that includes noise. Noise in this context means errors that occur on real devices such as single-qubit gate errors, two-qubit gate errors and single-qubit readout errors. A simple noise model can e.g. be created using error parameters directly provided through the calibration data of the real devices. This is going to be the way we construct the noise model here.</p>
<p>In the following, we show how to choose a real IBM Q device as backend and read out the necessary data using an IBM Q account. Afterwards we explain how to generate a noise model using integrated Qiskit functions and run a noisy simulation using the QASM simulator.</p>
<section id="ibm-q-account">
<h3>4.1 IBM Q Account<a class="headerlink" href="#ibm-q-account" title="Permalink to this heading">¶</a></h3>
<p>To use the IBM Q Experience, we first have to import the necessary library:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">IBMQ</span>
</pre></div>
</div>
</div>
</div>
<p>If you have previously saved your IBM Q credentials locally, you can load your IBM Q account using the <code class="docutils literal notranslate"><span class="pre">load_account</span></code> function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">IBMQ</span><span class="o">.</span><span class="n">load_account</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>For more information on managing your IBM Q account, please refer to the corresponding Qiskit notebook [8].</p>
<p>The real backends are provided by so-called providers. In the case of the authors, we only have access to one provider, namely the one that grants access to the public IBM Q devices:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">IBMQ</span><span class="o">.</span><span class="n">providers</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We can access this provider using the method <code class="docutils literal notranslate"><span class="pre">get_provider</span></code> by specifying <code class="docutils literal notranslate"><span class="pre">hub='ibm-q'</span></code> as input argument:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">my_provider</span> <span class="o">=</span> <span class="n">IBMQ</span><span class="o">.</span><span class="n">get_provider</span><span class="p">(</span><span class="n">hub</span><span class="o">=</span><span class="s1">&#39;ibm-q&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>You can use the provider instance <code class="docutils literal notranslate"><span class="pre">my_provider</span></code> to access a list of available or accessible devices using the method <code class="docutils literal notranslate"><span class="pre">backends</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">my_provider</span><span class="o">.</span><span class="n">backends</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>A real IBM Q device can now be selected as backend using the method <code class="docutils literal notranslate"><span class="pre">get_backend</span></code> and for this tutorial we use the device <code class="docutils literal notranslate"><span class="pre">ibmqx2</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">backend_IBMQ</span> <span class="o">=</span> <span class="n">my_provider</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;ibmqx2&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="creation-of-noise-model-in-qiskit">
<h3>4.2 Creation of Noise Model in Qiskit<a class="headerlink" href="#creation-of-noise-model-in-qiskit" title="Permalink to this heading">¶</a></h3>
<p>It has already been mentioned that Qiskit provides integrated functions to construct simple noise models from device parameters, such as</p>
<ul class="simple">
<li><p>single-qubit gate errors,</p></li>
<li><p>two-qubit gate errors, and</p></li>
<li><p>single-qubit readout errors.</p></li>
</ul>
<p>A noise model can be created by providing values for the above parameters or by reading them directly from the calibration data of a real IBM Q device. In order to use this Qiskit feature, we must first import the class <code class="docutils literal notranslate"><span class="pre">NoiseModel</span></code> from the Qiskit element Aer:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.providers.aer.noise</span> <span class="kn">import</span> <span class="n">NoiseModel</span>
</pre></div>
</div>
</div>
</div>
<p>The noise parameters of a real device listed above are stored in the backend properties, and a noise model can be directly created from the real backend using the method <code class="docutils literal notranslate"><span class="pre">from_backend</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">noise_model</span> <span class="o">=</span> <span class="n">NoiseModel</span><span class="o">.</span><span class="n">from_backend</span><span class="p">(</span><span class="n">backend_IBMQ</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The object <code class="docutils literal notranslate"><span class="pre">noise_model</span></code> is an instance of the <code class="docutils literal notranslate"><span class="pre">NoiseModel</span></code> class and can be used in the QASM simulator to perform noisy simulations.</p>
<p>Since not all qubits on a real device are directly coupled, it is very likely that additional gates will have to be introduced if a circuit is run on a real device. These gates swap quantum states between qubits so that multi-qubit gates can be executed. To include such swap processes in the simulation, the function <code class="docutils literal notranslate"><span class="pre">execute</span></code> takes an additional input parameter <code class="docutils literal notranslate"><span class="pre">coupling_map</span></code>, in which the qubit couplings can be provided.</p>
<p>We can also read the qubit couplings directly from the device itself using the property <code class="docutils literal notranslate"><span class="pre">coupling_map</span></code> of a backend configuration:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">coupling_map</span> <span class="o">=</span> <span class="n">backend_IBMQ</span><span class="o">.</span><span class="n">configuration</span><span class="p">()</span><span class="o">.</span><span class="n">coupling_map</span>
</pre></div>
</div>
</div>
</div>
<p>In addition, a real device can only execute a finite set of quantum operations directly, and all other gates are constructed from that set. The construction of generic quantum gates from these basis gates and the generation of necessary swap operations based on the qubit coupling structure are part of the compilation process of a quantum circuit.</p>
<p>When we run a noisy simulation, we want to run exactly the same circuits that would run on the real device. We can pass the set of basis gates to the function <code class="docutils literal notranslate"><span class="pre">execute</span></code> to ensure that the simulated quantum circuits are assembled from the same basis gates available on the real device. The noise model <code class="docutils literal notranslate"><span class="pre">noise_model</span></code> is also defined with respect to the basis gates that are available on the device <code class="docutils literal notranslate"><span class="pre">ibmqx2</span></code>. Therefore the set of basis gates can e.g. be obtained from the property <code class="docutils literal notranslate"><span class="pre">basis_gates</span></code> of a noise model:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">basis_gates</span> <span class="o">=</span> <span class="n">noise_model</span><span class="o">.</span><span class="n">basis_gates</span>
</pre></div>
</div>
</div>
</div>
<p>With the <code class="docutils literal notranslate"><span class="pre">noise_model</span></code>, the <code class="docutils literal notranslate"><span class="pre">basis_gates</span></code> and the <code class="docutils literal notranslate"><span class="pre">coupling_map</span></code> we have all information at hand that is necessary for a (simple) noisy simulation of the quantum circuit for the BBPSSW protocol.</p>
</section>
<section id="simulation-including-noise">
<h3>4.3 Simulation Including Noise<a class="headerlink" href="#simulation-including-noise" title="Permalink to this heading">¶</a></h3>
<p>To perform a noisy simulation with the QASM simulator, we can again use the function <code class="docutils literal notranslate"><span class="pre">execute</span></code> and provide three additional input parameters, which are</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">noise_model</span></code>: An instance of the <code class="docutils literal notranslate"><span class="pre">NoiseModel</span></code> class.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">coupling_map</span></code>: A list that specifies the qubit couplings.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">basis_gates</span></code>: A set of basis gates.</p></li>
</ul>
<p>Our function <code class="docutils literal notranslate"><span class="pre">execute_purification</span></code> has already been defined in such a way that we simply specify the additional parameters <code class="docutils literal notranslate"><span class="pre">noise_model</span></code>, <code class="docutils literal notranslate"><span class="pre">basis_gates</span></code> and <code class="docutils literal notranslate"><span class="pre">coupling_map</span></code> as input arguments, which are then fed into the function <code class="docutils literal notranslate"><span class="pre">execute</span></code> to perform the noisy simulation from which we finally obtain the reconstructed density matrix of the control qubits <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span> .</p>
<p><strong>However, to determine the output fidelity as a function of the input fidelity taking noise into account, we need to perform an additional simulation.</strong> The reason for this is explained below.</p>
<p>Remember that the BBPSSW protocol works for Werner states <span class="math notranslate nohighlight">\(W_F\)</span>. The input fidelity <span class="math notranslate nohighlight">\(F\)</span> into the BBPSSW protocol is thus the fidelity of the Werner state <span class="math notranslate nohighlight">\(W_F\)</span>, which we created after the application of the twirl circuit <code class="docutils literal notranslate"><span class="pre">twirl_circ</span></code>. In the case of a noisy simulation, this fidelity <span class="math notranslate nohighlight">\(F\)</span> is most likely less than the fidelity of the source state <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span>, which we will now call <span class="math notranslate nohighlight">\(F_\textrm{S}\)</span>,</p>
<div class="math notranslate nohighlight">
\[
F_\textrm{S} = \langle \Psi^- | \rho_\textrm{S} | \Psi^- \rangle,
\]</div>
<p>due to errors in the preparation process of <span class="math notranslate nohighlight">\(W_F\)</span>. I.e. in general we expect</p>
<div class="math notranslate nohighlight">
\[
F_\textrm{S} \leq F,
\]</div>
<p>with equality only in the case of unitary time evolution without any sources of noise. The actual input fidelity <span class="math notranslate nohighlight">\(F\)</span> is thus the fidelity of the two-qubit state after the initialization circuit <code class="docutils literal notranslate"><span class="pre">source_circ</span></code> and the application of the twirl procedure in <code class="docutils literal notranslate"><span class="pre">twirl_circ</span></code>.</p>
<p>In order to compare the input fidelity <span class="math notranslate nohighlight">\(F\)</span> with the output fidelity <span class="math notranslate nohighlight">\(F'\)</span>, we therefore have to simulate the circuits <code class="docutils literal notranslate"><span class="pre">source_circ</span></code> and <code class="docutils literal notranslate"><span class="pre">twirl_circ</span></code> first to find the actual input state of the BBPSSW protocol. We must also check whether it is actually a Werner state of the form <span class="math notranslate nohighlight">\(W_F\)</span> and then calculate the actual input fidelity <span class="math notranslate nohighlight">\(F\)</span> from this state.</p>
<section id="initial-state-and-initial-fidelity">
<h4>4.3.1 Initial State and Initial Fidelity<a class="headerlink" href="#initial-state-and-initial-fidelity" title="Permalink to this heading">¶</a></h4>
<p>As we described above, the input fidelity <span class="math notranslate nohighlight">\(F\)</span> to the BBPSSW protocol is the fidelity of the state <span class="math notranslate nohighlight">\(W_F\)</span> towards the Bell state <span class="math notranslate nohighlight">\(|\Psi^-\rangle\)</span> obtained after the initialization circuit and twirl operation. (We still have to show that it is actually a Werner state, what we can do after the noisy simulation.)</p>
<p>In the following we will perform a noisy simulation of a quantum circuit consisting of the circuits <code class="docutils literal notranslate"><span class="pre">source_circ</span></code> and <code class="docutils literal notranslate"><span class="pre">twirl_circ</span></code>, and to reconstruct the state <span class="math notranslate nohighlight">\(W_F\)</span> we will perform quantum state tomography of the control qubits.</p>
<p>Here, too, we define some helpful functions that make the implementation easier to read and understand. First we define a function <code class="docutils literal notranslate"><span class="pre">initialization_circuit</span></code> (analogous to <code class="docutils literal notranslate"><span class="pre">experiment_circuit</span></code>, see <strong>Sec. 3.2.1</strong>), which takes the index of the bilateral rotation as input argument and returns a corresponding experimental circuit for the initialization process including the twirl:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">initialization_circuit</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns initialization circuit (source + twirl) corresponding to an index.</span>
<span class="sd">    </span>
<span class="sd">    Keyword arguments:</span>
<span class="sd">    index -- integer between 0 and 11</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    experiment_circ -- quantum circuit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="mi">11</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Index for bilateral rotation exceeds range of possible values.&quot;</span><span class="p">)</span>
    
    <span class="c1"># Create twirl circuit from the bilateral rotations</span>
    <span class="n">twirl_circ</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">qr</span><span class="p">)</span>
    <span class="n">bilateral_rotation</span><span class="p">(</span><span class="n">twirl_circ</span><span class="p">,</span> <span class="n">control_qubits</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">bilateral_rotation</span><span class="p">(</span><span class="n">twirl_circ</span><span class="p">,</span> <span class="n">target_qubits</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    
    <span class="n">experiment_circ</span> <span class="o">=</span> <span class="n">source_circ</span> <span class="o">+</span> <span class="n">twirl_circ</span>
    
    <span class="k">return</span> <span class="n">experiment_circ</span>
</pre></div>
</div>
</div>
</div>
<p>All steps to execute the initialization process are summarized in the function <code class="docutils literal notranslate"><span class="pre">execute_initialization</span></code> (analogous to <code class="docutils literal notranslate"><span class="pre">execute_purification</span></code>, see <strong>Sec. 3.2.1</strong>). This function creates the initialization circuit via the function <code class="docutils literal notranslate"><span class="pre">initialization</span> <span class="pre">circuit</span></code> from above, creates the corresponding tomography circuits with the Qiskit function <code class="docutils literal notranslate"><span class="pre">state_tomography_circuits</span></code> and executes the tomography circuits on the backend, which is specified as input parameter:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">execute_initialization</span><span class="p">(</span><span class="n">F_S</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">shots</span><span class="p">,</span> <span class="n">noise_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">coupling_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basis_gates</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Execute initialization procedure of BBPSSW protocol (simulation of source and twirl) on a target backend.</span>
<span class="sd">    </span>
<span class="sd">    Keyword arguments:</span>
<span class="sd">    F_S -- source fidelity</span>
<span class="sd">    index -- integer between 0 and 11, defines bilateral rotation</span>
<span class="sd">    backend -- backend to execute circuits</span>
<span class="sd">    shots -- number of shots per execution</span>
<span class="sd">    noise_model -- noise model for simulation of real device</span>
<span class="sd">    coupling_map -- list that specifies the qubit couplings</span>
<span class="sd">    basis_gates -- set of basis gates on real device</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    job_dict -- dictionary containing execution job and corrresponding quantum circuits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create experiment circuit and corresponding tomography circuits</span>
    <span class="n">experiment_circ</span> <span class="o">=</span> <span class="n">initialization_circuit</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="n">tomography_circs</span> <span class="o">=</span> <span class="n">state_tomography_circuits</span><span class="p">(</span><span class="n">experiment_circ</span><span class="p">,</span> <span class="n">control_qubits</span><span class="p">)</span>

    <span class="c1"># Execute tomography circuits on simulator (w/ noise parameters) or real device (w/o noise parameters)</span>
    <span class="k">if</span> <span class="n">backend</span><span class="o">.</span><span class="n">configuration</span><span class="p">()</span><span class="o">.</span><span class="n">simulator</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">tomography_circs</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">,</span>
                      <span class="n">noise_model</span><span class="o">=</span><span class="n">noise_model</span><span class="p">,</span> <span class="n">coupling_map</span><span class="o">=</span><span class="n">coupling_map</span><span class="p">,</span> <span class="n">basis_gates</span><span class="o">=</span><span class="n">basis_gates</span><span class="p">,</span>
                      <span class="n">parameter_binds</span><span class="o">=</span><span class="p">[{</span><span class="n">theta</span><span class="p">:</span> <span class="n">F_to_theta</span><span class="p">(</span><span class="n">F_S</span><span class="p">)}])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">tomography_circs</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">,</span>
                      <span class="n">parameter_binds</span><span class="o">=</span><span class="p">[{</span><span class="n">theta</span><span class="p">:</span> <span class="n">F_to_theta</span><span class="p">(</span><span class="n">F_S</span><span class="p">)}])</span>
    
    <span class="c1"># Construct job dictionary</span>
    <span class="n">job_dict</span> <span class="o">=</span> <span class="n">job_dictionary</span><span class="p">(</span><span class="n">tomography_circs</span><span class="p">,</span> <span class="n">job</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">job_dict</span>
</pre></div>
</div>
</div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">execute_initialization</span></code> also returns a job dictionary containing the execution job and the corresponding tomography circuits.</p>
<p>We define a list of source fidelities <span class="math notranslate nohighlight">\(F_\textrm{S}\)</span> as numpy array, for which we want to extract the resulting input fidelities <span class="math notranslate nohighlight">\(F\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">source_fidelities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In analogy to our simulation of the entire BBPSSW protocol in the absence of noise in <strong>Part III</strong> we calculate an average over <span class="math notranslate nohighlight">\(N=100\)</span> execution runs,</p>
<div class="math notranslate nohighlight">
\[
W_F \approx \frac{1}{N} \sum_{n=1}^N \rho_n,
\]</div>
<p>where <span class="math notranslate nohighlight">\(\rho_n\)</span> denotes the state after the random bilateral rotation in run <span class="math notranslate nohighlight">\(n\)</span> which can be obtained by executing the function <code class="docutils literal notranslate"><span class="pre">execute_initialization</span></code>. We store the reconstructed initial states and the corresponding input fidelities in the lists <code class="docutils literal notranslate"><span class="pre">simulated_initial_state</span></code> and <code class="docutils literal notranslate"><span class="pre">input_fidelities_noise</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>

<span class="c1"># Empty lists for storing all input states and input fidelities</span>
<span class="n">simulated_initial_states</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">input_fidelities_noise</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">fidelity</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">source_fidelities</span><span class="p">):</span>
    <span class="n">fitted_states</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="c1"># Create circuits, execute circuits on simulator, reconstruct density matrix of control qubits</span>
        <span class="n">random_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">job_dict</span> <span class="o">=</span> <span class="n">execute_initialization</span><span class="p">(</span><span class="n">fidelity</span><span class="p">,</span> <span class="n">random_idx</span><span class="p">,</span> <span class="n">backend_QASM</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span>
                                          <span class="n">noise_model</span><span class="o">=</span><span class="n">noise_model</span><span class="p">,</span> <span class="n">coupling_map</span><span class="o">=</span><span class="n">coupling_map</span><span class="p">,</span> <span class="n">basis_gates</span><span class="o">=</span><span class="n">basis_gates</span><span class="p">)</span>
        <span class="n">rho_fit</span> <span class="o">=</span> <span class="n">rho_from_dict</span><span class="p">(</span><span class="n">job_dict</span><span class="p">,</span> <span class="n">cond_tomo</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">fitted_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rho_fit</span><span class="p">)</span>
      
    <span class="c1"># Calculate average density matrix and add state to list</span>
    <span class="n">rho_average</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fitted_states</span><span class="p">)</span><span class="o">/</span><span class="n">N</span>
    <span class="n">simulated_initial_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rho_average</span><span class="p">)</span>
    
    <span class="c1"># Calculate fidelity towards Psi^- and add fidelity to list</span>
    <span class="n">input_fidelities_noise</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">state_fidelity</span><span class="p">(</span><span class="n">rho_average</span><span class="p">,</span> <span class="n">psi_minus</span><span class="p">))</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">source_fidelities</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; simulation runs done.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>If one compares this code with the corresponding code from <strong>Sec. 3.2.2</strong>, one notices on the one hand that we perform regular quantum state tomography here, i.e. we set <code class="docutils literal notranslate"><span class="pre">cond_tomo=False</span></code> in the function <code class="docutils literal notranslate"><span class="pre">rho_from_dict</span></code>. Conditional quantum state tomography is not required here because we want to find out what the state of the control qubits after the initialization process is without restriction. (We might as well reconstruct the state of the target qubits here or take an average of both.) On the other hand, we calculate the fidelity towards the Bell state <span class="math notranslate nohighlight">\(|\Psi^-\rangle\)</span> because we have not yet exchanged the <span class="math notranslate nohighlight">\(|\Psi^-\rangle\)</span> and <span class="math notranslate nohighlight">\(|\Phi^+\rangle\)</span> components (see step 2 of <strong>Sec. 1.</strong> and <strong>Sec. 2.3.4</strong>).</p>
<p>We can now plot the resulting input fidelities from the list <code class="docutils literal notranslate"><span class="pre">input_fidelities_noise</span></code> against the source fidelties <code class="docutils literal notranslate"><span class="pre">source_fidelities</span></code> to see the degree of noise degradation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">F_S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">F_S</span><span class="p">,</span> <span class="n">F_S</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;$F = F_\mathrm</span><span class="si">{S}</span><span class="s2">$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">source_fidelities</span><span class="p">,</span> <span class="n">input_fidelities_noise</span><span class="p">,</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;QASM simulator w/ noise&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Source Fidelity $F_\mathrm</span><span class="si">{S}</span><span class="s1">$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Input Fidelity $F$&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p>For all source fidelities <span class="math notranslate nohighlight">\(F_\mathrm{S}\)</span> we observe in the simulation results that the corresponding input fidelity <span class="math notranslate nohighlight">\(F\)</span> is less than <span class="math notranslate nohighlight">\(F_\mathrm{S}\)</span>.</p>
<p>Besides the magnitude of the initial fidelity, another crucial requirement for the functionality of the BBPSSW protocol is that the input states have Werner form <span class="math notranslate nohighlight">\(W_F\)</span>.</p>
</section>
<section id="send-it-after-class-3">
<h4>Send it after class 3<a class="headerlink" href="#send-it-after-class-3" title="Permalink to this heading">¶</a></h4>
<p>Write a function <code class="docutils literal notranslate"><span class="pre">state_fidelity_Werner</span></code> that returns the fidelity of a two-qubit state towards the Werner state <span class="math notranslate nohighlight">\(W_F\)</span>. The function should use the following input arguments:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">F_Werner</span></code>: Fidelity <span class="math notranslate nohighlight">\(F\)</span> of a Werner state <span class="math notranslate nohighlight">\(W_F\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">state</span></code>: A two-qubit quantum state.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">state_fidelity_Werner</span><span class="p">(</span><span class="n">F_Werner</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the fidelity of a two-qubit quantum state to a Werner state.</span>
<span class="sd">    </span>
<span class="sd">    Keyword arguments:</span>
<span class="sd">    F_Werner -- fidelity of Werner state towards Psi^-, range [0, 1]</span>
<span class="sd">    state -- two-qubit quantum state</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">F_Werner</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">F_Werner</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Fidelity must be between 0 and 1.&#39;</span><span class="p">)</span>
    
    <span class="c1">###</span>
    <span class="c1">### Enter your code below</span>
    <span class="c1">###</span>
    
    <span class="n">fidelity</span> <span class="o">=</span> <span class="n">state_fidelity</span><span class="p">(</span><span class="n">Werner_state</span><span class="p">(</span><span class="n">F_Werner</span><span class="p">),</span> <span class="n">state</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">fidelity</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="send-it-after-class-4">
<h4>Send it after class 4<a class="headerlink" href="#send-it-after-class-4" title="Permalink to this heading">¶</a></h4>
<p>We want to find out how well a Werner state can be initialized in the noisy simulation. For all states in <code class="docutils literal notranslate"><span class="pre">simulated_initial_states</span></code>, calculate the fidelity towards the corresponding Werner state using the function <code class="docutils literal notranslate"><span class="pre">state_fidelity_Werner</span></code>, which you defined above in exercise 5. Store the calculated fidelities in a list called <code class="docutils literal notranslate"><span class="pre">initial_fidelities_Werner</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">initial_fidelities_Werner</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1">###</span>
<span class="c1">### Enter your code below</span>
<span class="c1">###</span>
<span class="k">for</span> <span class="n">fidelity</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">input_fidelities_noise</span><span class="p">,</span> <span class="n">simulated_initial_states</span><span class="p">):</span>
    <span class="n">fidelity</span> <span class="o">=</span> <span class="n">state_fidelity_Werner</span><span class="p">(</span><span class="n">fidelity</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
    <span class="n">initial_fidelities_Werner</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fidelity</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>You can plot the fidelities <code class="docutils literal notranslate"><span class="pre">initial_fidelities_Werner</span></code> against the source fidelities <span class="math notranslate nohighlight">\(F_\mathrm{S}\)</span> and see that Werner states can be initialized with fidelities of about 99 % if the calculation of <code class="docutils literal notranslate"><span class="pre">initial_fidelities_Werner</span></code> is correct:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">F_S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">F_S</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">F_S</span><span class="p">)),</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;$Fidelity = 1$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">source_fidelities</span><span class="p">,</span> <span class="n">initial_fidelities_Werner</span><span class="p">,</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;QASM simulator w/ noise&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Source Fidelity $F_\mathrm</span><span class="si">{S}</span><span class="s1">$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Fidelity towards Werner state&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mf">0.95</span><span class="p">,</span> <span class="mf">1.001</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p>In summary, we have shown in this noisy simulation that after initialization by the quantum circuits <code class="docutils literal notranslate"><span class="pre">source_circ</span></code> and <code class="docutils literal notranslate"><span class="pre">twirl_circ</span></code> a Werner state <span class="math notranslate nohighlight">\(W_F\)</span> can be generated, but with a fidelity <span class="math notranslate nohighlight">\(F\)</span> that is less than the fidelity <span class="math notranslate nohighlight">\(F_\mathrm{S}\)</span> of the original source state.</p>
</section>
<section id="entanglement-purification-in-the-presence-of-noise">
<h4>4.3.2 Entanglement Purification in the Presence of Noise<a class="headerlink" href="#entanglement-purification-in-the-presence-of-noise" title="Permalink to this heading">¶</a></h4>
<p>In <strong>Sec. 3.2.1</strong> we have already defined the function <code class="docutils literal notranslate"><span class="pre">execute_purification</span></code>. To perform a noisy simulation of the BBPSSW protocol on the QASM simulator, we can simply pass the additional parameters <code class="docutils literal notranslate"><span class="pre">noise_model</span></code> and <code class="docutils literal notranslate"><span class="pre">coupling_map</span></code> to this function, which are then finally passed to the Qiskit function <code class="docutils literal notranslate"><span class="pre">execute</span></code>.</p>
<p>Again we calculate the average of <span class="math notranslate nohighlight">\(N=100\)</span> runs,</p>
<div class="math notranslate nohighlight">
\[
\rho'_{F'} \approx \frac{1}{N} \sum_{n=1}^{N} \rho_n',
\]</div>
<p>where <span class="math notranslate nohighlight">\(\rho_n'\)</span> now denotes the state of the control qubits after the application of the BBPSSW protocol in the execution run <span class="math notranslate nohighlight">\(n\)</span>, obtained by executing the function <code class="docutils literal notranslate"><span class="pre">execute_purification</span></code>. We perform this calculation for all source fidelities defined in <code class="docutils literal notranslate"><span class="pre">source_fidelities</span></code> and save the output fidelities in the list <code class="docutils literal notranslate"><span class="pre">output_fidelities_noise</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>

<span class="c1"># Empty list for storing all output fidelities</span>
<span class="n">output_fidelities_noise</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">fidelity</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">source_fidelities</span><span class="p">):</span>
    <span class="n">fitted_states</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="c1"># Create circuits, execute circuits on simulator, reconstruct density matrix of control qubits</span>
        <span class="n">random_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">job_dict</span> <span class="o">=</span> <span class="n">execute_purification</span><span class="p">(</span><span class="n">fidelity</span><span class="p">,</span> <span class="n">random_idx</span><span class="p">,</span> <span class="n">backend_QASM</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span>
                                        <span class="n">noise_model</span><span class="o">=</span><span class="n">noise_model</span><span class="p">,</span> <span class="n">coupling_map</span><span class="o">=</span><span class="n">coupling_map</span><span class="p">,</span> <span class="n">basis_gates</span><span class="o">=</span><span class="n">basis_gates</span><span class="p">)</span>
        <span class="n">rho_fit</span> <span class="o">=</span> <span class="n">rho_from_dict</span><span class="p">(</span><span class="n">job_dict</span><span class="p">,</span> <span class="n">cond_tomo</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">fitted_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rho_fit</span><span class="p">)</span>
        
    <span class="c1"># Calculate average density matrix</span>
    <span class="n">rho_average</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fitted_states</span><span class="p">)</span><span class="o">/</span><span class="n">N</span>
    
    <span class="c1"># Calculate fidelity towards Phi^+ and add fidelity to list</span>
    <span class="n">output_fidelities_noise</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">state_fidelity</span><span class="p">(</span><span class="n">rho_average</span><span class="p">,</span> <span class="n">phi_plus</span><span class="p">))</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">source_fidelities</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; simulation runs done.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Comparing this code with the corresponding code from <strong>Sec. 3.2.2</strong>, the only difference is that the arguments <code class="docutils literal notranslate"><span class="pre">noise_model</span></code> and <code class="docutils literal notranslate"><span class="pre">coupling_map</span></code> are passed to the function <code class="docutils literal notranslate"><span class="pre">execute_purification</span></code>.</p>
<p>Now let’s see how well the purification worked if we include realistic noise parameters in the simulation. To do this, the output fidelities <code class="docutils literal notranslate"><span class="pre">output_fidelities_noise</span></code> are plotted as a function of the input fidelities <code class="docutils literal notranslate"><span class="pre">input_fidelities_noise</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">F_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">F_in</span><span class="p">,</span> <span class="n">F_in</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;$F&#39; = F$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">F_in</span><span class="p">,</span> <span class="n">output_fidelity</span><span class="p">(</span><span class="n">F_in</span><span class="p">),</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;$F&#39;(F)$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">input_fidelities</span><span class="p">,</span> <span class="n">output_fidelities</span><span class="p">,</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;QASM simulator&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">input_fidelities_noise</span><span class="p">,</span> <span class="n">output_fidelities_noise</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>\
         <span class="n">label</span><span class="o">=</span><span class="s1">&#39;QASM simulator w/ noise&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Input Fidelity $F$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Output Fidelity $F&#39;$&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p>We can see that due to the presence of noise, the output fidelity (orange) is smaller than in the case of a unitary time evolution we have examined in <strong>Part III</strong> (red). Nevertheless, for fidelities around 0.7 to 0.8, where the increase in fidelity is largest, it can be observed that the output fidelity is slightly increased. Therefore, it may even be possible to successfully run the entanglement purification protocol on a real IBM Q device.</p>
<p>And this is exactly what we will do in the following, last part of the tutorial.</p>
</section>
</section>
</section>
<section id="part-v-entanglement-purification-on-a-real-ibm-q-device">
<h2>Part V: Entanglement Purification on a Real IBM Q Device<a class="headerlink" href="#part-v-entanglement-purification-on-a-real-ibm-q-device" title="Permalink to this heading">¶</a></h2>
<hr class="docutils" />
<p>In this last part of the tutorial, we will run the BBPSSW protocol for entanglement purification on a real IBM Q device using the IBM Q Experience.</p>
<p>The first section explains the necessary details when using the IBM Q Experience. Then we proceed as in the noisy simulation, i.e. we first determine the true input fidelity into the purification protocol and then carry out the complete BBPSSW protocol.</p>
<section id="ibm-q-experience">
<h3>5.1 IBM Q Experience<a class="headerlink" href="#ibm-q-experience" title="Permalink to this heading">¶</a></h3>
<p>We have already defined the functions <code class="docutils literal notranslate"><span class="pre">execute_initialization</span></code> and <code class="docutils literal notranslate"><span class="pre">execute_purification</span></code> in such a way that we can simply pass the real IBM Q device as the target backend to execute the tomography circuits on it. The reason for this is that the Qiskit function <code class="docutils literal notranslate"><span class="pre">execute</span></code> itself sends a job to a real IBM Q device when this is selected as the backend.</p>
<p>Furthermore, we have already defined the real device <code class="docutils literal notranslate"><span class="pre">ibmqx2</span></code> as the backend <code class="docutils literal notranslate"><span class="pre">Backend_IBMQ</span></code>, so we are basically ready to execute our quantum circuits on the <code class="docutils literal notranslate"><span class="pre">ibmqx2</span></code> machine.</p>
<p>When working with real IBM Q devices via the IBM Q Experience, there are two points to consider when performing the entanglement purification experiment as in the previous sections. On the one hand we have to take into account a certain waiting time until the execution of a job and on the other hand we can only send a limited number of jobs to a real device. These two points will be explained in the next two subsections.</p>
<section id="device-queue-job-status-and-job-monitor">
<h4>5.1.1 Device Queue, Job Status, and Job Monitor<a class="headerlink" href="#device-queue-job-status-and-job-monitor" title="Permalink to this heading">¶</a></h4>
<p>We have already mentioned that a real device usually has a queue of pending jobs from other users. This means that, in addition to the actual execution time of a quantum circuit, the user must also wait until all pending jobs in the queue have been executed. A job has run successfully when it could be transmitted to the real device, passed the queue, and the quantum circuit could finally be executed. Only then can we obtain the results using the method <code class="docutils literal notranslate"><span class="pre">results</span></code> and perform all subsequent steps to reconstruct a density matrix.</p>
<p>This is exactly why we store the job object itself in a dictionary in the functions <code class="docutils literal notranslate"><span class="pre">execute_initialization</span></code> and <code class="docutils literal notranslate"><span class="pre">execute_purification</span></code>, so that we can retrieve the results at a later time when the job has been executed.</p>
<p>The current status of a job can be determined using the <code class="docutils literal notranslate"><span class="pre">status</span></code> method of the job class. Possible statuses are e.g. that the job is initialized, queued, actively running or done.</p>
<p>Qiskit also offers the possibility to continuously monitor a job with the function <code class="docutils literal notranslate"><span class="pre">job_monitor</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.tools.monitor</span> <span class="kn">import</span> <span class="n">job_monitor</span>
</pre></div>
</div>
</div>
</div>
<p>However, note that when using the <code class="docutils literal notranslate"><span class="pre">job_monitor</span></code> function, the notebook kernel remains busy until a job has been executed (or aborted for some reason). Since a job sent to a real device may be queued for a long period of time (up to hours or even days, depending on the workload of the device), the job monitor should be used carefully.</p>
<p>The number of pending jobs on an IBM Q device can be checked either on your IBM Q Experience - Dashboard (https://quantum-computing.ibm.com/) or with a Qiskit Jupyter tool <code class="docutils literal notranslate"><span class="pre">backend_overview</span></code>. For this we also import the Jupyter Tools:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">qiskit.tools.jupyter</span>
</pre></div>
</div>
</div>
</div>
<p>This gives us a good overview of all IBM Q devices available to us:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">qiskit_backend_overview</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="personal-credits">
<h4>5.1.2 Personal Credits<a class="headerlink" href="#personal-credits" title="Permalink to this heading">¶</a></h4>
<p>The IBM Q Experience regulates the use of real devices with the help of a credit system. This means that an execution on a real device costs a certain number of credits and after a job has been executed, the used credits are replenished. The number of credits that an execution actually costs depends, for example, on the number of experiment shots and the size of the quantum circuits to be executed.</p>
<p>As a private user you have a limited number of credits and therefore you can only send a maximum number of jobs to a real device.</p>
<p>Remember that we need to execute a series of <span class="math notranslate nohighlight">\(N\)</span> runs to implement the twirl operation, which on average creates a Werner state of <span class="math notranslate nohighlight">\(W_F\)</span>,</p>
<div class="math notranslate nohighlight">
\[
W_F \approx \frac{1}{N} \sum_{n=1}^N \rho_n,
\]</div>
<p>where <span class="math notranslate nohighlight">\(\rho_n\)</span> denotes the state after the random bilateral rotation in run <span class="math notranslate nohighlight">\(n\)</span> which can be obtained by executing the function <code class="docutils literal notranslate"><span class="pre">execute_initialization</span></code>. And we must also execute this series of <span class="math notranslate nohighlight">\(N\)</span> runs to determine the average output state <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span> of the BBPSSW protocol,</p>
<div class="math notranslate nohighlight">
\[
\rho'_{F'} \approx \frac{1}{N} \sum_{n=1}^{N} \rho_n',
\]</div>
<p>where <span class="math notranslate nohighlight">\(\rho_n'\)</span> now denotes the state of the control qubits after the application of the BBPSSW protocol in the execution run <span class="math notranslate nohighlight">\(n\)</span>, obtained by executing the function <code class="docutils literal notranslate"><span class="pre">execute_purification</span></code>.</p>
<p>To make this averaging process work, we have chosen <span class="math notranslate nohighlight">\(N=100\)</span> runs. If we select 1024 shots per experiment, the execution of all tomography circuits through <code class="docutils literal notranslate"><span class="pre">execute_initialization</span></code> or <code class="docutils literal notranslate"><span class="pre">execute_purification</span></code> in one job costs 3 credits. This means that we would need 300 credits to send all <span class="math notranslate nohighlight">\(N\)</span> runs to the real device.</p>
<p>As a private user you usually don’t have that many credits. (In our case, for example, it is 15 credits.) The entire experiments must therefore be divided into smaller batches, which are then sent separately to the device and executed there.</p>
<p>Furthermore, we want to reduce the number of runs <span class="math notranslate nohighlight">\(N\)</span> as much as possible in order to keep the execution time as short as possible. To reduce the number of necessary runs, we will adjust the averaging procedure to obtain a Werner state <span class="math notranslate nohighlight">\(W_F\)</span> or the final state <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span>. Instead of chosing randomly from the set of bilateral rotations, which would be the only way to go in a quantum communication network, we will apply each element of the set once to theoretically obtain an exact Werner state,</p>
<p>Instead of randomly choosing from the set of bilateral rotations <span class="math notranslate nohighlight">\(\{U_i\}\)</span>, which would be the only practical possibility in a quantum communication network, we will use each element of the set <span class="math notranslate nohighlight">\(\{U_i\}\)</span> once to theoretically obtain an exact Werner state at the beginning,</p>
<div class="math notranslate nohighlight">
\[
W_F = \frac{1}{12} \sum_{i=1}^{12} U_i \rho_\textrm{S} U_i^\dagger,
\]</div>
<p>where <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span> is the source state before the application of the twirl. So now we only have to execute 12 jobs to generate a Werner state on average as input for the purification protocol.</p>
<p>In this tutorial we divide these 12 jobs into batches of 4. We then send only one batch at a time to the device and wait until the experiments have been completed, so that there are always enough credits available to execute all jobs of a batch:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Batch #</p></th>
<th class="head text-center"><p>Bilateral Rotations <span class="math notranslate nohighlight">\(i\)</span></p></th>
<th class="head text-center"><p>Num. of Credits</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>1</p></td>
<td class="text-center"><p>1 - 4</p></td>
<td class="text-center"><p>12</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>2</p></td>
<td class="text-center"><p>5 - 8</p></td>
<td class="text-center"><p>12</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>3</p></td>
<td class="text-center"><p>9 - 12</p></td>
<td class="text-center"><p>12</p></td>
</tr>
</tbody>
</table>
<p>When all batches have been successfully executed, we can finally follow the procedures in <strong>Part III</strong> and <strong>Part IV</strong> to reconstruct the density matrices <span class="math notranslate nohighlight">\(W_F\)</span> and <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span> from the execution results with our predefined function <code class="docutils literal notranslate"><span class="pre">rho_from_dict</span></code>.</p>
<p>In case you have a different number of credits available, you will see that you can easily adapt the following implementation to your own case.</p>
</section>
</section>
<section id="id1">
<h3>5.2 Initial State and Initial Fidelity<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h3>
<p>Due to imperfections in the real device, the actual input fidelity <span class="math notranslate nohighlight">\(F\)</span> to the BBPSSW protocol is less than the source fidelity <span class="math notranslate nohighlight">\(F_\textrm{S}\)</span> (cf. the noisy simulation and the plot in <strong>Sec. 4.3.1</strong>). As in the case of the noisy simulation, we must therefore first determine the actual input fidelity to the BBPSSW protocol.</p>
<p>In the previous section, we explained why we cannot run the BBPSSW protocol on a real device exactly as we did in the simulations. As a private user you have a limited number of credits and we therefore only run the BBPSSW protocol on the real device for a single source fidelity of <span class="math notranslate nohighlight">\(F_\textrm{S}=1\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">F_source</span> <span class="o">=</span> <span class="mf">0.8</span>
</pre></div>
</div>
</div>
</div>
<p>To execute the quantum circuits for the initialization of a Werner state <span class="math notranslate nohighlight">\(W_F\)</span>, we can use the function <code class="docutils literal notranslate"><span class="pre">execute_initialization</span></code> again. Each execution of this function returns a job dictionary and we store the dictionary of each run <span class="math notranslate nohighlight">\(i\)</span> in a list <code class="docutils literal notranslate"><span class="pre">initialization_jobs</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">initialization_jobs</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
</div>
</div>
<p>We can use the list elements later to retrieve the job results when the execution of the corresponding quantum circuits is complete.</p>
<p>So let’s start with the execution of the first batch on the IBM Q device <code class="docutils literal notranslate"><span class="pre">ibmqx2</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
    <span class="n">job_dict</span> <span class="o">=</span> <span class="n">execute_initialization</span><span class="p">(</span><span class="n">F_source</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">backend_IBMQ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
    <span class="n">initialization_jobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">job_dict</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Remember: Each element of this batch now consists of the tomography circuits belonging to the quantum circuit which first generates the source state <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span> and then implements the bilateral rotation <span class="math notranslate nohighlight">\(U_i\)</span>. And the whole thing is done for the indices <span class="math notranslate nohighlight">\(i \in \{1, 2, 3, 4\}\)</span>.</p>
<p>After running the above cell, we can check the status of each of the four jobs using the method <code class="docutils literal notranslate"><span class="pre">status</span></code>. E.g. for the first entry in the list <code class="docutils literal notranslate"><span class="pre">initialization_jobs</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">initialization_jobs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;job&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">status</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We have also mentioned another method to continuously monitor the status of a job by using the function <code class="docutils literal notranslate"><span class="pre">job_monitor</span></code>. We will do this for the latest job, i.e. the last entry in <code class="docutils literal notranslate"><span class="pre">initialization_jobs</span></code>, but remember that the kernel will be busy until the job is finished (or an error has occurred):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job_monitor</span><span class="p">(</span><span class="n">initialization_jobs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;job&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>If the job was successfully executed, i.e. no error occurred and the job was not canceled, the output of the above cell should print <code class="docutils literal notranslate"><span class="pre">Job</span> <span class="pre">Status:</span> <span class="pre">job</span> <span class="pre">has</span> <span class="pre">successfully</span> <span class="pre">run</span></code>.</p>
<p>If this is the case, we can the start the execution of the second batch by simpy changing the indices of the bilateral rotations to <span class="math notranslate nohighlight">\(i \in \{5,6,7,8\}\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
    <span class="n">job_dict</span> <span class="o">=</span> <span class="n">execute_initialization</span><span class="p">(</span><span class="n">F_source</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">backend_IBMQ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
    <span class="n">initialization_jobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">job_dict</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Here, too, we use the job monitor to watch the status of the latest job:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job_monitor</span><span class="p">(</span><span class="n">initialization_jobs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;job&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>If this job has also run successfully, we can execute the third and last batch for the indices <span class="math notranslate nohighlight">\(i \in \{9,10,11,12\}\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">):</span>
    <span class="n">job_dict</span> <span class="o">=</span> <span class="n">execute_initialization</span><span class="p">(</span><span class="n">F_source</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">backend_IBMQ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
    <span class="n">initialization_jobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">job_dict</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We monitor the status of the job that was last sent again:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job_monitor</span><span class="p">(</span><span class="n">initialization_jobs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;job&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>To make sure that all jobs have actually run successfully, you can, for example, check the status of all jobs that we have now executed on the real IBM Q device:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">initialization_jobs</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;i = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="s2">&quot;job&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">status</span><span class="p">()))</span>
</pre></div>
</div>
</div>
</div>
<p>If the status of all jobs is <code class="docutils literal notranslate"><span class="pre">DONE</span></code>, we can now reconstruct the quantum state of the control qubits.</p>
<p>In the noisy simulation (<strong>Sec. 4.3.1</strong>) we did this for each execution run with the previously defined function <code class="docutils literal notranslate"><span class="pre">rho_from_dict</span></code>, to which we passed the job dictionary of this run and set the value of the input parameter <code class="docutils literal notranslate"><span class="pre">cond_tomo=False</span></code>. (We perform regular quantum state tomography after initialization.)</p>
<p>Here, in the case of a real device, we can use exactly the same procedure to reconstruct the density matrices of the control qubits using the function <code class="docutils literal notranslate"><span class="pre">rho_from_dict</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">experimental_initial_states</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">initialization_jobs</span><span class="p">:</span>
    <span class="n">rho_fit</span> <span class="o">=</span> <span class="n">rho_from_dict</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">cond_tomo</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">experimental_initial_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rho_fit</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We store the reconstructed initial state of each run <span class="math notranslate nohighlight">\(i\)</span> in the list <code class="docutils literal notranslate"><span class="pre">experimental_initial_states</span></code> and then calculate the average:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rho_average</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">experimental_initial_states</span><span class="p">)</span><span class="o">/</span><span class="mi">12</span>
</pre></div>
</div>
</div>
</div>
<p>The state <code class="docutils literal notranslate"><span class="pre">rho_average</span></code> should now be close to a Werner state <span class="math notranslate nohighlight">\(W_F\)</span> to be useful as an input state for the BBPSSW protocol. To check this, we must first calculate the fidelity <span class="math notranslate nohighlight">\(F\)</span> towards the Bell state <span class="math notranslate nohighlight">\(|\Psi^-\rangle\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">experimental_input_fidelity</span> <span class="o">=</span> <span class="n">state_fidelity</span><span class="p">(</span><span class="n">rho_average</span><span class="p">,</span> <span class="n">psi_minus</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Source fidelity =&#39;</span><span class="p">,</span> <span class="n">F_source</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Experimental input fidelity = </span><span class="si">{:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">experimental_input_fidelity</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>This fidelity now corresponds to the actual initial fidelity, if a real IBM Q device is used as backend and is therefore called <code class="docutils literal notranslate"><span class="pre">experimental_input_fidelity</span></code>.</p>
<p>(For comparison: In experiments to test the tutorial we got fidelities <code class="docutils literal notranslate"><span class="pre">experimental_input_fidelity</span></code> of about 75 % using the IBM Q device <code class="docutils literal notranslate"><span class="pre">ibmqx2</span></code>.)</p>
<p>As we could expect from the noisy simulation, the fidelity <code class="docutils literal notranslate"><span class="pre">experimental_input_fidelity</span></code> is smaller than the source fidelity <code class="docutils literal notranslate"><span class="pre">F_source</span></code>, i.e.:</p>
<div class="math notranslate nohighlight">
\[
F &lt; F_\textrm{S}.
\]</div>
<p>We can now calculate the fidelity of the state <code class="docutils literal notranslate"><span class="pre">rho_average</span></code> towards the Werner state <span class="math notranslate nohighlight">\(W_F\)</span> (where <span class="math notranslate nohighlight">\(F\)</span> is now the <code class="docutils literal notranslate"><span class="pre">experimental_input_fidelity</span></code>):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fidelity_Werner</span> <span class="o">=</span> <span class="n">state_fidelity_Werner</span><span class="p">(</span><span class="n">experimental_input_fidelity</span><span class="p">,</span> <span class="n">rho_average</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Fidelity towards Werner state = </span><span class="si">{:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fidelity_Werner</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>(For comparison: In experiments to test the tutorial we got fidelities <code class="docutils literal notranslate"><span class="pre">fidelity_Werner</span></code> of about 95 % using the IBM Q device <code class="docutils literal notranslate"><span class="pre">ibmqx2</span></code>.)</p>
<p>The results we obtained from the real IBM Q device <code class="docutils literal notranslate"><span class="pre">ibmqx2</span></code> can now be compared with the results of the noisy simulation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">F_S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">F_S</span><span class="p">,</span> <span class="n">F_S</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;$F = F_\mathrm</span><span class="si">{S}</span><span class="s2">$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">source_fidelities</span><span class="p">,</span> <span class="n">input_fidelities_noise</span><span class="p">,</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;QASM simulator w/ noise&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">F_source</span><span class="p">,</span> <span class="n">experimental_input_fidelity</span><span class="p">,</span> <span class="s1">&#39;gx&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">backend_IBMQ</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Source Fidelity $F_\mathrm</span><span class="si">{S}</span><span class="s1">$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Input Fidelity $F$&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p>Probably the experimentally observed input fidelity on the device <code class="docutils literal notranslate"><span class="pre">ibmqx2</span></code> is smaller than that of the noisy simulation. There may be various reasons why the results of the simulation and the use of the real device differ. For example, we used a very simple noise model for the simulation, which most likely does not take into account all the effects that lead to errors in the computation on the real device.</p>
<p>An analysis of how good the simulation is should not be part of this tutorial. The focus of this section is basically to execute the quantum circuits correctly on a real IBM Q device using the IBM Q Experience.</p>
<p>Now that we have obtained an experimental value for the input fidelity <span class="math notranslate nohighlight">\(F\)</span>, in the last step of this tutorial we will run the complete BBPSSW protocol on the <code class="docutils literal notranslate"><span class="pre">ibmqx2</span></code> device.</p>
</section>
<section id="execution-of-the-bbpssw-protocol-on-a-real-device">
<h3>5.3 Execution of the BBPSSW Protocol on a Real Device<a class="headerlink" href="#execution-of-the-bbpssw-protocol-on-a-real-device" title="Permalink to this heading">¶</a></h3>
<p>The execution of the complete purification experiment is similar to the steps in the previous section regarding the splitting of all necessary jobs into smaller batches. This is again due to the limited number of credits.</p>
<p>To run the BBPSSW protocol on a real IBM Q device, we will use our function <code class="docutils literal notranslate"><span class="pre">execute_purification</span></code> and simply pass the IBM Q device <code class="docutils literal notranslate"><span class="pre">ibmqx2</span></code> as the target backend.</p>
<p>We use each element of the set <span class="math notranslate nohighlight">\(\{U_i\}\)</span> once again to implement an exact twirl. The output state of the control qubits <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span> after to the BBPSSW protocol will then be the following average</p>
<div class="math notranslate nohighlight">
\[
\rho'_{F'} = \frac{1}{12} \sum_{i=1}^{N} \rho_i',
\]</div>
<p>where <span class="math notranslate nohighlight">\(\rho_i'\)</span> is the control qubit state if the bilateral rotation <span class="math notranslate nohighlight">\(U_i\)</span> was applied during the initialization process.</p>
<p>This time we store the jobs of each run <span class="math notranslate nohighlight">\(i\)</span> in the list <code class="docutils literal notranslate"><span class="pre">purification_jobs</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">purification_jobs</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
</div>
</div>
<p>We start with the execution of the first batch on the IBM Q device <code class="docutils literal notranslate"><span class="pre">ibmqx2</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
    <span class="n">job_dict</span> <span class="o">=</span> <span class="n">execute_purification</span><span class="p">(</span><span class="n">F_source</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">backend_IBMQ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
    <span class="n">purification_jobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">job_dict</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Remember once again: Each element of this batch now consists of the tomography circuits to the quantum circuit, which uses the bilateral rotation <span class="math notranslate nohighlight">\(U_i\)</span> in the twirl and then implements the entire BBPSSW protocol. And the whole thing is done for the indices <span class="math notranslate nohighlight">\(i \in \{1, 2, 3, 4\}\)</span>.</p>
<p>Here, too, we use the job monitor to watch the status of the latest job:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job_monitor</span><span class="p">(</span><span class="n">purification_jobs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;job&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>We unfortunately obtain an error here. These circuits cannot be executed because the barriers are still in our way (remember the explanation at the end of <strong>Part II</strong>). But we already took care of the by passing the argument <code class="docutils literal notranslate"><span class="pre">remove_barriers=True</span></code> to the function <code class="docutils literal notranslate"><span class="pre">execute_purification</span></code>. So let’s start over again:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">purification_jobs</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
    <span class="n">job_dict</span> <span class="o">=</span> <span class="n">execute_purification</span><span class="p">(</span><span class="n">F_source</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">backend_IBMQ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">remove_barriers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">purification_jobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">job_dict</span><span class="p">)</span>
    
<span class="n">job_monitor</span><span class="p">(</span><span class="n">purification_jobs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;job&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>If the job has successfully run, we can the start the execution of the second batch by simpy changing the indices of the bilateral rotations to <span class="math notranslate nohighlight">\(i \in \{5,6,7,8\}\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
    <span class="n">job_dict</span> <span class="o">=</span> <span class="n">execute_purification</span><span class="p">(</span><span class="n">F_source</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">backend_IBMQ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">remove_barriers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">purification_jobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">job_dict</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job_monitor</span><span class="p">(</span><span class="n">purification_jobs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;job&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>And if the latest job of the second batch has successfully run, the third batch can be sent to the device using the indices <span class="math notranslate nohighlight">\(i \in \{9,10,11,12\}\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">):</span>
    <span class="n">job_dict</span> <span class="o">=</span> <span class="n">execute_purification</span><span class="p">(</span><span class="n">F_source</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">backend_IBMQ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">remove_barriers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">purification_jobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">job_dict</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job_monitor</span><span class="p">(</span><span class="n">purification_jobs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;job&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>To ensure that all jobs have been successfully executed, we will again check the status of all jobs that we have just executed on the real IBM Q device:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">purification_jobs</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;i = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="s2">&quot;job&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">status</span><span class="p">()))</span>
</pre></div>
</div>
</div>
</div>
<p>When the status of all jobs is <code class="docutils literal notranslate"><span class="pre">DONE</span></code>, we can continue to reconstruct the state of the control qubits using conditional quantum state tomography. Again we follow the steps of the noisy simulation (<strong>Sec. 4.3.2</strong>) and do this  for each execution run with the previously defined function <code class="docutils literal notranslate"><span class="pre">rho_from_dict</span></code>, to which we pass the job dictionary of this run and set the value of the input parameter <code class="docutils literal notranslate"><span class="pre">cond_tomo=True</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">experimental_output_states</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">purification_jobs</span><span class="p">:</span>
    <span class="n">rho_fit</span> <span class="o">=</span> <span class="n">rho_from_dict</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">cond_tomo</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">experimental_output_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rho_fit</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Here we store the reconstructed output state of each run <span class="math notranslate nohighlight">\(i\)</span> in the list <code class="docutils literal notranslate"><span class="pre">experimental_output_states</span></code>. We then calculate the average of all reconstructed states to obtain <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rho_average</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">experimental_output_states</span><span class="p">)</span><span class="o">/</span><span class="mi">12</span>
</pre></div>
</div>
</div>
</div>
<p>Now that we have the state <span class="math notranslate nohighlight">\(\rho'_{F'}\)</span>, we are finally able to calculate the output fidelity <span class="math notranslate nohighlight">\(F'\)</span> after executing the BBPSSW protocol on the real device,</p>
<div class="math notranslate nohighlight">
\[
F' = \langle \Phi^+ | \rho'_{F'}| \Phi^+ \rangle,
\]</div>
<p>and compare it to the experimental input fidelity <span class="math notranslate nohighlight">\(F\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">experimental_output_fidelity</span> <span class="o">=</span> <span class="n">state_fidelity</span><span class="p">(</span><span class="n">rho_average</span><span class="p">,</span> <span class="n">phi_plus</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Source fidelity =&#39;</span><span class="p">,</span> <span class="n">F_source</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Experimental input fidelity = </span><span class="si">{:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">experimental_input_fidelity</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Theoretical output fidelity = </span><span class="si">{:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output_fidelity</span><span class="p">(</span><span class="n">experimental_input_fidelity</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Experimental output fidelity = </span><span class="si">{:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">experimental_output_fidelity</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>(For comparison: In experiments to test the tutorial we got output fidelities <code class="docutils literal notranslate"><span class="pre">experimental_output_fidelity</span></code> of about 70 - 75 % using the IBM Q device <code class="docutils literal notranslate"><span class="pre">ibmqx2</span></code>.)</p>
<p>If the current errors in the system are not too large, the experimental output fidelity may be greater than the input fidelity. However, we will not be able to make any concrete statements about the result. This would require a much more thorough analysis, which cannot be part of this tutorial. For example, to compare input and output fidelity, two quantities observed in two different experiments, it would be necessary to prove that the experimental conditions were the same in both cases. Also a fundamental, detailed error analysis cannot be omitted.</p>
<p>Nevertheless, at the end we summarize all the results we have received in this tutorial:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">F_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">F_in</span><span class="p">,</span> <span class="n">F_in</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;$F&#39; = F$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">F_in</span><span class="p">,</span> <span class="n">output_fidelity</span><span class="p">(</span><span class="n">F_in</span><span class="p">),</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;$F&#39;(F)$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">input_fidelities</span><span class="p">,</span> <span class="n">output_fidelities</span><span class="p">,</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;QASM simulator&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">input_fidelities_noise</span><span class="p">,</span> <span class="n">output_fidelities_noise</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>\
         <span class="n">label</span><span class="o">=</span><span class="s1">&#39;QASM simulator w/ noise&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">experimental_input_fidelity</span><span class="p">,</span> <span class="n">experimental_output_fidelity</span><span class="p">,</span> <span class="s1">&#39;gx&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">backend_IBMQ</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Input Fidelity $F$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Output Fidelity $F&#39;$&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<p>When we compare the results of the <code class="docutils literal notranslate"><span class="pre">ibmqx2</span></code> machine and the noisy simulation, we see a good agreement for the value of the output fidelity <span class="math notranslate nohighlight">\(F'\)</span>. However, we have already seen that the simulator significantly overestimates the value for the actual initial fidelity <span class="math notranslate nohighlight">\(F\)</span>. The errors that come from the part of the circuit that belongs exclusively to the BBPSSW protocol, i.e. gate errors in the circuit <code class="docutils literal notranslate"><span class="pre">purification_circ</span></code> and subsequent measurement errors, are therefore probably underestimated by the noise model used here.</p>
</section>
</section>
<section id="part-vi-conclusion-and-further-ideas">
<h2>Part VI: Conclusion and Further Ideas<a class="headerlink" href="#part-vi-conclusion-and-further-ideas" title="Permalink to this heading">¶</a></h2>
<p>In this tutorial we showed how to use the IBM framework Qiskit and the online platform IBM Q Experience for quantum information processing, using the BBPSSW protocol for entanglement purification as an example.</p>
<p>The quantum circuit for the BBPSSW protocol consists of common single-qubit and two-qubit gates and we have explained in detail how this circuit is constructed in Qiskit. Furthermore, we have demonstrated how to use a library integrated in Qiskit to perform conditional quantum state tomography, which is also required in the BBPSSW protocol.</p>
<p>Quantum circuits in Qiskit can be executed either on a simulator or on real IBM Q devices and we have shown how to use these two backends respectively. When using the simulator, we also explained how simple noise models can be created and integrated into the simulation.</p>
<p>There are (at least) two possible topics that could usefully extend this tutorial. On the one hand, there are possibilities to improve the execution on real devices, and on the other hand, there are other protocols for entanglement purification in addition to the BBPSSW protocol (see e.g. [9] and the references therein).</p>
<p>Some possibilities that could improve the quality of execution on a real device are:</p>
<ul class="simple">
<li><p><strong>Error mitigation through calibration circuits</strong><br />
The Qiskit element Ignis provides noise mitigation functions through specific calibration routines. The use of these functions could therefore lead to a better performance of the execution on the real device and thus to a more significant increase in the output fidelity <span class="math notranslate nohighlight">\(F'\)</span>.</p></li>
<li><p><strong>Circuit optimization with internal compiler</strong><br />
A quantum circuit must be mapped to the physical layout of a real device, i.e. the coupling of the individual qubits with each other and the available set quantum gates is taken into account. This is done via a compiler and the result is a compiled quantum circuit which is actually executed on the real device. The Qiskit compiler knows four optimization levels and you can use this possibility to reduce the length of the compiled circuit, i.e. the number of operations required, and thus suppress the effects of errors.</p></li>
<li><p><strong>Circuit optimization with external compiler</strong><br />
Another possibility is the use of external compilers, such as t|ket⟩™, to optimize quantum circuits. In addition, one could compare the results of different compilers with each other.</p></li>
</ul>
<p>As already mentioned, the BBPSSW protocol is one of many for entanglement purification. Some of these protocols work very similarly and differ only in the bilateral two-qubit interaction that Alice and Bob apply locally to their qubits. It is straightforward to implement such a protocol by simply changing the gates that make up the circuit <code class="docutils literal notranslate"><span class="pre">purification_circ</span></code>.</p>
<p>But there are also protocols that work with three input pairs <span class="math notranslate nohighlight">\(\rho_\textrm{S}\)</span>, for example, and require a specific measurement outcome of two of these pairs for successful purification. In order to implement such a protocol in Qiskit according to the procedure presented in this tutorial, one would also have to adapt the creation of the ancilla tomography circuits and change the function <code class="docutils literal notranslate"><span class="pre">purification_shots</span></code> so that the conditions for a successful purification are fulfilled.</p>
<p>Another provider has just been released that enables access to the trapped ion device of Alpine Quantum Technologies (AQT) [10,11]. If you have AQT credentials, it would be great to see how well the purification protocol works on the trapped ion device. The results could then be compared with earlier experimental results demonstrating entanglement purification for ion qubits [12].</p>
<p>Finally, we would like to emphasize that by providing these ideas, we hope to encourage other users to continue learning with this tutorial notebook by trying out the implementation of the ideas.</p>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this heading">¶</a></h2>
<hr class="docutils" />
<p>[1] C. H. Bennett, H. J. Bernstein, S. Popescu, and B. Schumacher, <em>Concentrating partial entanglement by local operations</em>, Phys. Rev. A <strong>53</strong>, 2046 (1996).</p>
<p>[2] C. H. Bennett, G. Brassard, C. Crépeau, R. Jozsa, A. Peres, and W. K. Wootters, <em>Teleporting an unknown quantum state via dual classical and Einstein-Podolsky-Rosen channels</em>, Phys. Rev. Lett. <strong>70</strong>, 1895 (1993).</p>
<p>[3] A. K. Ekert, <em>Quantum cryptography based on Bell’s theorem</em>, Phys. Rev. Lett. <strong>67</strong>, 661 (1991).</p>
<p>[4] H.-J. Briegel, W. Dür, J. I. Cirac, and P. Zoller, <em>Quantum Repeaters: The Role of Imperfect Local Operations in Quantum Communication</em>, Phys. Rev. Lett. <strong>81</strong>, 5932 (1998).</p>
<p>[5] C. H. Bennett, D. P. DiVincenzo, J. A. Smolin, and W. K. Wootters, <em>Mixed-state entanglement
and quantum error correction</em>, Phys. Rev. A <strong>54</strong>, 3824 (1996).</p>
<p>[6] <em>Quantum State Tomography</em>, Retrieved from https://github.com/Qiskit/qiskit-iqx-tutorials/blob/master/qiskit/advanced/ignis/6a_state_tomography.ipynb (2019, December 1).</p>
<p>[7] R. LaRose, A. Mari, P. J. Karalekas, N. Shammah, and W. J. Zeng, <em>Mitiq: A software package for error mitigation on noisy quantum computers</em>, arXiv:2009.04417 (2020)</p>
<p>[8] <em>The IBM Q Account</em>, Retrieved from https://github.com/Qiskit/qiskit-iqx-tutorials/blob/5c18c22465d19b22ca19a915518f051de78ba4bc/qiskit/fundamentals/3_the_ibmq_account.ipynb (2019, December 1).</p>
<p>[9] W. Dür and H. J. Briegel, <em>Entanglement purification and quantum error correction</em>, Rep. Prog. Phys. <strong>70</strong>, 1381 (2007).</p>
<p>[10] A. Javadi-Abhari, P. Nation, and J. Gambetta, <em>Qiskit – Write once, target multiple architectures</em>, Retrieved from https://www.ibm.com/blogs/research/2019/11/qiskit-for-multiple-architectures/ (2019, December 1)</p>
<p>[11] Retrived from https://www.aqt.eu/ (2019, December 1).</p>
<p>[12] R. Reichle, D. Leibfried, E. Knill, J. Britton, R. B. Blakestad, J. D. Jost, C. Langer, R. Ozeri, S. Seidelin, and D. J. Wineland, <em>Experimental purification of two-atom entanglement</em>, Nature <strong>443</strong>, 838 (2006).</p>
</section>
</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../../../../_sources/courses/PHYS437/Hands-On/hands-on-6/Hands-on-6-book.ipynb.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright (CC BY 3.0) https://creativecommons.org/ .<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.3.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>
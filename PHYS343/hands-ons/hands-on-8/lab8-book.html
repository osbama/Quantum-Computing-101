<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Learning Outcomes &#8212; Introduction to Quantum Computing for Physicists  documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/togglebutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.12.4.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.4.1/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default ">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          QC for Physicists</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../hands-on-sessions.html">Hands-on sessions for Phys343</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Contents <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../syllabus.html">Syllabus</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../syllabus.html#hands-on-sessions">Hands-On sessions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../syllabus.html#theoretical-sections">Theoretical sections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../syllabus.html#tentative-course-contents">Tentative Course Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../syllabus.html#term-projects">Term projects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../syllabus.html#textbooks">Textbooks</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../schedule.html">Course schedule</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../links_and_forms.html">Forms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lectures/lectures.html">Lectures and Lecture notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../lectures/Ch1.html">Chapter 1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../lectures/Ch2.html">Chapter 2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../lectures/Ch3.html">Chapter 3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../lectures/Ch4.html">Chapter 4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../lectures/Ch5.html">Chapter 5</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../lectures/Ch6.html">Chapter 6</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../lectures/Ch7.html">Chapter 7</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../hands-on-sessions.html">Hands On Sessions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../hands-on-0/lab0.html">Linux Terminal Primer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hands-on-0/lab0.html#getting-your-computer-ready">Getting your computer ready</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hands-on-0/lab0.html#dilhan">Dilhan</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hands-on-1/lab1.html">Session Recording</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hands-on-1/lab1.html#lab-book">Lab book</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hands-on-2/lab2.html">Session Recording</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hands-on-2/lab2.html#lab-book">Lab book</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hands-on-3/lab3.html">Session Recording</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hands-on-3/lab3.html#lab-book">Lab book</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hands-on-4/lab4.html">Session Recording</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hands-on-4/lab4.html#lab-book">Lab book</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hands-on-5/lab5.html">Session Recording</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hands-on-5/lab5.html#lab-book">Lab book</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hands-on-6/lab6.html">Session Recording</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hands-on-6/lab6.html#lab-book">Lab book</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hands-on-7/lab7.html">Session Recording</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hands-on-7/lab7.html#lab-book">Lab book</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab8.html">Session Recording</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab8.html#lab-book">Lab book</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../term_project_ideas.html">Term Project Ideas</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../help/IBM_quantum.html">Using IBM quantum Cloud</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../help/IBM_quantum.html#invitation-e-mail">Invitation e-mail</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../help/IBM_quantum.html#ibm-quantum-computing-cloud">IBM Quantum Computing cloud</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="learning-outcomes">
<h1>Learning Outcomes<a class="headerlink" href="#learning-outcomes" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p>QFT’s counting perspective</p></li>
<li><p>Quantum Phase Estimation</p></li>
<li><p>Shor’s Algorithm</p></li>
<li><p>Grover’s Algorithm</p></li>
</ul>
<div class="section" id="intuition-a-id-intuition-a">
<h2>2. Intuition <a id="intuition"></a><a class="headerlink" href="#intuition-a-id-intuition-a" title="Permalink to this headline">¶</a></h2>
<p>The quantum Fourier transform (QFT) transforms between two bases, the computational (Z) basis, and the Fourier basis. The H-gate is the single-qubit QFT, and it transforms between the Z-basis states <span class="math notranslate nohighlight">\(|0\rangle\)</span> and <span class="math notranslate nohighlight">\(|1\rangle\)</span> to the X-basis states <span class="math notranslate nohighlight">\(|{+}\rangle\)</span> and <span class="math notranslate nohighlight">\(|{-}\rangle\)</span>. In the same way, all multi-qubit states in the computational basis have corresponding states in the Fourier basis. The QFT is simply the function that transforms between these bases.</p>
<div class="math notranslate nohighlight">
\[
|\text{State in Computational Basis}\rangle \quad \xrightarrow[]{\text{QFT}} \quad |\text{State in Fourier Basis}\rangle
\]</div>
<div class="math notranslate nohighlight">
\[
\text{QFT}|x\rangle = |\widetilde{x}\rangle
\]</div>
<p>(We often note states in the Fourier basis using the tilde (~)).</p>
<div class="section" id="counting-in-the-fourier-basis-a-id-counting-fourier-a">
<h3>2.1 Counting in the Fourier basis: <a id="counting-fourier"></a><a class="headerlink" href="#counting-in-the-fourier-basis-a-id-counting-fourier-a" title="Permalink to this headline">¶</a></h3>
<p>In the computational basis, we store numbers in binary using the states <span class="math notranslate nohighlight">\(|0\rangle\)</span> and <span class="math notranslate nohighlight">\(|1\rangle\)</span>:</p>
<p><img alt="zbasiscounting" src="PHYS343/hands-ons/hands-on-8/images/zbasis-counting.gif" />
Note the frequency with which the different qubits change; the leftmost qubit flips with every increment in the number, the next with every 2 increments, the third with every 4 increments, and so on. In the Fourier basis, we store numbers using different rotations around the Z-axis:</p>
<p><img alt="fbasiscounting" src="PHYS343/hands-ons/hands-on-8/images/fourierbasis-counting.gif" /></p>
<p>The number we want to store dictates the angle at which each qubit is rotated around the Z-axis. In the state <span class="math notranslate nohighlight">\(|\widetilde{0}\rangle\)</span>, all qubits are in the state <span class="math notranslate nohighlight">\(|{+}\rangle\)</span>. As seen in the example above, to encode the state <span class="math notranslate nohighlight">\(|\widetilde{5}\rangle\)</span> on 4 qubits, we rotated the leftmost qubit by <span class="math notranslate nohighlight">\(\tfrac{5}{2^n} = \tfrac{5}{16}\)</span> full turns (<span class="math notranslate nohighlight">\(\tfrac{5}{16}\times 2\pi\)</span> radians). The next qubit is turned double this (<span class="math notranslate nohighlight">\(\tfrac{10}{16}\times 2\pi\)</span> radians, or <span class="math notranslate nohighlight">\(10/16\)</span> full turns), this angle is then doubled for the qubit after, and so on.</p>
<p>Again, note the frequency with which each qubit changes. The leftmost qubit (<code class="docutils literal notranslate"><span class="pre">qubit</span> <span class="pre">0</span></code>) in this case has the lowest frequency, and the rightmost the highest.</p>
</div>
<div class="section" id="exercise-1">
<h3>Exercise 1<a class="headerlink" href="#exercise-1" title="Permalink to this headline">¶</a></h3>
<p>Let’s say we are using 3 qubits to represent numbers between 0-7. Answer the following:</p>
<ul class="simple">
<li><p>How do we represent <span class="math notranslate nohighlight">\(|3\rangle\)</span> in z basis?</p></li>
<li><p>How do we represent <span class="math notranslate nohighlight">\(|\widetilde{3}\rangle\)</span>? That is how much do we rotate each qubit?</p></li>
<li><p>How do we represent <span class="math notranslate nohighlight">\(|6\rangle\)</span> in z basis?</p></li>
<li><p>How do we represent <span class="math notranslate nohighlight">\(|\widetilde{6}\rangle\)</span>? That is how much do we rotate each qubit?</p></li>
</ul>
</div>
<div class="section" id="answer">
<h3>Answer<a class="headerlink" href="#answer" title="Permalink to this headline">¶</a></h3>
<p>?</p>
</div>
</div>
<div class="section" id="contents">
<h2>Contents<a class="headerlink" href="#contents" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p><a class="reference external" href="#overview">Overview</a><br />
1.1 <a class="reference external" href="#intuition">Intuition</a><br />
1.2 <a class="reference external" href="#maths">Mathematical Basis</a></p></li>
<li><p><a class="reference external" href="#example_t_gate">Example: T-gate</a><br />
2.1 <a class="reference external" href="#creating_the_circuit">Creating the Circuit</a><br />
2.2 <a class="reference external" href="#results">Results</a></p></li>
<li><p><a class="reference external" href="#getting_more_precision">Getting More Precision</a><br />
3.1 <a class="reference external" href="#the_problem">The Problem</a><br />
3.2 <a class="reference external" href="#the_solution">The Solution</a></p></li>
<li><p><a class="reference external" href="#real_devices">Experimenting on Real Devices</a><br />
4.1 <a class="reference external" href="#circuit_2.1">With the Circuit from 2.1</a></p></li>
<li><p><a class="reference external" href="#exercises">Exercises</a></p></li>
<li><p><a class="reference external" href="#looking_forward">Looking Forward</a></p></li>
<li><p><a class="reference external" href="#references">References</a></p></li>
<li><p><a class="reference external" href="#contributors">Contributors</a></p></li>
</ol>
<p>Quantum phase estimation is one of the most important subroutines in quantum computation. It serves as a central building block for many quantum algorithms. The objective of the algorithm is the following:</p>
<p>Given a unitary operator <span class="math notranslate nohighlight">\(U\)</span>, the algorithm estimates <span class="math notranslate nohighlight">\(\theta\)</span> in <span class="math notranslate nohighlight">\(U\vert\psi \rangle =e^{\boldsymbol{2\pi i} \theta }|\psi \rangle\)</span>. Here <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> is an eigenvector and <span class="math notranslate nohighlight">\(e^{\boldsymbol{2\pi i}\theta}\)</span> is the corresponding eigenvalue. Since <span class="math notranslate nohighlight">\(U\)</span> is unitary, all of its eigenvalues have a norm of 1.</p>
<div class="section" id="exercise-2">
<h3>Exercise 2<a class="headerlink" href="#exercise-2" title="Permalink to this headline">¶</a></h3>
<p>Prove that given a unitary operator <span class="math notranslate nohighlight">\(U\)</span>, its eigenvalues have norm 1.
Hint: <span class="math notranslate nohighlight">\(U |n\rangle = n | n \rangle \)</span></p>
</div>
<div class="section" id="id1">
<h3>Answer<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="overview-a-id-overview-a">
<h2>1. Overview <a id='overview'></a><a class="headerlink" href="#overview-a-id-overview-a" title="Permalink to this headline">¶</a></h2>
<p>The general quantum circuit for phase estimation is shown below. The top register contains <span class="math notranslate nohighlight">\(t\)</span> ‘counting’ qubits, and the bottom contains qubits in the state <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>:</p>
<p><img alt="image.png" src="PHYS343/hands-ons/hands-on-8/attachment:image.png" /></p>
<div class="section" id="id2">
<h3>1.1 Intuition <a id='intuition'></a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>The quantum phase estimation algorithm uses phase kickback to write the phase of <span class="math notranslate nohighlight">\(U\)</span> (in the Fourier basis) to the <span class="math notranslate nohighlight">\(t\)</span> qubits in the counting register. We then use the inverse QFT to translate this from the Fourier basis into the computational basis, which we can measure.</p>
<p>We remember (from the QFT chapter) that in the Fourier basis the topmost qubit completes one full rotation when counting between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^t\)</span>. To count to a number, <span class="math notranslate nohighlight">\(x\)</span> between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^t\)</span>, we rotate this qubit by <span class="math notranslate nohighlight">\(\tfrac{x}{2^t}\)</span> around the z-axis. For the next qubit we rotate by <span class="math notranslate nohighlight">\(\tfrac{2x}{2^t}\)</span>, then <span class="math notranslate nohighlight">\(\tfrac{4x}{2^t}\)</span> for the third qubit.</p>
<p><img alt="image.png" src="PHYS343/hands-ons/hands-on-8/attachment:image.png" /></p>
<p>When we use a qubit to control the <span class="math notranslate nohighlight">\(U\)</span>-gate, the qubit will turn (due to kickback) proportionally to the phase <span class="math notranslate nohighlight">\(e^{2i\pi\theta}\)</span>. We can use successive <span class="math notranslate nohighlight">\(CU\)</span>-gates to repeat this rotation an appropriate number of times until we have encoded the phase theta as a number between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^t\)</span> in the Fourier basis.</p>
<p>Then we simply use <span class="math notranslate nohighlight">\(QFT^\dagger\)</span> to convert this into the computational basis.</p>
</div>
<div class="section" id="mathematical-foundation-a-id-maths-a">
<h3>1.2 Mathematical Foundation <a id='maths'></a><a class="headerlink" href="#mathematical-foundation-a-id-maths-a" title="Permalink to this headline">¶</a></h3>
<p>As mentioned above, this circuit estimates the phase of a unitary operator <span class="math notranslate nohighlight">\(U\)</span>. It estimates <span class="math notranslate nohighlight">\(\theta\)</span> in <span class="math notranslate nohighlight">\(U\vert\psi \rangle =e^{\boldsymbol{2\pi i} \theta }|\psi \rangle\)</span>, where <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> is an eigenvector and <span class="math notranslate nohighlight">\(e^{\boldsymbol{2\pi i}\theta}\)</span> is the corresponding eigenvalue. The circuit operates in the following steps:</p>
<p>i. <strong>Setup</strong>: <span class="math notranslate nohighlight">\(\vert\psi\rangle\)</span> is in one set of qubit registers. An additional set of <span class="math notranslate nohighlight">\(n\)</span> qubits form the counting register on which we will store the value <span class="math notranslate nohighlight">\(2^n\theta\)</span>:</p>
<div class="math notranslate nohighlight">
\[ \psi_0 = \lvert 0 \rangle^{\otimes n} \lvert \psi \rangle\]</div>
<p>ii. <strong>Superposition</strong>: Apply a <span class="math notranslate nohighlight">\(n\)</span>-bit Hadamard gate operation <span class="math notranslate nohighlight">\(H^{\otimes n}\)</span> on the counting register:</p>
<div class="math notranslate nohighlight">
\[ \psi_1 = {\frac {1}{2^{\frac {n}{2}}}}\left(|0\rangle +|1\rangle \right)^{\otimes n} \lvert \psi \rangle\]</div>
<p>iii. <strong>Controlled Unitary Operations</strong>: We need to introduce the controlled unitary <span class="math notranslate nohighlight">\(C-U\)</span> that applies the unitary operator <span class="math notranslate nohighlight">\(U\)</span> on the target register only if its corresponding control bit is <span class="math notranslate nohighlight">\(|1\rangle\)</span>. Since <span class="math notranslate nohighlight">\(U\)</span> is a unitary operatory with eigenvector <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> such that <span class="math notranslate nohighlight">\(U|\psi \rangle =e^{\boldsymbol{2\pi i} \theta }|\psi \rangle\)</span>, this means:</p>
<div class="math notranslate nohighlight">
\[U^{2^{j}}|\psi \rangle =U^{2^{j}-1}U|\psi \rangle =U^{2^{j}-1}e^{2\pi i\theta }|\psi \rangle =\cdots =e^{2\pi i2^{j}\theta }|\psi \rangle\]</div>
<p>Applying all the <span class="math notranslate nohighlight">\(n\)</span> controlled operations <span class="math notranslate nohighlight">\(C − U^{2^j}\)</span> with <span class="math notranslate nohighlight">\(0\leq j\leq n-1\)</span>, and using the relation <span class="math notranslate nohighlight">\(|0\rangle \otimes |\psi \rangle +|1\rangle \otimes e^{2\pi i\theta }|\psi \rangle =\left(|0\rangle +e^{2\pi i\theta }|1\rangle \right)\otimes |\psi \rangle\)</span>:</p>
<p>\begin{aligned}
\psi_{2} &amp; =\frac {1}{2^{\frac {n}{2}}} \left(|0\rangle+{e^{\boldsymbol{2\pi i} \theta 2^{n-1}}}|1\rangle \right) \otimes \cdots \otimes \left(|0\rangle+{e^{\boldsymbol{2\pi i} \theta 2^{1}}}\vert1\rangle \right) \otimes \left(|0\rangle+{e^{\boldsymbol{2\pi i} \theta 2^{0}}}\vert1\rangle \right) \otimes |\psi\rangle\
&amp; = \frac{1}{2^{\frac {n}{2}}}\sum _{k=0}^{2^{n}-1}e^{\boldsymbol{2\pi i} \theta k}|k\rangle \otimes \vert\psi\rangle
\end{aligned}
where <span class="math notranslate nohighlight">\(k\)</span> denotes the integer representation of n-bit binary numbers.</p>
<p>iv. <strong>Inverse Fourier Transform</strong>: Notice that the above expression is exactly the result of applying a quantum Fourier transform as we derived in the notebook on <a class="reference external" href="https://qiskit.org/textbook/ch-algorithms/quantum-fourier-transform.html">Quantum Fourier Transform and its Qiskit Implementation</a>. Recall that QFT maps an n-qubit input state <span class="math notranslate nohighlight">\(\vert x\rangle\)</span> into an output as</p>
<div class="math notranslate nohighlight">
\[
QFT\vert x \rangle = \frac{1}{2^\frac{n}{2}}
\left(\vert0\rangle + e^{\frac{2\pi i}{2}x} \vert1\rangle\right) 
\otimes
\left(\vert0\rangle + e^{\frac{2\pi i}{2^2}x} \vert1\rangle\right) 
\otimes  
\ldots
\otimes
\left(\vert0\rangle + e^{\frac{2\pi i}{2^{n-1}}x} \vert1\rangle\right) 
\otimes
\left(\vert0\rangle + e^{\frac{2\pi i}{2^n}x} \vert1\rangle\right) 
\]</div>
<p>Replacing <span class="math notranslate nohighlight">\(x\)</span> by <span class="math notranslate nohighlight">\(2^n\theta\)</span> in the above expression gives exactly the expression derived in step 2 above. Therefore, to recover the state <span class="math notranslate nohighlight">\(\vert2^n\theta\rangle\)</span>, apply an inverse Fourier transform on the auxiliary register. Doing so, we find</p>
<div class="math notranslate nohighlight">
\[
\vert\psi_3\rangle = \frac {1}{2^{\frac {n}{2}}}\sum _{k=0}^{2^{n}-1}e^{\boldsymbol{2\pi i} \theta k}|k\rangle \otimes | \psi \rangle \xrightarrow{\mathcal{QFT}_n^{-1}} \frac {1}{2^n}\sum _{x=0}^{2^{n}-1}\sum _{k=0}^{2^{n}-1} e^{-\frac{2\pi i k}{2^n}(x - 2^n \theta)} |x\rangle \otimes |\psi\rangle
\]</div>
<p>v. <strong>Measurement</strong>:
The above expression peaks near <span class="math notranslate nohighlight">\(x = 2^n\theta\)</span>. For the case when <span class="math notranslate nohighlight">\(2^n\theta\)</span> is an integer, measuring in the computational basis gives the phase in the auxiliary register with high probability:</p>
<div class="math notranslate nohighlight">
\[ |\psi_4\rangle = | 2^n \theta \rangle \otimes | \psi \rangle\]</div>
<p>For the case when <span class="math notranslate nohighlight">\(2^n\theta\)</span> is not an integer, it can be shown that the above expression still peaks near <span class="math notranslate nohighlight">\(x = 2^n\theta\)</span> with probability better than <span class="math notranslate nohighlight">\(4/\pi^2 \approx 40\%\)</span> [1].</p>
</div>
</div>
<div class="section" id="example-t-gate-a-id-example-t-gate-a">
<h2>2. Example: T-gate <a id='example_t_gate'></a><a class="headerlink" href="#example-t-gate-a-id-example-t-gate-a" title="Permalink to this headline">¶</a></h2>
<p>Let’s take a gate we know well, the <span class="math notranslate nohighlight">\(T\)</span>-gate, and use Quantum Phase Estimation to estimate its phase. You will remember that the <span class="math notranslate nohighlight">\(T\)</span>-gate adds a phase of <span class="math notranslate nohighlight">\(e^\frac{i\pi}{4}\)</span> to the state <span class="math notranslate nohighlight">\(|1\rangle\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split} T|1\rangle = 
\begin{bmatrix}
1 &amp; 0\\
0 &amp; e^\frac{i\pi}{4}\\ 
\end{bmatrix}
\begin{bmatrix}
0\\
1\\ 
\end{bmatrix}
= e^\frac{i\pi}{4}|1\rangle \end{split}\]</div>
<p>Since QPE will give us <span class="math notranslate nohighlight">\(\theta\)</span> where:</p>
<div class="math notranslate nohighlight">
\[ T|1\rangle = e^{2i\pi\theta}|1\rangle \]</div>
<p>We expect to find:</p>
<div class="math notranslate nohighlight">
\[\theta = \frac{1}{8}\]</div>
<p>In this example we will use three qubits and obtain an <em>exact</em> result (not an estimation!)</p>
<div class="section" id="creating-the-circuit-a-id-creating-the-circuit-a">
<h3>2.1 Creating the Circuit <a id='creating_the_circuit'></a><a class="headerlink" href="#creating-the-circuit-a-id-creating-the-circuit-a" title="Permalink to this headline">¶</a></h3>
<p>Let’s first prepare our environment:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#initialization</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="c1"># importing Qiskit</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">IBMQ</span><span class="p">,</span> <span class="n">Aer</span><span class="p">,</span> <span class="n">transpile</span><span class="p">,</span> <span class="n">assemble</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">ClassicalRegister</span><span class="p">,</span> <span class="n">QuantumRegister</span>

<span class="c1"># import basic plot tools</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">ModuleNotFoundError</span><span class="g g-Whitespace">                       </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="mi">25913</span><span class="n">dd7c12a</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="g g-Whitespace">      </span><span class="mi">1</span> <span class="c1">#initialization</span>
<span class="ne">----&gt; </span><span class="mi">2</span> <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="g g-Whitespace">      </span><span class="mi">4</span> <span class="kn">import</span> <span class="nn">math</span>
<span class="g g-Whitespace">      </span><span class="mi">5</span> 

<span class="ne">ModuleNotFoundError</span>: No module named &#39;matplotlib&#39;
</pre></div>
</div>
</div>
</div>
<p>Now, set up the quantum circuit. We will use four qubits – qubits 0 to 2 as counting qubits, and qubit 3 as the eigenstate of the unitary operator (<span class="math notranslate nohighlight">\(T\)</span>).</p>
<p>We initialize <span class="math notranslate nohighlight">\(\vert\psi\rangle = \vert1\rangle\)</span> by applying an <span class="math notranslate nohighlight">\(X\)</span> gate:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qpe</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">qpe</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qpe</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_18_0.png" src="../../../_images/lab8-book_18_0.png" />
</div>
</div>
<p>Next, we apply Hadamard gates to the counting qubits:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">qpe</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
<span class="n">qpe</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_20_0.png" src="../../../_images/lab8-book_20_0.png" />
</div>
</div>
<p>Next we perform the controlled unitary operations. <strong>Remember:</strong> Qiskit orders its qubits the opposite way round to the image above.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">repetitions</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">counting_qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">repetitions</span><span class="p">):</span>
        <span class="n">qpe</span><span class="o">.</span><span class="n">cp</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="n">counting_qubit</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1"># This is C-U</span>
    <span class="n">repetitions</span> <span class="o">*=</span> <span class="mi">2</span>
<span class="n">qpe</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_22_0.png" src="../../../_images/lab8-book_22_0.png" />
</div>
</div>
<p>We apply the inverse quantum Fourier transformation to convert the state of the counting register. Here we provide the code for <span class="math notranslate nohighlight">\(QFT^\dagger\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">qft_dagger</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;n-qubit QFTdagger the first n qubits in circ&quot;&quot;&quot;</span>
    <span class="c1"># Don&#39;t forget the Swaps!</span>
    <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">qubit</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
            <span class="n">qc</span><span class="o">.</span><span class="n">cp</span><span class="p">(</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">m</span><span class="p">)),</span> <span class="n">m</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We then measure the counting register:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qpe</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
<span class="c1"># Apply inverse QFT</span>
<span class="n">qft_dagger</span><span class="p">(</span><span class="n">qpe</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1"># Measure</span>
<span class="n">qpe</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">qpe</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qpe</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_27_0.png" src="../../../_images/lab8-book_27_0.png" />
</div>
</div>
</div>
<div class="section" id="results-a-id-results-a">
<h3>2.2 Results <a id='results'></a><a class="headerlink" href="#results-a-id-results-a" title="Permalink to this headline">¶</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qasm_sim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">)</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">2048</span>
<span class="n">t_qpe</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qpe</span><span class="p">,</span> <span class="n">qasm_sim</span><span class="p">)</span>
<span class="n">qobj</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">t_qpe</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">qasm_sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qobj</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">answer</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>

<span class="n">plot_histogram</span><span class="p">(</span><span class="n">answer</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_29_0.png" src="../../../_images/lab8-book_29_0.png" />
</div>
</div>
<p>We see we get one result (<code class="docutils literal notranslate"><span class="pre">001</span></code>) with certainty, which translates to the decimal: <code class="docutils literal notranslate"><span class="pre">1</span></code>. We now need to divide our result (<code class="docutils literal notranslate"><span class="pre">1</span></code>) by <span class="math notranslate nohighlight">\(2^n\)</span> to get <span class="math notranslate nohighlight">\(\theta\)</span>:</p>
<div class="math notranslate nohighlight">
\[ \theta = \frac{1}{2^3} = \frac{1}{8} \]</div>
<p>This is exactly the result we expected!</p>
</div>
</div>
<div class="section" id="example-getting-more-precision-a-id-getting-more-precision-a">
<h2>3. Example: Getting More Precision <a id='getting_more_precision'></a><a class="headerlink" href="#example-getting-more-precision-a-id-getting-more-precision-a" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-problem-a-id-the-problem-a">
<h3>3.1 The Problem <a id='the_problem'></a><a class="headerlink" href="#the-problem-a-id-the-problem-a" title="Permalink to this headline">¶</a></h3>
<p>Instead of a <span class="math notranslate nohighlight">\(T\)</span>-gate, let’s use a gate with <span class="math notranslate nohighlight">\(\theta = \frac{1}{3}\)</span>. We set up our circuit as with the last example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create and set up circuit</span>
<span class="n">qpe2</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="c1"># Apply H-Gates to counting qubits:</span>
<span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">qpe2</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>

<span class="c1"># Prepare our eigenstate |psi&gt;:</span>
<span class="n">qpe2</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Do the controlled-U operations:</span>
<span class="n">angle</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span>
<span class="n">repetitions</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">counting_qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">repetitions</span><span class="p">):</span>
        <span class="n">qpe2</span><span class="o">.</span><span class="n">cp</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">counting_qubit</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">repetitions</span> <span class="o">*=</span> <span class="mi">2</span>

<span class="c1"># Do the inverse QFT:</span>
<span class="n">qft_dagger</span><span class="p">(</span><span class="n">qpe2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="c1"># Measure of course!</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">qpe2</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>

<span class="n">qpe2</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_32_0.png" src="../../../_images/lab8-book_32_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s see the results!</span>
<span class="n">qasm_sim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">)</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">4096</span>
<span class="n">t_qpe2</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qpe2</span><span class="p">,</span> <span class="n">qasm_sim</span><span class="p">)</span>
<span class="n">qobj</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">t_qpe2</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">qasm_sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qobj</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">answer</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>

<span class="n">plot_histogram</span><span class="p">(</span><span class="n">answer</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_33_0.png" src="../../../_images/lab8-book_33_0.png" />
</div>
</div>
<p>We are expecting the result <span class="math notranslate nohighlight">\(\theta = 0.3333\dots\)</span>, and we see our most likely results are <code class="docutils literal notranslate"><span class="pre">010(bin)</span> <span class="pre">=</span> <span class="pre">2(dec)</span></code> and <code class="docutils literal notranslate"><span class="pre">011(bin)</span> <span class="pre">=</span> <span class="pre">3(dec)</span></code>. These two results would tell us that <span class="math notranslate nohighlight">\(\theta = 0.25\)</span> (off by 25%) and <span class="math notranslate nohighlight">\(\theta = 0.375\)</span> (off by 13%) respectively. The true value of <span class="math notranslate nohighlight">\(\theta\)</span> lies between the values we can get from our counting bits, and this gives us uncertainty and imprecision.</p>
</div>
<div class="section" id="the-solution-a-id-the-solution-a">
<h3>3.2 The Solution <a id='the_solution'></a><a class="headerlink" href="#the-solution-a-id-the-solution-a" title="Permalink to this headline">¶</a></h3>
<p>To get more precision we simply add more counting qubits. We are going to add two more counting qubits:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create and set up circuit</span>
<span class="n">qpe3</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="c1"># Apply H-Gates to counting qubits:</span>
<span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">qpe3</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>

<span class="c1"># Prepare our eigenstate |psi&gt;:</span>
<span class="n">qpe3</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Do the controlled-U operations:</span>
<span class="n">angle</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span>
<span class="n">repetitions</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">counting_qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">repetitions</span><span class="p">):</span>
        <span class="n">qpe3</span><span class="o">.</span><span class="n">cp</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">counting_qubit</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="n">repetitions</span> <span class="o">*=</span> <span class="mi">2</span>

<span class="c1"># Do the inverse QFT:</span>
<span class="n">qft_dagger</span><span class="p">(</span><span class="n">qpe3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="c1"># Measure of course!</span>
<span class="n">qpe3</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">qpe3</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>

<span class="n">qpe3</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_35_0.png" src="../../../_images/lab8-book_35_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s see the results!</span>
<span class="n">qasm_sim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">)</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">4096</span>
<span class="n">t_qpe3</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qpe3</span><span class="p">,</span> <span class="n">qasm_sim</span><span class="p">)</span>
<span class="n">qobj</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">t_qpe3</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">qasm_sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qobj</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">answer</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>

<span class="n">plot_histogram</span><span class="p">(</span><span class="n">answer</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_36_0.png" src="../../../_images/lab8-book_36_0.png" />
</div>
</div>
<p>The two most likely measurements are now <code class="docutils literal notranslate"><span class="pre">01011</span></code> (decimal 11) and <code class="docutils literal notranslate"><span class="pre">01010</span></code> (decimal 10). Measuring these results would tell us <span class="math notranslate nohighlight">\(\theta\)</span> is:</p>
<div class="math notranslate nohighlight">
\[
\theta = \frac{11}{2^5} = 0.344,\;\text{  or  }\;\; \theta = \frac{10}{2^5} = 0.313
\]</div>
<p>These two results differ from <span class="math notranslate nohighlight">\(\frac{1}{3}\)</span> by 3% and 6% respectively. A much better precision!</p>
</div>
</div>
<div class="section" id="experiment-with-real-devices-a-id-real-devices-a">
<h2>4. Experiment with Real Devices <a id='real_devices'></a><a class="headerlink" href="#experiment-with-real-devices-a-id-real-devices-a" title="Permalink to this headline">¶</a></h2>
<div class="section" id="circuit-from-2-1-a-id-circuit-2-1-a">
<h3>4.1 Circuit from 2.1 <a id='circuit_2.1'></a><a class="headerlink" href="#circuit-from-2-1-a-id-circuit-2-1-a" title="Permalink to this headline">¶</a></h3>
<p>We can run the circuit in section 2.1 on a real device, let’s remind ourselves of the circuit:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qpe</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_39_0.png" src="../../../_images/lab8-book_39_0.png" />
</div>
</div>
<div class="cell tag_uses-hardware docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">IBMQ</span><span class="o">.</span><span class="n">load_account</span><span class="p">()</span>
<span class="kn">from</span> <span class="nn">qiskit.tools.monitor</span> <span class="kn">import</span> <span class="n">job_monitor</span>
<span class="n">provider</span> <span class="o">=</span> <span class="n">IBMQ</span><span class="o">.</span><span class="n">get_provider</span><span class="p">(</span><span class="n">hub</span><span class="o">=</span><span class="s1">&#39;ibm-q&#39;</span><span class="p">)</span>
<span class="n">santiago</span> <span class="o">=</span> <span class="n">provider</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;ibmq_santiago&#39;</span><span class="p">)</span>

<span class="c1"># Run with 2048 shots</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">2048</span>
<span class="n">t_qpe</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qpe</span><span class="p">,</span> <span class="n">santiago</span><span class="p">,</span> <span class="n">optimization_level</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qobj</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">t_qpe</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">santiago</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qobj</span><span class="p">)</span>
<span class="n">job_monitor</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;ipython-input-14-9ef98798e543&gt;:10: DeprecationWarning: Passing a Qobj to Backend.run is deprecated and will be removed in a future release. Please pass in circuits or pulse schedules instead.
  job = santiago.run(qobj)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Job Status: job has successfully run
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">t_qpe</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_41_0.png" src="../../../_images/lab8-book_41_0.png" />
</div>
</div>
<div class="cell tag_uses-hardware docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># get the results from the computation</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">answer</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">qpe</span><span class="p">)</span>

<span class="n">plot_histogram</span><span class="p">(</span><span class="n">answer</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_43_0.png" src="../../../_images/lab8-book_43_0.png" />
</div>
</div>
<p>We can hopefully see that the most likely result is <code class="docutils literal notranslate"><span class="pre">001</span></code> which is the result we would expect from the simulator. Unlike the simulator, there is a probability of measuring something other than <code class="docutils literal notranslate"><span class="pre">001</span></code>, this is due to noise and gate errors in the quantum computer.</p>
</div>
</div>
<div class="section" id="exercises-a-id-exercises-a">
<h2>5. Exercises <a id='exercises'></a><a class="headerlink" href="#exercises-a-id-exercises-a" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p>Try the experiments above with different gates (<span class="math notranslate nohighlight">\(\text{CNOT}\)</span>, Controlled-<span class="math notranslate nohighlight">\(S\)</span>, Controlled-<span class="math notranslate nohighlight">\(T^\dagger\)</span>), what results do you expect? What results do you get?</p></li>
<li><p>Try the experiment with a Controlled-<span class="math notranslate nohighlight">\(Y\)</span>-gate, do you get the result you expected? (Hint: Remember to make sure <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> is an eigenstate of <span class="math notranslate nohighlight">\(Y\)</span>!)</p></li>
</ol>
<div class="section" id="exercise-3">
<h3>Exercise 3<a class="headerlink" href="#exercise-3" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>What are the eigenstates for X operator? What are the corresponding eigenvalues?</p></li>
<li><p>Fill in the code below for initializing the target qubit to the eigestate of X gate, the one w/ the positive eigenvalue.</p></li>
<li><p>Run the circuit by running the following cells, calculate <span class="math notranslate nohighlight">\(\theta\)</span> and discuss your results.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qpex</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="c1"># Apply H-Gates to counting qubits:</span>
<span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">qpex</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>

<span class="c1"># Prepare our eigenstate |psi&gt;:</span>


<span class="c1"># Do the controlled-U operations, CNOT:</span>
<span class="n">repetitions</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">counting_qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">repetitions</span><span class="p">):</span>
        <span class="n">qpex</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">counting_qubit</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">repetitions</span> <span class="o">*=</span> <span class="mi">2</span>

<span class="c1"># Do the inverse QFT:</span>
<span class="n">qft_dagger</span><span class="p">(</span><span class="n">qpex</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="c1"># Measure of course!</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">qpex</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>

<span class="n">qpex</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s see the results!</span>
<span class="n">qasm_sim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">)</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">4096</span>
<span class="n">t_qpex</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qpex</span><span class="p">,</span> <span class="n">qasm_sim</span><span class="p">)</span>
<span class="n">qobj</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">t_qpex</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">qasm_sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qobj</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">answer</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>

<span class="n">plot_histogram</span><span class="p">(</span><span class="n">answer</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id3">
<h3>Answer<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>Discuss your results.</p>
</div>
<div class="section" id="exercise-4">
<h3>Exercise 4<a class="headerlink" href="#exercise-4" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Fill in the code below for initializing the target qubit to the eigestate of X gate, the one w/ the negative eigenvalue.</p></li>
<li><p>Run the following cells, calculate <span class="math notranslate nohighlight">\(\theta\)</span> and discuss your results.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qpex</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="c1"># Apply H-Gates to counting qubits:</span>
<span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">qpex</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>

<span class="c1"># Prepare our eigenstate |psi&gt;:</span>


<span class="c1"># Do the controlled-U operations, CNOT:</span>
<span class="n">repetitions</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">counting_qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">repetitions</span><span class="p">):</span>
        <span class="n">qpex</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">counting_qubit</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">repetitions</span> <span class="o">*=</span> <span class="mi">2</span>

<span class="c1"># Do the inverse QFT:</span>
<span class="n">qft_dagger</span><span class="p">(</span><span class="n">qpex</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="c1"># Measure of course!</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">qpex</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>

<span class="n">qpex</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s see the results!</span>
<span class="n">qasm_sim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">)</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">4096</span>
<span class="n">t_qpex</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qpex</span><span class="p">,</span> <span class="n">qasm_sim</span><span class="p">)</span>
<span class="n">qobj</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">t_qpex</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">qasm_sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qobj</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">answer</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>

<span class="n">plot_histogram</span><span class="p">(</span><span class="n">answer</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id4">
<h3>Answer<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>Discuss your results.</p>
</div>
</div>
<div class="section" id="looking-forward-a-id-looking-forward-a">
<h2>6. Looking Forward <a id='looking_forward'></a><a class="headerlink" href="#looking-forward-a-id-looking-forward-a" title="Permalink to this headline">¶</a></h2>
<p>The quantum phase estimation algorithm may seem pointless, since we have to know <span class="math notranslate nohighlight">\(\theta\)</span> to perform the controlled-<span class="math notranslate nohighlight">\(U\)</span> operations on our quantum computer. We will see in later chapters that it is possible to create circuits for which we don’t know <span class="math notranslate nohighlight">\(\theta\)</span>, and for which learning theta can tell us something very useful (most famously how to factor a number!)</p>
</div>
<div class="section" id="references-a-id-references-a">
<h2>7. References <a id='references'></a><a class="headerlink" href="#references-a-id-references-a" title="Permalink to this headline">¶</a></h2>
<p>[1] Michael A. Nielsen and Isaac L. Chuang. 2011. Quantum Computation and Quantum Information: 10th Anniversary Edition (10th ed.). Cambridge University Press, New York, NY, USA.</p>
</div>
<div class="section" id="contributors-a-id-contributors-a">
<h2>8. Contributors <a id='contributors'></a><a class="headerlink" href="#contributors-a-id-contributors-a" title="Permalink to this headline">¶</a></h2>
<p>03/20/2020 — Hwajung Kang (&#64;HwajungKang) — Fixed inconsistencies with qubit ordering</p>
<p>Shor’s algorithm is famous for factoring integers in polynomial time. Since the best-known classical algorithm requires superpolynomial time to factor the product of two primes, the widely used cryptosystem, RSA, relies on factoring being impossible for large enough integers.</p>
<p>In this chapter we will focus on the quantum part of Shor’s algorithm, which actually solves the problem of <em>period finding</em>. Since a factoring problem can be turned into a period finding problem in polynomial time, an efficient period finding algorithm can be used to factor integers efficiently too. For now its enough to show that if we can compute the period of <span class="math notranslate nohighlight">\(a^x\bmod N\)</span> efficiently, then we can also efficiently factor. Since period finding is a worthy problem in its own right, we will first solve this, then discuss how this can be used to factor in section 5.</p>
<div class="cell tag_thebelab-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">Aer</span><span class="p">,</span> <span class="n">transpile</span><span class="p">,</span> <span class="n">assemble</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">gcd</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">randint</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">Fraction</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Imports Successful&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Imports Successful
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="the-problem-period-finding">
<h2>1. The Problem: Period Finding<a class="headerlink" href="#the-problem-period-finding" title="Permalink to this headline">¶</a></h2>
<p>Let’s look at the periodic function:</p>
<div class="math notranslate nohighlight">
\[ f(x) = a^x \bmod{N}\]</div>
<details>
    <summary>Reminder: Modulo &amp; Modular Arithmetic (Click here to expand)</summary>
<p>The modulo operation (abbreviated to ‘mod’) simply means to find the remainder when dividing one number by another. For example:</p>
<div class="math notranslate nohighlight">
\[ 17 \bmod 5 = 2 \]</div>
<p>Since <span class="math notranslate nohighlight">\(17 \div 5 = 3\)</span> with remainder <span class="math notranslate nohighlight">\(2\)</span>. (i.e. <span class="math notranslate nohighlight">\(17 = (3\times 5) + 2\)</span>). In Python, the modulo operation is denoted through the <code>%</code> symbol.</p>
<p>This behaviour is used in <a href="https://en.wikipedia.org/wiki/Modular_arithmetic">modular arithmetic</a>, where numbers ‘wrap round’ after reaching a certain value (the modulus). Using modular arithmetic, we could write:</p>
<div class="math notranslate nohighlight">
\[ 17 = 2 \pmod 5\]</div>
<p>Note that here the <span class="math notranslate nohighlight">\(\pmod 5\)</span> applies to the entire equation (since it is in parenthesis), unlike the equation above where it only applied to the left-hand side of the equation.</p>
</details>
<p>where <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(N\)</span> are positive integers, <span class="math notranslate nohighlight">\(a\)</span> is less than <span class="math notranslate nohighlight">\(N\)</span>, and they have no common factors. The period, or order (<span class="math notranslate nohighlight">\(r\)</span>), is the smallest (non-zero) integer such that:</p>
<div class="math notranslate nohighlight">
\[a^r \bmod N = 1 \]</div>
<p>We can see an example of this function plotted on the graph below. Note that the lines between points are to help see the periodicity and do not represent the intermediate values between the x-markers.</p>
<div class="cell tag_remove_input docutils container">
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_61_0.png" src="../../../_images/lab8-book_61_0.png" />
</div>
</div>
</div>
<div class="section" id="the-solution">
<h2>2. The Solution<a class="headerlink" href="#the-solution" title="Permalink to this headline">¶</a></h2>
<p>Shor’s solution was to use <span class="xref myst">quantum phase estimation</span> on the unitary operator:</p>
<div class="math notranslate nohighlight">
\[ U|y\rangle \equiv |ay \bmod N \rangle \]</div>
<p>To see how this is helpful, let’s work out what an eigenstate of U might look like. If we started in the state <span class="math notranslate nohighlight">\(|1\rangle\)</span>, we can see that each successive application of U will multiply the state of our register by <span class="math notranslate nohighlight">\(a \pmod N\)</span>, and after <span class="math notranslate nohighlight">\(r\)</span> applications we will arrive at the state <span class="math notranslate nohighlight">\(|1\rangle\)</span> again. For example with <span class="math notranslate nohighlight">\(a = 3\)</span> and <span class="math notranslate nohighlight">\(N = 35\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
U|1\rangle &amp;= |3\rangle &amp; \\
U^2|1\rangle &amp;= |9\rangle \\
U^3|1\rangle &amp;= |27\rangle \\
&amp; \vdots \\
U^{(r-1)}|1\rangle &amp;= |12\rangle \\
U^r|1\rangle &amp;= |1\rangle 
\end{aligned}\end{split}\]</div>
<div class="cell tag_remove_input docutils container">
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_63_0.png" src="../../../_images/lab8-book_63_0.png" />
</div>
</div>
<div class="section" id="exercise-5">
<h3>Exercise 5<a class="headerlink" href="#exercise-5" title="Permalink to this headline">¶</a></h3>
<p>Let’s say the number we would like to factor is <span class="math notranslate nohighlight">\(N=21\)</span> and we chose <span class="math notranslate nohighlight">\(a=11\)</span>. So we defined <span class="math notranslate nohighlight">\(O|y\rangle = |11\times y \ mod \ 21 \rangle\)</span>. What are the results of:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(O|1\rangle = ?\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(O^2|1\rangle = ?\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(O^3|1\rangle = ?\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(O^4|1\rangle = ?\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(O^5|1\rangle = ?\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(O^6|1\rangle = ?\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(O^7|1\rangle = ?\)</span></p></li>
<li><p>According to your results, what is the period <span class="math notranslate nohighlight">\(r\)</span> such that <span class="math notranslate nohighlight">\(a^r = 1 \ mod \ 21 \)</span>.</p></li>
</ul>
</div>
<div class="section" id="id5">
<h3>Answer<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>?</p>
<p>So a superposition of the states in this cycle (<span class="math notranslate nohighlight">\(|u_0\rangle\)</span>) would be an eigenstate of <span class="math notranslate nohighlight">\(U\)</span>:</p>
<div class="math notranslate nohighlight">
\[|u_0\rangle = \tfrac{1}{\sqrt{r}}\sum_{k=0}^{r-1}{|a^k \bmod N\rangle} \]</div>
<details>
    <summary>Click to Expand: Example with $a = 3$ and $N=35$</summary>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
|u_0\rangle &amp;= \tfrac{1}{\sqrt{12}}(|1\rangle + |3\rangle + |9\rangle \dots + |4\rangle + |12\rangle) \\[10pt]
U|u_0\rangle &amp;= \tfrac{1}{\sqrt{12}}(U|1\rangle + U|3\rangle + U|9\rangle \dots + U|4\rangle + U|12\rangle) \\[10pt]
 &amp;= \tfrac{1}{\sqrt{12}}(|3\rangle + |9\rangle + |27\rangle \dots + |12\rangle + |1\rangle) \\[10pt]
 &amp;= |u_0\rangle
\end{aligned}\end{split}\]</div>
</details>
</div>
<div class="section" id="exercise-6">
<h3>Exercise 6<a class="headerlink" href="#exercise-6" title="Permalink to this headline">¶</a></h3>
<p>According to your result from previous example, write down <span class="math notranslate nohighlight">\(|o_0 \rangle\)</span> explicitly for <span class="math notranslate nohighlight">\(a=11\)</span> and <span class="math notranslate nohighlight">\(N=21\)</span> where:
$<span class="math notranslate nohighlight">\(|o_0\rangle = \tfrac{1}{\sqrt{r}}\sum_{k=0}^{r-1}{|a^k \bmod N\rangle} \)</span>$</p>
<p>What is the eigenvalue of <span class="math notranslate nohighlight">\(O\)</span> corresponding to <span class="math notranslate nohighlight">\(|o_0\rangle\)</span> ? That is, given <span class="math notranslate nohighlight">\(O|o_0\rangle = \lambda |o_0 \rangle\)</span>, what is <span class="math notranslate nohighlight">\(\lambda\)</span>?</p>
</div>
<div class="section" id="id6">
<h3>Answer<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>?</p>
<p>This eigenstate has an eigenvalue of 1, which isn’t very interesting. A more interesting eigenstate could be one in which the phase is different for each of these computational basis states. Specifically, let’s look at the case in which the phase of the <span class="math notranslate nohighlight">\(k\)</span>th state is proportional to <span class="math notranslate nohighlight">\(k\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
|u_1\rangle &amp;= \tfrac{1}{\sqrt{r}}\sum_{k=0}^{r-1}{e^{-\tfrac{2\pi i k}{r}}|a^k \bmod N\rangle}\\[10pt]
U|u_1\rangle &amp;= e^{\tfrac{2\pi i}{r}}|u_1\rangle 
\end{aligned}
\end{split}\]</div>
<details>
    <summary>Click to Expand: Example with $a = 3$ and $N=35$</summary>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
|u_1\rangle &amp;= \tfrac{1}{\sqrt{12}}(|1\rangle + e^{-\tfrac{2\pi i}{12}}|3\rangle + e^{-\tfrac{4\pi i}{12}}|9\rangle \dots + e^{-\tfrac{20\pi i}{12}}|4\rangle + e^{-\tfrac{22\pi i}{12}}|12\rangle) \\[10pt]
U|u_1\rangle &amp;= \tfrac{1}{\sqrt{12}}(|3\rangle + e^{-\tfrac{2\pi i}{12}}|9\rangle + e^{-\tfrac{4\pi i}{12}}|27\rangle \dots + e^{-\tfrac{20\pi i}{12}}|12\rangle + e^{-\tfrac{22\pi i}{12}}|1\rangle) \\[10pt]
U|u_1\rangle &amp;= e^{\tfrac{2\pi i}{12}}\cdot\tfrac{1}{\sqrt{12}}(e^{\tfrac{-2\pi i}{12}}|3\rangle + e^{-\tfrac{4\pi i}{12}}|9\rangle + e^{-\tfrac{6\pi i}{12}}|27\rangle \dots + e^{-\tfrac{22\pi i}{12}}|12\rangle + e^{-\tfrac{24\pi i}{12}}|1\rangle) \\[10pt]
U|u_1\rangle &amp;= e^{\tfrac{2\pi i}{12}}|u_1\rangle
\end{aligned}\end{split}\]</div>
<p>(We can see <span class="math notranslate nohighlight">\(r = 12\)</span> appears in the denominator of the phase.)</p>
</details>
</div>
<div class="section" id="exercise-7">
<h3>Exercise 7<a class="headerlink" href="#exercise-7" title="Permalink to this headline">¶</a></h3>
<p>According to your result from previous example, write down <span class="math notranslate nohighlight">\(|o_1 \rangle\)</span> explicitly for <span class="math notranslate nohighlight">\(a=11\)</span> and <span class="math notranslate nohighlight">\(N=21\)</span> where:
$<span class="math notranslate nohighlight">\(|o_1\rangle = \tfrac{1}{\sqrt{r}}\sum_{k=0}^{r-1}{e^{-\tfrac{2\pi i k}{r}}|a^k \bmod N\rangle} \)</span>$</p>
<p>What is the eigenvalue corresponding to <span class="math notranslate nohighlight">\(|o_1\rangle\)</span> ? That is, given <span class="math notranslate nohighlight">\(O|o_1\rangle = \lambda |o_1 \rangle\)</span>, what is <span class="math notranslate nohighlight">\(\lambda\)</span>?</p>
</div>
<div class="section" id="id7">
<h3>Answer<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>?</p>
<p>This is a particularly interesting eigenvalue as it contains <span class="math notranslate nohighlight">\(r\)</span>. In fact, <span class="math notranslate nohighlight">\(r\)</span> has to be included to make sure the phase differences between the <span class="math notranslate nohighlight">\(r\)</span> computational basis states are equal. This is not the only eigenstate with this behaviour; to generalise this further, we can multiply an integer, <span class="math notranslate nohighlight">\(s\)</span>, to this phase difference, which will show up in our eigenvalue:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
|u_s\rangle &amp;= \tfrac{1}{\sqrt{r}}\sum_{k=0}^{r-1}{e^{-\tfrac{2\pi i s k}{r}}|a^k \bmod N\rangle}\\[10pt]
U|u_s\rangle &amp;= e^{\tfrac{2\pi i s}{r}}|u_s\rangle 
\end{aligned}
\end{split}\]</div>
<details>
    <summary>Click to Expand: Example with $a = 3$ and $N=35$</summary>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
|u_s\rangle &amp;= \tfrac{1}{\sqrt{12}}(|1\rangle + e^{-\tfrac{2\pi i s}{12}}|3\rangle + e^{-\tfrac{4\pi i s}{12}}|9\rangle \dots + e^{-\tfrac{20\pi i s}{12}}|4\rangle + e^{-\tfrac{22\pi i s}{12}}|12\rangle) \\[10pt]
U|u_s\rangle &amp;= \tfrac{1}{\sqrt{12}}(|3\rangle + e^{-\tfrac{2\pi i s}{12}}|9\rangle + e^{-\tfrac{4\pi i s}{12}}|27\rangle \dots + e^{-\tfrac{20\pi i s}{12}}|12\rangle + e^{-\tfrac{22\pi i s}{12}}|1\rangle) \\[10pt]
U|u_s\rangle &amp;= e^{\tfrac{2\pi i s}{12}}\cdot\tfrac{1}{\sqrt{12}}(e^{-\tfrac{2\pi i s}{12}}|3\rangle + e^{-\tfrac{4\pi i s}{12}}|9\rangle + e^{-\tfrac{6\pi i s}{12}}|27\rangle \dots + e^{-\tfrac{22\pi i s}{12}}|12\rangle + e^{-\tfrac{24\pi i s}{12}}|1\rangle) \\[10pt]
U|u_s\rangle &amp;= e^{\tfrac{2\pi i s}{12}}|u_s\rangle
\end{aligned}\end{split}\]</div>
</details>
</div>
<div class="section" id="exercise-8">
<h3>Exercise 8<a class="headerlink" href="#exercise-8" title="Permalink to this headline">¶</a></h3>
<p>According to your result from previous example, write down <span class="math notranslate nohighlight">\(|o_s \rangle\)</span> explicitly for <span class="math notranslate nohighlight">\(a=11\)</span> and <span class="math notranslate nohighlight">\(N=21\)</span> where:
$<span class="math notranslate nohighlight">\(|o_s\rangle = \tfrac{1}{\sqrt{r}}\sum_{k=0}^{r-1}{e^{-\tfrac{2\pi i k}{r}}|a^k \bmod N\rangle} \)</span>$</p>
<p>What is the eigenvalue corresponding to <span class="math notranslate nohighlight">\(|o_s\rangle\)</span> ? That is, given <span class="math notranslate nohighlight">\(O|o_s\rangle = \lambda |o_s \rangle\)</span>, what is <span class="math notranslate nohighlight">\(\lambda\)</span>?</p>
</div>
<div class="section" id="id8">
<h3>Answer<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>?</p>
<p>We now have a unique eigenstate for each integer value of <span class="math notranslate nohighlight">\(s\)</span> where $<span class="math notranslate nohighlight">\(0 \leq s \leq r-1\)</span><span class="math notranslate nohighlight">\(. Very conveniently, if we sum up all these eigenstates, the different phases cancel out all computational basis states except \)</span>|1\rangle$:</p>
<div class="math notranslate nohighlight">
\[ \tfrac{1}{\sqrt{r}}\sum_{s=0}^{r-1} |u_s\rangle = |1\rangle\]</div>
<details>
    <summary>Click to Expand: Example with $a = 7$ and $N=15$</summary>
<p>For this, we will look at a smaller example where <span class="math notranslate nohighlight">\(a = 7\)</span> and <span class="math notranslate nohighlight">\(N=15\)</span>. In this case <span class="math notranslate nohighlight">\(r=4\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\tfrac{1}{2}(\quad|u_0\rangle &amp;= \tfrac{1}{2}(|1\rangle \hphantom{e^{-\tfrac{2\pi i}{12}}}+ |7\rangle \hphantom{e^{-\tfrac{12\pi i}{12}}} + |4\rangle \hphantom{e^{-\tfrac{12\pi i}{12}}} + |13\rangle)\dots \\[10pt]
+ |u_1\rangle &amp;= \tfrac{1}{2}(|1\rangle + e^{-\tfrac{2\pi i}{4}}|7\rangle + e^{-\tfrac{\hphantom{1}4\pi i}{4}}|4\rangle + e^{-\tfrac{\hphantom{1}6\pi i}{4}}|13\rangle)\dots \\[10pt]
+ |u_2\rangle &amp;= \tfrac{1}{2}(|1\rangle + e^{-\tfrac{4\pi i}{4}}|7\rangle + e^{-\tfrac{\hphantom{1}8\pi i}{4}}|4\rangle + e^{-\tfrac{12\pi i}{4}}|13\rangle)\dots \\[10pt]
+ |u_3\rangle &amp;= \tfrac{1}{2}(|1\rangle + e^{-\tfrac{6\pi i}{4}}|7\rangle + e^{-\tfrac{12\pi i}{4}}|4\rangle + e^{-\tfrac{18\pi i}{4}}|13\rangle)\quad) = |1\rangle \\[10pt]
\end{aligned}\end{split}\]</div>
</details>
<p><img alt="image-2.png" src="PHYS343/hands-ons/hands-on-8/attachment:image-2.png" /></p>
<p>Since the computational basis state <span class="math notranslate nohighlight">\(|1\rangle\)</span> is a superposition of these eigenstates, which means if we do QPE on <span class="math notranslate nohighlight">\(U\)</span> using the state <span class="math notranslate nohighlight">\(|1\rangle\)</span>, we will measure a phase:</p>
<div class="math notranslate nohighlight">
\[\phi = \frac{s}{r}\]</div>
<p>!! Remember when we measure the state will collapse to one of the eigenstates <span class="math notranslate nohighlight">\(|u_s\rangle\)</span> and the corresponding eigenvalue is <span class="math notranslate nohighlight">\(e^{2\pi s / r}\)</span>. The quantum phase estimation algortihm yields the value <span class="math notranslate nohighlight">\(\theta\)</span> in <span class="math notranslate nohighlight">\(e^{2\pi \theta}\)</span>. Therefore, we will get the value <span class="math notranslate nohighlight">\(\frac{s}{r}\)</span>.</p>
<p>Where <span class="math notranslate nohighlight">\(s\)</span> is a random integer between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(r-1\)</span>. We finally use the <a class="reference external" href="https://en.wikipedia.org/wiki/Continued_fraction">continued fractions</a> algorithm on <span class="math notranslate nohighlight">\(\phi\)</span> to find <span class="math notranslate nohighlight">\(r\)</span>. The circuit diagram looks like this (note that this diagram uses Qiskit’s qubit ordering convention):</p>
<p><img alt="image-3.png" src="PHYS343/hands-ons/hands-on-8/attachment:image-3.png" /></p>
<p>We will next demonstrate Shor’s algorithm using Qiskit’s simulators. For this demonstration we will provide the circuits for <span class="math notranslate nohighlight">\(U\)</span> without explanation, but in section 4 we will discuss how circuits for <span class="math notranslate nohighlight">\(U^{2^j}\)</span> can be constructed efficiently.</p>
</div>
<div class="section" id="exercise-9">
<h3>Exercise 9<a class="headerlink" href="#exercise-9" title="Permalink to this headline">¶</a></h3>
<p>If you did the previous exercises, then you know the value of <span class="math notranslate nohighlight">\(r\)</span>. We also know <span class="math notranslate nohighlight">\(0 \leq s \leq r-1\)</span>. Than what are the possible values for <span class="math notranslate nohighlight">\(\frac{s}{r}\)</span> when <span class="math notranslate nohighlight">\(a=11\)</span> and <span class="math notranslate nohighlight">\(N=21\)</span>?</p>
</div>
<div class="section" id="id9">
<h3>Answer<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>?</p>
</div>
</div>
<div class="section" id="qiskit-implementation">
<h2>3. Qiskit Implementation<a class="headerlink" href="#qiskit-implementation" title="Permalink to this headline">¶</a></h2>
<p>In this example we will solve the period finding problem for <span class="math notranslate nohighlight">\(a=7\)</span> and <span class="math notranslate nohighlight">\(N=15\)</span>. We provide the circuits for <span class="math notranslate nohighlight">\(U\)</span> where:</p>
<div class="math notranslate nohighlight">
\[U|y\rangle = |ay\bmod 15\rangle \]</div>
<p>without explanation. To create <span class="math notranslate nohighlight">\(U^x\)</span>, we will simply repeat the circuit <span class="math notranslate nohighlight">\(x\)</span> times. In the next section we will discuss a general method for creating these circuits efficiently. The function <code class="docutils literal notranslate"><span class="pre">c_amod15</span></code> returns the controlled-U gate for <code class="docutils literal notranslate"><span class="pre">a</span></code>, repeated <code class="docutils literal notranslate"><span class="pre">power</span></code> times.</p>
<div class="cell tag_thebelab-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">c_amod15</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">power</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Controlled multiplication by a mod 15&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;a&#39; must be 2,7,8,11 or 13&quot;</span><span class="p">)</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>        
    <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">power</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">13</span><span class="p">]:</span>
            <span class="n">U</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">U</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">U</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]:</span>
            <span class="n">U</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">U</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">U</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">11</span><span class="p">:</span>
            <span class="n">U</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">U</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">U</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">to_gate</span><span class="p">()</span>
    <span class="n">U</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%i</span><span class="s2">^</span><span class="si">%i</span><span class="s2"> mod 15&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span>
    <span class="n">c_U</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">control</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">c_U</span>
</pre></div>
</div>
</div>
</div>
<p>We will use 8 counting qubits:</p>
<div class="cell tag_thebelab-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Specify variables</span>
<span class="n">n_count</span> <span class="o">=</span> <span class="mi">8</span>  <span class="c1"># number of counting qubits</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">7</span>
</pre></div>
</div>
</div>
</div>
<p>We also import the circuit for the QFT (you can read more about the QFT in the <a class="reference external" href="./quantum-fourier-transform.html#generalqft">quantum Fourier transform chapter</a>):</p>
<div class="cell tag_thebelab-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">qft_dagger</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;n-qubit QFTdagger the first n qubits in circ&quot;&quot;&quot;</span>
    <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="c1"># Don&#39;t forget the Swaps!</span>
    <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">qubit</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
            <span class="n">qc</span><span class="o">.</span><span class="n">cp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">m</span><span class="p">)),</span> <span class="n">m</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;QFT†&quot;</span>
    <span class="k">return</span> <span class="n">qc</span>
</pre></div>
</div>
</div>
</div>
<p>With these building blocks we can easily construct the circuit for Shor’s algorithm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create QuantumCircuit with n_count counting qubits</span>
<span class="c1"># plus 4 qubits for U to act on</span>
<span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">n_count</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">n_count</span><span class="p">)</span>

<span class="c1"># Initialise counting qubits</span>
<span class="c1"># in state |+&gt;</span>
<span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_count</span><span class="p">):</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    
<span class="c1"># And auxiliary register in state |1&gt;</span>
<span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="n">n_count</span><span class="p">)</span>

<span class="c1"># Do controlled-U operations</span>
<span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_count</span><span class="p">):</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_amod15</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="n">q</span><span class="p">),</span> 
             <span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">n_count</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)])</span>

<span class="c1"># Do inverse-QFT</span>
<span class="n">qc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qft_dagger</span><span class="p">(</span><span class="n">n_count</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_count</span><span class="p">))</span>

<span class="c1"># Measure circuit</span>
<span class="n">qc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_count</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_count</span><span class="p">))</span>
<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">fold</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># -1 means &#39;do not fold&#39; </span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_85_0.png" src="../../../_images/lab8-book_85_0.png" />
</div>
</div>
<p>Let’s see what results we measure:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qasm_sim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">)</span>
<span class="n">t_qc</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">qasm_sim</span><span class="p">)</span>
<span class="n">qobj</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">t_qc</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">qasm_sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qobj</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_87_0.png" src="../../../_images/lab8-book_87_0.png" />
</div>
</div>
<p>Since we have 3 qubits, these results correspond to measured phases of:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rows</span><span class="p">,</span> <span class="n">measured_phases</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
    <span class="n">decimal</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Convert (base 2) string to decimal</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_count</span><span class="p">)</span>  <span class="c1"># Find corresponding eigenvalue</span>
    <span class="n">measured_phases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span>
    <span class="c1"># Add these values to the rows in our table:</span>
    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">output</span><span class="si">}</span><span class="s2">(bin) = </span><span class="si">{</span><span class="n">decimal</span><span class="si">:</span><span class="s2">&gt;3</span><span class="si">}</span><span class="s2">(dec)&quot;</span><span class="p">,</span> 
                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">decimal</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="mi">2</span><span class="o">**</span><span class="n">n_count</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">phase</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">])</span>
<span class="c1"># Print the rows in a table</span>
<span class="n">headers</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Register Output&quot;</span><span class="p">,</span> <span class="s2">&quot;Phase&quot;</span><span class="p">]</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">headers</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>            Register Output           Phase
0  11000000(bin) = 192(dec)  192/256 = 0.75
1  00000000(bin) =   0(dec)    0/256 = 0.00
2  10000000(bin) = 128(dec)  128/256 = 0.50
3  01000000(bin) =  64(dec)   64/256 = 0.25
</pre></div>
</div>
</div>
</div>
<p>We can now use the continued fractions algorithm to attempt to find <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(r\)</span>. Python has this functionality built in: We can use the <code class="docutils literal notranslate"><span class="pre">fractions</span></code> module to turn a float into a <code class="docutils literal notranslate"><span class="pre">Fraction</span></code> object, for example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Fraction</span><span class="p">(</span><span class="mf">0.666</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Fraction(5998794703657501, 9007199254740992)
</pre></div>
</div>
</div>
</div>
<p>Because this gives fractions that return the result exactly (in this case, <code class="docutils literal notranslate"><span class="pre">0.6660000...</span></code>), this can give gnarly results like the one above. We can use the <code class="docutils literal notranslate"><span class="pre">.limit_denominator()</span></code> method to get the fraction that most closely resembles our float, with denominator below a certain value:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get fraction that most closely resembles 0.666</span>
<span class="c1"># with denominator &lt; 15</span>
<span class="n">Fraction</span><span class="p">(</span><span class="mf">0.666</span><span class="p">)</span><span class="o">.</span><span class="n">limit_denominator</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Fraction(2, 3)
</pre></div>
</div>
</div>
</div>
<p>Much nicer! The order (r) must be less than N, so we will set the maximum denominator to be <code class="docutils literal notranslate"><span class="pre">15</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="n">measured_phases</span><span class="p">:</span>
    <span class="n">frac</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span><span class="o">.</span><span class="n">limit_denominator</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">phase</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">frac</span><span class="o">.</span><span class="n">numerator</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">frac</span><span class="o">.</span><span class="n">denominator</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">frac</span><span class="o">.</span><span class="n">denominator</span><span class="p">])</span>
<span class="c1"># Print as a table</span>
<span class="n">headers</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Phase&quot;</span><span class="p">,</span> <span class="s2">&quot;Fraction&quot;</span><span class="p">,</span> <span class="s2">&quot;Guess for r&quot;</span><span class="p">]</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">headers</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>   Phase Fraction  Guess for r
0   0.75      3/4            4
1   0.00      0/1            1
2   0.50      1/2            2
3   0.25      1/4            4
</pre></div>
</div>
</div>
</div>
<p>We can see that two of the measured eigenvalues provided us with the correct result: <span class="math notranslate nohighlight">\(r=4\)</span>, and we can see that Shor’s algorithm has a chance of failing. These bad results are because <span class="math notranslate nohighlight">\(s = 0\)</span>, or because <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(r\)</span> are not coprime and instead of <span class="math notranslate nohighlight">\(r\)</span> we are given a factor of <span class="math notranslate nohighlight">\(r\)</span>. The easiest solution to this is to simply repeat the experiment until we get a satisfying result for <span class="math notranslate nohighlight">\(r\)</span>.</p>
<div class="section" id="quick-exercise">
<h3>Quick Exercise<a class="headerlink" href="#quick-exercise" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Modify the circuit above for values of <span class="math notranslate nohighlight">\(a = 2, 8, 11\)</span> and <span class="math notranslate nohighlight">\(13\)</span>. What results do you get and why?</p></li>
</ul>
</div>
</div>
<div class="section" id="modular-exponentiation">
<h2>4. Modular Exponentiation<a class="headerlink" href="#modular-exponentiation" title="Permalink to this headline">¶</a></h2>
<p>You may have noticed that the method of creating the <span class="math notranslate nohighlight">\(U^{2^j}\)</span> gates by repeating <span class="math notranslate nohighlight">\(U\)</span> grows exponentially with <span class="math notranslate nohighlight">\(j\)</span> and will not result in a polynomial time algorithm. We want a way to create the operator:</p>
<div class="math notranslate nohighlight">
\[ U^{2^j}|y\rangle = |a^{2^j}y \bmod N \rangle \]</div>
<p>that grows polynomially with <span class="math notranslate nohighlight">\(j\)</span>. Fortunately, calculating:</p>
<div class="math notranslate nohighlight">
\[ a^{2^j} \bmod N\]</div>
<p>efficiently is possible. Classical computers can use an algorithm known as <em>repeated squaring</em> to calculate an exponential. In our case, since we are only dealing with exponentials of the form <span class="math notranslate nohighlight">\(2^j\)</span>, the repeated squaring algorithm becomes very simple:</p>
<div class="cell tag_thebelab-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">a2jmodN</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute a^{2^j} (mod N) by repeated squaring&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a2jmodN</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2049</span><span class="p">,</span> <span class="mi">53</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>47
</pre></div>
</div>
</div>
</div>
<p>If an efficient algorithm is possible in Python, then we can use the same algorithm on a quantum computer. Unfortunately, despite scaling polynomially with <span class="math notranslate nohighlight">\(j\)</span>, modular exponentiation circuits are not straightforward and are the bottleneck in Shor’s algorithm. A beginner-friendly implementation can be found in reference [1].</p>
</div>
<div class="section" id="factoring-from-period-finding">
<h2>5. Factoring from Period Finding<a class="headerlink" href="#factoring-from-period-finding" title="Permalink to this headline">¶</a></h2>
<p>Not all factoring problems are difficult; we can spot an even number instantly and know that one of its factors is 2. In fact, there are <a class="reference external" href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf#%5B%7B%22num%22%3A127%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C223%2C0%5D">specific criteria</a> for choosing numbers that are difficult to factor, but the basic idea is to choose the product of two large prime numbers.</p>
<p>A general factoring algorithm will first check to see if there is a shortcut to factoring the integer (is the number even? Is the number of the form <span class="math notranslate nohighlight">\(N = a^b\)</span>?), before using Shor’s period finding for the worst-case scenario. Since we aim to focus on the quantum part of the algorithm, we will jump straight to the case in which N is the product of two primes.</p>
<div class="section" id="example-factoring-15">
<h3>Example: Factoring 15<a class="headerlink" href="#example-factoring-15" title="Permalink to this headline">¶</a></h3>
<p>To see an example of factoring on a small number of qubits, we will factor 15, which we all know is the product of the not-so-large prime numbers 3 and 5.</p>
<div class="cell tag_thebelab-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">15</span>
</pre></div>
</div>
</div>
</div>
<p>The first step is to choose a random number, <span class="math notranslate nohighlight">\(x\)</span>, between <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(N-1\)</span>:</p>
<div class="cell tag_thebelab-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># This is to make sure we get reproduceable results</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>7
</pre></div>
</div>
</div>
</div>
<p>Next we quickly check it isn’t already a non-trivial factor of <span class="math notranslate nohighlight">\(N\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">gcd</span> <span class="c1"># greatest common divisor</span>
<span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1
</pre></div>
</div>
</div>
</div>
<p>Great. Next, we do Shor’s order finding algorithm for <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">7</span></code> and <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">15</span></code>. Remember that the phase we measure will be <span class="math notranslate nohighlight">\(s/r\)</span> where:</p>
<div class="math notranslate nohighlight">
\[ a^r \bmod N = 1 \]</div>
<p>and <span class="math notranslate nohighlight">\(s\)</span> is a random integer between 0 and <span class="math notranslate nohighlight">\(r-1\)</span>.</p>
<div class="cell tag_thebelab-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">qpe_amod15</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">n_count</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">4</span><span class="o">+</span><span class="n">n_count</span><span class="p">,</span> <span class="n">n_count</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_count</span><span class="p">):</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>     <span class="c1"># Initialise counting qubits in state |+&gt;</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="n">n_count</span><span class="p">)</span> <span class="c1"># And auxiliary register in state |1&gt;</span>
    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_count</span><span class="p">):</span> <span class="c1"># Do controlled-U operations</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_amod15</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="n">q</span><span class="p">),</span> 
                 <span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">n_count</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)])</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qft_dagger</span><span class="p">(</span><span class="n">n_count</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_count</span><span class="p">))</span> <span class="c1"># Do inverse-QFT</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_count</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_count</span><span class="p">))</span>
    <span class="c1"># Simulate Results</span>
    <span class="n">qasm_sim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">)</span>
    <span class="c1"># Setting memory=True below allows us to see a list of each sequential reading</span>
    <span class="n">t_qc</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">qasm_sim</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">t_qc</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">qasm_sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qobj</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
    <span class="n">readings</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_memory</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Register Reading: &quot;</span> <span class="o">+</span> <span class="n">readings</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">readings</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_count</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Corresponding Phase: </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">phase</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">phase</span>
</pre></div>
</div>
</div>
</div>
<p>From this phase, we can easily find a guess for <span class="math notranslate nohighlight">\(r\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">phase</span> <span class="o">=</span> <span class="n">qpe_amod15</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1"># Phase = s/r</span>
<span class="n">Fraction</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span><span class="o">.</span><span class="n">limit_denominator</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span> <span class="c1"># Denominator should (hopefully!) tell us r</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Register Reading: 01000000
Corresponding Phase: 0.250000
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Fraction(1, 4)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">frac</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span><span class="o">.</span><span class="n">limit_denominator</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="n">s</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">frac</span><span class="o">.</span><span class="n">numerator</span><span class="p">,</span> <span class="n">frac</span><span class="o">.</span><span class="n">denominator</span>
<span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4
</pre></div>
</div>
</div>
</div>
<p>Now we have <span class="math notranslate nohighlight">\(r\)</span>, we might be able to use this to find a factor of <span class="math notranslate nohighlight">\(N\)</span>. Since:</p>
<div class="math notranslate nohighlight">
\[a^r \bmod N = 1 \]</div>
<p>then:</p>
<div class="math notranslate nohighlight">
\[(a^r - 1) \bmod N = 0 \]</div>
<p>which mean <span class="math notranslate nohighlight">\(N\)</span> must divide <span class="math notranslate nohighlight">\(a^r-1\)</span>. And if <span class="math notranslate nohighlight">\(r\)</span> is also even, then we can write:</p>
<div class="math notranslate nohighlight">
\[a^r -1 = (a^{r/2}-1)(a^{r/2}+1)\]</div>
<p>(if <span class="math notranslate nohighlight">\(r\)</span> is not even, we cannot go further and must try again with a different value for <span class="math notranslate nohighlight">\(a\)</span>). There is then a high probability that the greatest common divisor of <span class="math notranslate nohighlight">\(N\)</span> and either <span class="math notranslate nohighlight">\(a^{r/2}-1\)</span>, or <span class="math notranslate nohighlight">\(a^{r/2}+1\)</span> is a proper factor of <span class="math notranslate nohighlight">\(N\)</span> [2]:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#N = p x q</span>
<span class="n">a</span>
<span class="n">r</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">guesses</span> <span class="o">=</span> <span class="p">[</span><span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="p">(</span><span class="n">r</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="p">(</span><span class="n">r</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">guesses</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[3, 5]
</pre></div>
</div>
</div>
</div>
<p>The cell below repeats the algorithm until at least one factor of 15 is found. You should try re-running the cell a few times to see how it behaves.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">11</span>
<span class="n">factor_found</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">attempt</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="ow">not</span> <span class="n">factor_found</span><span class="p">:</span>
    <span class="n">attempt</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Attempt </span><span class="si">%i</span><span class="s2">:&quot;</span> <span class="o">%</span> <span class="n">attempt</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">qpe_amod15</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1"># Phase = s/r</span>
    <span class="n">frac</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span><span class="o">.</span><span class="n">limit_denominator</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="c1"># Denominator should (hopefully!) tell us r</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">frac</span><span class="o">.</span><span class="n">denominator</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result: r = </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">r</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">phase</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Guesses for factors are gcd(x^{r/2} ±1 , 15)</span>
        <span class="n">guesses</span> <span class="o">=</span> <span class="p">[</span><span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="p">(</span><span class="n">r</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="p">(</span><span class="n">r</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Guessed Factors: </span><span class="si">%i</span><span class="s2"> and </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">guesses</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">guesses</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">guess</span> <span class="ow">in</span> <span class="n">guesses</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">guess</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">N</span> <span class="o">%</span> <span class="n">guess</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Check to see if guess is a factor</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;*** Non-trivial factor found: </span><span class="si">%i</span><span class="s2"> ***&quot;</span> <span class="o">%</span> <span class="n">guess</span><span class="p">)</span>
                <span class="n">factor_found</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Attempt 1:
Register Reading: 1001
Corresponding Phase: 0.035156
Result: r = 15
Guessed Factors: 5 and 3
*** Non-trivial factor found: 5 ***
*** Non-trivial factor found: 3 ***
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="references">
<h2>6. References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p>Stephane Beauregard, <em>Circuit for Shor’s algorithm using 2n+3 qubits,</em> <a class="reference external" href="https://arxiv.org/abs/quant-ph/0205095">arXiv:quant-ph/0205095</a></p></li>
<li><p>M. Nielsen and I. Chuang, <em>Quantum Computation and Quantum Information,</em> Cambridge Series on Information and the Natural Sciences (Cambridge University Press, Cambridge, 2000). (Page 633)</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">qiskit</span>
<span class="n">qiskit</span><span class="o">.</span><span class="n">__qiskit_version__</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;qiskit-terra&#39;: &#39;0.17.4&#39;, &#39;qiskit-aer&#39;: &#39;0.8.2&#39;, &#39;qiskit-ignis&#39;: &#39;0.6.0&#39;, &#39;qiskit-ibmq-provider&#39;: &#39;0.13.1&#39;, &#39;qiskit-aqua&#39;: &#39;0.9.1&#39;, &#39;qiskit&#39;: &#39;0.26.2&#39;, &#39;qiskit-nature&#39;: &#39;0.1.3&#39;, &#39;qiskit-finance&#39;: None, &#39;qiskit-optimization&#39;: &#39;0.1.0&#39;, &#39;qiskit-machine-learning&#39;: None}
</pre></div>
</div>
</div>
</div>
<p>In this section, we introduce Grover’s algorithm and how it can be used to solve unstructured search problems. We then implement the quantum algorithm using Qiskit, and run on a simulator and device.</p>
</div>
<div class="section" id="id10">
<h2>Contents<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p><a class="reference external" href="#introduction">Introduction</a></p></li>
<li><p><a class="reference external" href="#2qubits">Example: 2 Qubits</a><br />
2.1 <a class="reference external" href="#2qubits-simulation">Simulation</a><br />
2.2 <a class="reference external" href="#2qubits-device">Device</a></p></li>
<li><p><a class="reference external" href="#3qubits">Example: 3 Qubits</a><br />
3.1 <a class="reference external" href="#3qubits-simulation">Simulation</a><br />
3.2 <a class="reference external" href="#3qubits-device">Device</a></p></li>
<li><p><a class="reference external" href="#problems">Problems</a></p></li>
<li><p><a class="reference external" href="#sudoku">Solving Sudoku using Grover’s Algorithm</a></p></li>
<li><p><a class="reference external" href="#references">References</a></p></li>
</ol>
</div>
<div class="section" id="introduction-a-id-introduction-a">
<h2>1. Introduction <a id='introduction'></a><a class="headerlink" href="#introduction-a-id-introduction-a" title="Permalink to this headline">¶</a></h2>
<p>You have likely heard that one of the many advantages a quantum computer has over a classical computer is its superior speed searching databases. Grover’s algorithm demonstrates this capability. This algorithm can speed up an unstructured search problem quadratically, but its uses extend beyond that; it can serve as a general trick or subroutine to obtain quadratic run time improvements for a variety of other algorithms. This is called the amplitude amplification trick.</p>
<div class="section" id="unstructured-search">
<h3>Unstructured Search<a class="headerlink" href="#unstructured-search" title="Permalink to this headline">¶</a></h3>
<p>Suppose you are given a large list of <span class="math notranslate nohighlight">\(N\)</span> items. Among these items there is one item with a unique property that we wish to locate; we will call this one the winner <span class="math notranslate nohighlight">\(w\)</span>. Think of each item in the list as a box of a particular color. Say all items in the list are gray except the winner <span class="math notranslate nohighlight">\(w\)</span>, which is purple.</p>
<p><img alt="image.png" src="PHYS343/hands-ons/hands-on-8/attachment:image.png" /></p>
<p>To find the purple box – the <em>marked item</em> – using classical computation, one would have to check on average <span class="math notranslate nohighlight">\(N/2\)</span> of these boxes, and in the worst case, all <span class="math notranslate nohighlight">\(N\)</span> of them. On a quantum computer, however, we can find the marked item in roughly <span class="math notranslate nohighlight">\(\sqrt{N}\)</span> steps with Grover’s amplitude amplification trick. A quadratic speedup is indeed a substantial time-saver for finding marked items in long lists. Additionally, the algorithm does not use the list’s internal structure, which makes it <em>generic;</em> this is why it immediately provides a quadratic quantum speed-up for many classical problems.</p>
</div>
<div class="section" id="creating-an-oracle">
<h3>Creating an Oracle<a class="headerlink" href="#creating-an-oracle" title="Permalink to this headline">¶</a></h3>
<p>For the examples in this textbook, our ‘database’ is comprised of all the possible computational basis states our qubits can be in. For example, if we have 3 qubits, our list is the states <span class="math notranslate nohighlight">\(|000\rangle, |001\rangle, \dots |111\rangle\)</span> (i.e the states <span class="math notranslate nohighlight">\(|0\rangle \rightarrow |7\rangle\)</span>).</p>
<p>Grover’s algorithm solves oracles that add a negative phase to the solution states. I.e. for any state <span class="math notranslate nohighlight">\(|x\rangle\)</span> in the computational basis:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
U_\omega|x\rangle = \bigg\{
\begin{aligned}
\phantom{-}|x\rangle \quad \text{if} \; x \neq \omega \\
-|x\rangle \quad \text{if} \; x = \omega \\
\end{aligned}
\end{split}\]</div>
<p>This oracle will be a diagonal matrix, where the entry that correspond to the marked item will have a negative phase. For example, if we have three qubits and <span class="math notranslate nohighlight">\(\omega = \text{101}\)</span>, our oracle will have the matrix:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
U_\omega = 
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
\begin{aligned}
\\
\\
\\
\\
\\
\\
\leftarrow \omega = \text{101}\\
\\
\\
\\
\end{aligned}
\end{split}\]</div>
<p>What makes Grover’s algorithm so powerful is how easy it is to convert a problem to an oracle of this form. There are many computational problems in which it’s difficult to <em>find</em> a solution, but relatively easy to <em>verify</em> a solution. For example, we can easily verify a solution to a <a class="reference external" href="https://en.wikipedia.org/wiki/Sudoku">sudoku</a> by checking all the rules are satisfied. For these problems, we can create a function <span class="math notranslate nohighlight">\(f\)</span> that takes a proposed solution <span class="math notranslate nohighlight">\(x\)</span>, and returns <span class="math notranslate nohighlight">\(f(x) = 0\)</span> if <span class="math notranslate nohighlight">\(x\)</span> is not a solution (<span class="math notranslate nohighlight">\(x \neq \omega\)</span>) and <span class="math notranslate nohighlight">\(f(x) = 1\)</span> for a valid solution (<span class="math notranslate nohighlight">\(x = \omega\)</span>). Our oracle can then be described as:</p>
<div class="math notranslate nohighlight">
\[
U_\omega|x\rangle = (-1)^{f(x)}|x\rangle
\]</div>
<p>and the oracle’s matrix will be a diagonal matrix of the form:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
U_\omega = 
\begin{bmatrix}
(-1)^{f(0)} &amp;   0         &amp; \cdots &amp;   0         \\
0           &amp; (-1)^{f(1)} &amp; \cdots &amp;   0         \\
\vdots      &amp;   0         &amp; \ddots &amp; \vdots      \\
0           &amp;   0         &amp; \cdots &amp; (-1)^{f(2^n-1)} \\
\end{bmatrix}
\end{split}\]</div>
<p>If we have our classical function <span class="math notranslate nohighlight">\(f(x)\)</span>, we can convert it to a reversible circuit of the form:
<img alt="image.png" src="PHYS343/hands-ons/hands-on-8/attachment:image.png" />
If we initialise the ‘output’ qubit in the state <span class="math notranslate nohighlight">\(|{-}\rangle\)</span>, the phase kickback effect turns this into a Grover oracle (similar to the workings of the Deutsch-Jozsa oracle):
<img alt="image-2.png" src="PHYS343/hands-ons/hands-on-8/attachment:image-2.png" />
We then ignore the auxiliary (<span class="math notranslate nohighlight">\(|{-}\rangle\)</span>) qubit.</p>
<p>For the next part of this chapter, we aim to teach the core concepts of the algorithm. We will create example oracles where we know <span class="math notranslate nohighlight">\(\omega\)</span> beforehand, and not worry ourselves with whether these oracles are useful or not. At the end of the chapter, we will cover a short example where we create an oracle to solve a problem (sudoku).</p>
</div>
<div class="section" id="amplitude-amplification">
<h3>Amplitude Amplification<a class="headerlink" href="#amplitude-amplification" title="Permalink to this headline">¶</a></h3>
<p>So how does the algorithm work? Before looking at the list of items, we have no idea where the marked item is. Therefore, any guess of its location is as good as any other, which can be expressed in terms of a
uniform superposition: <span class="math notranslate nohighlight">\(|s \rangle = \frac{1}{\sqrt{N}} \sum_{x = 0}^{N -1} | x
\rangle.\)</span></p>
<p>If at this point we were to measure in the standard basis <span class="math notranslate nohighlight">\(\{ | x \rangle \}\)</span>, this superposition would collapse, according to the fifth quantum law, to any one of the basis states with the same probability of <span class="math notranslate nohighlight">\(\frac{1}{N} = \frac{1}{2^n}\)</span>. Our chances of guessing the right value <span class="math notranslate nohighlight">\(w\)</span> is therefore <span class="math notranslate nohighlight">\(1\)</span> in <span class="math notranslate nohighlight">\(2^n\)</span>, as could be expected. Hence, on average we would need to try about <span class="math notranslate nohighlight">\(N/2 = 2^{n-1}\)</span> times to guess the correct item.</p>
<p>Enter the procedure called amplitude amplification, which is how a quantum computer significantly enhances this probability. This procedure stretches out (amplifies) the amplitude of the marked item, which shrinks the other items’ amplitude, so that measuring the final state will return the right item with near-certainty.</p>
<p>This algorithm has a nice geometrical interpretation in terms of two reflections, which generate a rotation in a two-dimensional plane. The only two special states we need to consider are the winner <span class="math notranslate nohighlight">\(| w \rangle\)</span> and the uniform superposition <span class="math notranslate nohighlight">\(| s \rangle\)</span>. These two vectors span a two-dimensional plane in the vector space <span class="math notranslate nohighlight">\(\mathbb{C}^N.\)</span> They are not quite perpendicular because <span class="math notranslate nohighlight">\(| w \rangle\)</span> occurs in the superposition with amplitude <span class="math notranslate nohighlight">\(N^{-1/2}\)</span> as well.
We can, however, introduce an additional state <span class="math notranslate nohighlight">\(|s'\rangle\)</span> that is in the span of these two vectors, which is perpendicular to <span class="math notranslate nohighlight">\(| w \rangle\)</span> and is obtained from <span class="math notranslate nohighlight">\(|s \rangle\)</span> by removing <span class="math notranslate nohighlight">\(| w \rangle\)</span> and
rescaling.</p>
<p><strong>Step 1</strong>: The amplitude amplification procedure starts out in the uniform superposition <span class="math notranslate nohighlight">\(| s \rangle\)</span>, which is easily constructed from <span class="math notranslate nohighlight">\(| s \rangle = H^{\otimes n} | 0 \rangle^n\)</span>.</p>
<p><img alt="image.png" src="PHYS343/hands-ons/hands-on-8/attachment:image.png" /></p>
<p>The left graphic corresponds to the two-dimensional plane spanned by perpendicular vectors <span class="math notranslate nohighlight">\(|w\rangle\)</span> and <span class="math notranslate nohighlight">\(|s'\rangle\)</span> which allows to express the initial state as <span class="math notranslate nohighlight">\(|s\rangle = \sin \theta | w \rangle + \cos \theta | s' \rangle,\)</span> where <span class="math notranslate nohighlight">\(\theta = \arcsin \langle s | w \rangle = \arcsin \frac{1}{\sqrt{N}}\)</span>. The right graphic is a bar graph of the amplitudes of the state <span class="math notranslate nohighlight">\(| s \rangle\)</span>.</p>
<p><strong>Step 2</strong>: We apply the oracle reflection <span class="math notranslate nohighlight">\(U_f\)</span> to the state <span class="math notranslate nohighlight">\(|s\rangle\)</span>.</p>
<p><img alt="image-2.png" src="PHYS343/hands-ons/hands-on-8/attachment:image-2.png" /></p>
<p>Geometrically this corresponds to a reflection of the state <span class="math notranslate nohighlight">\(|s\rangle\)</span> about <span class="math notranslate nohighlight">\(|s'\rangle\)</span>. This transformation means that the amplitude in front of the <span class="math notranslate nohighlight">\(|w\rangle\)</span> state becomes negative, which in turn means that the average amplitude (indicated by a dashed line) has been lowered.</p>
<p><strong>Step 3</strong>: We now apply an additional reflection (<span class="math notranslate nohighlight">\(U_s\)</span>) about the state <span class="math notranslate nohighlight">\(|s\rangle\)</span>: <span class="math notranslate nohighlight">\(U_s = 2|s\rangle\langle s| - \mathbb{1}\)</span>. This transformation maps the state to <span class="math notranslate nohighlight">\(U_s U_f| s \rangle\)</span> and completes the transformation.</p>
<p><img alt="image-3.png" src="PHYS343/hands-ons/hands-on-8/attachment:image-3.png" /></p>
<p>Two reflections always correspond to a rotation. The transformation <span class="math notranslate nohighlight">\(U_s U_f\)</span> rotates the initial state <span class="math notranslate nohighlight">\(|s\rangle\)</span> closer towards the winner <span class="math notranslate nohighlight">\(|w\rangle\)</span>. The action of the reflection <span class="math notranslate nohighlight">\(U_s\)</span> in the amplitude bar diagram can be understood as a reflection about the average amplitude. Since the average amplitude has been lowered by the first reflection, this transformation boosts the negative amplitude of <span class="math notranslate nohighlight">\(|w\rangle\)</span> to roughly three times its original value, while it decreases the other amplitudes. We then go to <strong>step 2</strong> to repeat the application. This procedure will be repeated several times to zero in on the winner.</p>
<p>After <span class="math notranslate nohighlight">\(t\)</span> steps we will be in the state <span class="math notranslate nohighlight">\(|\psi_t\rangle\)</span> where: <span class="math notranslate nohighlight">\(| \psi_t \rangle = (U_s U_f)^t  | s \rangle.\)</span></p>
<p>How many times do we need to apply the rotation? It turns out that roughly <span class="math notranslate nohighlight">\(\sqrt{N}\)</span> rotations suffice. This becomes clear when looking at the amplitudes of the state <span class="math notranslate nohighlight">\(| \psi \rangle\)</span>. We can see that the amplitude of <span class="math notranslate nohighlight">\(| w \rangle\)</span> grows linearly with the number of applications <span class="math notranslate nohighlight">\(\sim t N^{-1/2}\)</span>. However, since we are dealing with amplitudes and not probabilities, the vector space’s dimension enters as a square root. Therefore it is the amplitude, and not just the probability, that is being amplified in this procedure.</p>
<p>In the case that there are multiple solutions, <span class="math notranslate nohighlight">\(M\)</span>, it can be shown that roughly <span class="math notranslate nohighlight">\(\sqrt{(N/M)}\)</span> rotations will suffice.</p>
<p><img alt="image-4.png" src="PHYS343/hands-ons/hands-on-8/attachment:image-4.png" /></p>
</div>
</div>
<div class="section" id="example-2-qubits-a-id-2qubits-a">
<h2>2. Example: 2 Qubits <a id='2qubits'></a><a class="headerlink" href="#example-2-qubits-a-id-2qubits-a" title="Permalink to this headline">¶</a></h2>
<p>Let’s first have a look at the case of Grover’s algorithm for <span class="math notranslate nohighlight">\(N=4\)</span> which is realized with 2 qubits. In this particular case, only <b>one rotation</b> is required to rotate the initial state <span class="math notranslate nohighlight">\(|s\rangle\)</span> to the winner <span class="math notranslate nohighlight">\(|w\rangle\)</span>[3]:</p>
<ol>
    <li>
        Following  the above introduction, in the case $N=4$ we have 
<div class="math notranslate nohighlight">
\[\theta = \arcsin \frac{1}{2} = \frac{\pi}{6}.\]</div>
</li>
<li>
        After $t$ steps, we have $$(U_s U_\omega)^t  | s \rangle = \sin \theta_t | \omega \rangle + \cos \theta_t | s' \rangle ,$$where $$\theta_t = (2t+1)\theta.$$
</li>
<li>
        In order to obtain $| \omega \rangle$ we need $\theta_t = \frac{\pi}{2}$, which with $\theta=\frac{\pi}{6}$ inserted above results to $t=1$. This implies that after $t=1$ rotation the searched element is found.
</li>
</ol>
<p>We will now follow through an example using a specific oracle.</p>
<div class="section" id="oracle-for-lvert-omega-rangle-lvert-11-rangle">
<h3>Oracle for <span class="math notranslate nohighlight">\(\lvert \omega \rangle = \lvert 11 \rangle\)</span><a class="headerlink" href="#oracle-for-lvert-omega-rangle-lvert-11-rangle" title="Permalink to this headline">¶</a></h3>
<p>Let’s look at the case <span class="math notranslate nohighlight">\(\lvert w \rangle = \lvert 11 \rangle\)</span>. The oracle <span class="math notranslate nohighlight">\(U_\omega\)</span> in this case acts as follows:</p>
<div class="math notranslate nohighlight">
\[U_\omega | s \rangle = U_\omega \frac{1}{2}\left( |00\rangle + |01\rangle + |10\rangle + |11\rangle \right) = \frac{1}{2}\left( |00\rangle + |01\rangle + |10\rangle - |11\rangle \right).\]</div>
<p>or:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
U_\omega = 
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; -1 \\
\end{bmatrix}
\end{split}\]</div>
<p>which you may recognise as the controlled-Z gate. Thus, for this example, our oracle is simply the controlled-Z gate:</p>
<p><img alt="image.png" src="PHYS343/hands-ons/hands-on-8/attachment:image.png" /></p>
</div>
<div class="section" id="reflection-u-s">
<h3>Reflection <span class="math notranslate nohighlight">\(U_s\)</span><a class="headerlink" href="#reflection-u-s" title="Permalink to this headline">¶</a></h3>
<p>In order to complete the circuit we need to implement the additional reflection <span class="math notranslate nohighlight">\(U_s = 2|s\rangle\langle s| - \mathbb{1}\)</span>. Since this is a reflection about <span class="math notranslate nohighlight">\(|s\rangle\)</span>, we want to add a negative phase to every state orthogonal to <span class="math notranslate nohighlight">\(|s\rangle\)</span>.</p>
<p>One way we can do this is to use the operation that transforms the state <span class="math notranslate nohighlight">\(|s\rangle \rightarrow |0\rangle\)</span>, which we already know is the Hadamard gate applied to each qubit:</p>
<div class="math notranslate nohighlight">
\[H^{\otimes n}|s\rangle = |0\rangle\]</div>
<p>Then we apply a circuit that adds a negative phase to the states orthogonal to <span class="math notranslate nohighlight">\(|0\rangle\)</span>:</p>
<div class="math notranslate nohighlight">
\[U_0 \frac{1}{2}\left( \lvert 00 \rangle + \lvert 01 \rangle + \lvert 10 \rangle + \lvert 11 \rangle \right) = \frac{1}{2}\left( \lvert 00 \rangle - \lvert 01 \rangle - \lvert 10 \rangle - \lvert 11 \rangle \right)\]</div>
<p>i.e. the signs of each state are flipped except for <span class="math notranslate nohighlight">\(\lvert 00 \rangle\)</span>. As can easily be verified, one way of implementing <span class="math notranslate nohighlight">\(U_0\)</span> is the following circuit:</p>
<p><img alt="image-2.png" src="PHYS343/hands-ons/hands-on-8/attachment:image-2.png" /></p>
<p>Finally, we do the operation that transforms the state <span class="math notranslate nohighlight">\(|0\rangle \rightarrow |s\rangle\)</span> (the H-gate again):</p>
<div class="math notranslate nohighlight">
\[H^{\otimes n}U_0 H^{\otimes n} = U_s\]</div>
<p>The complete circuit for <span class="math notranslate nohighlight">\(U_s\)</span> looks like this:</p>
<p><img alt="image-3.png" src="PHYS343/hands-ons/hands-on-8/attachment:image-3.png" /></p>
</div>
<div class="section" id="full-circuit-for-lvert-w-rangle-11-rangle">
<h3>Full Circuit for <span class="math notranslate nohighlight">\(\lvert w \rangle = |11\rangle\)</span><a class="headerlink" href="#full-circuit-for-lvert-w-rangle-11-rangle" title="Permalink to this headline">¶</a></h3>
<p>Since in the particular case of <span class="math notranslate nohighlight">\(N=4\)</span> only one rotation is required we can combine the above components to build the full circuit for Grover’s algorithm for the case <span class="math notranslate nohighlight">\(\lvert w \rangle = |11\rangle\)</span>:</p>
<p><img alt="image-4.png" src="PHYS343/hands-ons/hands-on-8/attachment:image-4.png" /></p>
</div>
<div class="section" id="id11">
<h3>2.1 Qiskit Implementation<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>We now implement Grover’s algorithm for the above case of 2 qubits for <span class="math notranslate nohighlight">\(\lvert w \rangle = |11\rangle\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#initialization</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># importing Qiskit</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">IBMQ</span><span class="p">,</span> <span class="n">Aer</span><span class="p">,</span> <span class="n">assemble</span><span class="p">,</span> <span class="n">transpile</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">ClassicalRegister</span><span class="p">,</span> <span class="n">QuantumRegister</span>
<span class="kn">from</span> <span class="nn">qiskit.providers.ibmq</span> <span class="kn">import</span> <span class="n">least_busy</span>

<span class="c1"># import basic plot tools</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>
</pre></div>
</div>
</div>
</div>
<p>We start by preparing a quantum circuit with two qubits:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">grover_circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Then we simply need to write out the commands for the circuit depicted above. First, we need to initialize the state <span class="math notranslate nohighlight">\(|s\rangle\)</span>. Let’s create a general function (for any number of qubits) so we can use it again later:</p>
<div class="cell tag_thebelab-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">initialize_s</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">qubits</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply a H-gate to &#39;qubits&#39; in qc&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">qubits</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qc</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grover_circuit</span> <span class="o">=</span> <span class="n">initialize_s</span><span class="p">(</span><span class="n">grover_circuit</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">grover_circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_131_0.png" src="../../../_images/lab8-book_131_0.png" />
</div>
</div>
<p>Apply the Oracle for <span class="math notranslate nohighlight">\(|w\rangle = |11\rangle\)</span>. This oracle is specific to 2 qubits:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grover_circuit</span><span class="o">.</span><span class="n">cz</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Oracle</span>
<span class="n">grover_circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_133_0.png" src="../../../_images/lab8-book_133_0.png" />
</div>
</div>
<p><span id="general_diffuser"></span>We now want to apply the diffuser (<span class="math notranslate nohighlight">\(U_s\)</span>). As with the circuit that initialises <span class="math notranslate nohighlight">\(|s\rangle\)</span>, we’ll create a general diffuser (for any number of qubits) so we can use it later in other problems.</p>
<div class="cell tag_thebelab-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Diffusion operator (U_s)</span>
<span class="n">grover_circuit</span><span class="o">.</span><span class="n">h</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">grover_circuit</span><span class="o">.</span><span class="n">z</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">grover_circuit</span><span class="o">.</span><span class="n">cz</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">grover_circuit</span><span class="o">.</span><span class="n">h</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">grover_circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_135_0.png" src="../../../_images/lab8-book_135_0.png" />
</div>
</div>
<p>This is our finished circuit.</p>
</div>
<div class="section" id="experiment-with-simulators-a-id-2qubits-simulation-a">
<h3>2.1.1 Experiment with Simulators <a id='2qubits-simulation'></a><a class="headerlink" href="#experiment-with-simulators-a-id-2qubits-simulation-a" title="Permalink to this headline">¶</a></h3>
<p>Let’s run the circuit in simulation. First, we can verify that we have the correct statevector:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sv_sim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;statevector_simulator&#39;</span><span class="p">)</span>
<span class="n">qobj</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">grover_circuit</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">sv_sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qobj</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">statevec</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_statevector</span><span class="p">()</span>
<span class="kn">from</span> <span class="nn">qiskit_textbook.tools</span> <span class="kn">import</span> <span class="n">vector2latex</span>
<span class="n">vector2latex</span><span class="p">(</span><span class="n">statevec</span><span class="p">,</span> <span class="n">pretext</span><span class="o">=</span><span class="s2">&quot;|</span><span class="se">\\</span><span class="s2">psi</span><span class="se">\\</span><span class="s2">rangle =&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}\displaystyle 
$$ |\psi\rangle =\begin{bmatrix}
0 \\
0 \\
0 \\
1\end{bmatrix} \end{split}\]</div>
</div>
</div>
<p>As expected, the amplitude of every state that is not <span class="math notranslate nohighlight">\(|11\rangle\)</span> is 0, this means we have a 100% chance of measuring <span class="math notranslate nohighlight">\(|11\rangle\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">grover_circuit</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>

<span class="n">qasm_sim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">)</span>
<span class="n">qobj</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">grover_circuit</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">qasm_sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qobj</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_140_0.png" src="../../../_images/lab8-book_140_0.png" />
</div>
</div>
</div>
<div class="section" id="experiment-with-real-devices-a-id-2qubits-device-a">
<h3>2.1.2 Experiment with Real Devices <a id='2qubits-device'></a><a class="headerlink" href="#experiment-with-real-devices-a-id-2qubits-device-a" title="Permalink to this headline">¶</a></h3>
<p>We can run the circuit a real device as below.</p>
<div class="cell tag_uses-hardware docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load IBM Q account and get the least busy backend device</span>
<span class="n">provider</span> <span class="o">=</span> <span class="n">IBMQ</span><span class="o">.</span><span class="n">load_account</span><span class="p">()</span>
<span class="n">provider</span> <span class="o">=</span> <span class="n">IBMQ</span><span class="o">.</span><span class="n">get_provider</span><span class="p">(</span><span class="s2">&quot;ibm-q-internal&quot;</span><span class="p">)</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">least_busy</span><span class="p">(</span><span class="n">provider</span><span class="o">.</span><span class="n">backends</span><span class="p">(</span><span class="n">filters</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">configuration</span><span class="p">()</span><span class="o">.</span><span class="n">n_qubits</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="ow">and</span> 
                                   <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">configuration</span><span class="p">()</span><span class="o">.</span><span class="n">simulator</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">status</span><span class="p">()</span><span class="o">.</span><span class="n">operational</span><span class="o">==</span><span class="kc">True</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Running on current least busy device: &quot;</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ibmqfactory.load_account:WARNING:2021-06-10 15:05:56,210: Credentials are already in use. The existing account in the session will be replaced.
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Traceback <span class=" -Color -Color-Bold -Color-Bold-Cyan">(most recent call last)</span>:
  File <span class=" -Color -Color-Green">&quot;&lt;ipython-input-75-aa3be89eef35&gt;&quot;</span>, line <span class=" -Color -Color-Green">3</span>, in <span class=" -Color -Color-Magenta">&lt;module&gt;</span>
    provider = IBMQ.get_provider(&quot;ibm-q-internal&quot;)
<span class=" -Color -Color-Bold -Color-Bold-Cyan">  File </span><span class=" -Color -Color-Bold -Color-Bold-Green">&quot;/opt/conda/lib/python3.8/site-packages/qiskit/providers/ibmq/ibmqfactory.py&quot;</span><span class=" -Color -Color-Bold -Color-Bold-Cyan">, line </span><span class=" -Color -Color-Bold -Color-Bold-Green">424</span><span class=" -Color -Color-Bold -Color-Bold-Cyan">, in </span><span class=" -Color -Color-Bold -Color-Bold-Magenta">get_provider</span>
<span class=" -Color -Color-Bold -Color-Bold-Yellow">    raise IBMQProviderError(&#39;No provider matches the specified criteria: &#39;</span>
<span class=" -Color -Color-Bold -Color-Bold-Red">IBMQProviderError:</span> &#39;No provider matches the specified criteria: hub = ibm-q-internal, group = None, project = None&#39;

Use %tb to get the full traceback.
</pre></div>
</div>
<div class="output text_html">
<style>
.button {
  border: none;
  color: white;
  padding: 4px 8px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 12px;
  margin: 4px 2px;
  transition-duration: 0.2s;
  cursor: pointer;
}
.iqx-button {
  background-color: #0f62fe; 
  color: white; 
}
.iqx-button:hover {
  background-color: #0043ce;
  color: white;
}
</style>
<a href="https://stackoverflow.com/search?q=IBMQProviderError: No provider matches the specified criteria: hub = ibm-q-internal, group = None, project = None" target='_blank'><button class='button iqx-button'>Search for solution online</button></a>
</div></div>
</div>
<div class="cell tag_uses-hardware docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Run our circuit on the least busy backend. Monitor the execution of the job in the queue</span>
<span class="kn">from</span> <span class="nn">qiskit.tools.monitor</span> <span class="kn">import</span> <span class="n">job_monitor</span>
<span class="n">transpiled_grover_circuit</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">grover_circuit</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">optimization_level</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qobj</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">transpiled_grover_circuit</span><span class="p">)</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qobj</span><span class="p">)</span>
<span class="n">job_monitor</span><span class="p">(</span><span class="n">job</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_uses-hardware docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the results from the computation</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">answer</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">grover_circuit</span><span class="p">)</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">answer</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We confirm that in the majority of the cases the state <span class="math notranslate nohighlight">\(|11\rangle\)</span> is measured. The other results are due to errors in the quantum computation.</p>
</div>
</div>
<div class="section" id="example-3-qubits-a-id-3qubits-a">
<h2>3. Example: 3 Qubits <a id='3qubits'></a><a class="headerlink" href="#example-3-qubits-a-id-3qubits-a" title="Permalink to this headline">¶</a></h2>
<p>We now go through the example of Grover’s algorithm for 3 qubits with two marked states <span class="math notranslate nohighlight">\(\lvert101\rangle\)</span> and <span class="math notranslate nohighlight">\(\lvert110\rangle\)</span>, following the implementation found in Reference [2]. The quantum circuit to solve the problem using a phase oracle is:</p>
<p><img alt="image.png" src="PHYS343/hands-ons/hands-on-8/attachment:image.png" /></p>
<ol>
<li> 
  Apply Hadamard gates to $3$ qubits initialised to $\lvert000\rangle$ to create a uniform superposition:
  $$\lvert \psi_1 \rangle = \frac{1}{\sqrt{8}} \left( 
    \lvert000\rangle + \lvert001\rangle + \lvert010\rangle + \lvert011\rangle + 
    \lvert100\rangle + \lvert101\rangle + \lvert110\rangle + \lvert111\rangle \right) $$
</li>
<li>
  Mark states $\lvert101\rangle$ and $\lvert110\rangle$ using a phase oracle:
  $$\lvert \psi_2 \rangle = \frac{1}{\sqrt{8}} \left( 
    \lvert000\rangle + \lvert001\rangle + \lvert010\rangle + \lvert011\rangle + 
    \lvert100\rangle - \lvert101\rangle - \lvert110\rangle + \lvert111\rangle \right) $$
</li>
<li>
  Perform the reflection around the average amplitude:
  <ol>
   <li> Apply Hadamard gates to the qubits
      $$\lvert \psi_{3a} \rangle = \frac{1}{2} \left( 
        \lvert000\rangle +\lvert011\rangle +\lvert100\rangle -\lvert111\rangle \right) $$
   </li>
   <li> Apply X gates to the qubits
      $$\lvert \psi_{3b} \rangle = \frac{1}{2} \left( 
        -\lvert000\rangle +\lvert011\rangle +\lvert100\rangle +\lvert111\rangle \right) $$
   </li>
   <li> Apply a doubly controlled Z gate between the 1, 2 (controls) and 3 (target) qubits
      $$\lvert \psi_{3c} \rangle = \frac{1}{2} \left( 
        -\lvert000\rangle +\lvert011\rangle +\lvert100\rangle -\lvert111\rangle \right) $$
   </li>
   <li> Apply X gates to the qubits
      $$\lvert \psi_{3d} \rangle = \frac{1}{2} \left( 
        -\lvert000\rangle +\lvert011\rangle +\lvert100\rangle -\lvert111\rangle \right) $$
   </li>
   <li> Apply Hadamard gates to the qubits
      $$\lvert \psi_{3e} \rangle = \frac{1}{\sqrt{2}} \left( 
        -\lvert101\rangle -\lvert110\rangle \right) $$
   </li>
  </ol>
</li>
<li>
  Measure the $3$ qubits to retrieve states $\lvert101\rangle$ and $\lvert110\rangle$
</li>
</ol>
<p>Note that since there are 2 solutions and 8 possibilities, we will only need to run one iteration (steps 2 &amp; 3).</p>
<div class="section" id="qiskit-implementation-a-id-3qubit-implementation-a">
<h3>3.1 Qiskit Implementation <a id='3qubit-implementation'></a><a class="headerlink" href="#qiskit-implementation-a-id-3qubit-implementation-a" title="Permalink to this headline">¶</a></h3>
<p>We now implement Grover’s algorithm for the above <a class="reference external" href="#3qubits">example</a> for <span class="math notranslate nohighlight">\(3\)</span>-qubits and searching for two marked states <span class="math notranslate nohighlight">\(\lvert101\rangle\)</span> and <span class="math notranslate nohighlight">\(\lvert110\rangle\)</span>. <strong>Note:</strong> Remember that Qiskit orders it’s qubits the opposite way round to this resource, so the circuit drawn will appear flipped about the horizontal.</p>
<p>We create a phase oracle that will mark states <span class="math notranslate nohighlight">\(\lvert101\rangle\)</span> and <span class="math notranslate nohighlight">\(\lvert110\rangle\)</span> as the results (step 1).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cz</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cz</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">oracle_ex3</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">to_gate</span><span class="p">()</span>
<span class="n">oracle_ex3</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;U$_\omega$&quot;</span>
</pre></div>
</div>
</div>
</div>
<p>In the last section, we used a diffuser specific to 2 qubits, in the cell below we will create a general diffuser for any number of qubits.</p>
<details>
<summary> Details: Creating a General Diffuser (click to expand)</summary>
<p>Remember that we can create <span class="math notranslate nohighlight">\(U_s\)</span> from <span class="math notranslate nohighlight">\(U_0\)</span>:</p>
<div class="math notranslate nohighlight">
\[ U_s = H^{\otimes n} U_0 H^{\otimes n} \]</div>
<p>And a multi-controlled-Z gate (<span class="math notranslate nohighlight">\(MCZ\)</span>) inverts the phase of the state <span class="math notranslate nohighlight">\(|11\dots 1\rangle\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
MCZ = 
\begin{bmatrix}
 1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 \\
 0 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \\
 \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
 0 &amp; 0 &amp; 0 &amp; \cdots &amp; -1 \\
\end{bmatrix}
\begin{aligned}
\\
\\
\\
\leftarrow \text{Add negative phase to} \; |11\dots 1\rangle\\
\end{aligned}
\end{split}\]</div>
<p>Applying an X-gate to each qubit performs the transformation:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
|00\dots 0\rangle &amp; \rightarrow |11\dots 1\rangle\\
|11\dots 1\rangle &amp; \rightarrow |00\dots 0\rangle
\end{aligned}
\end{split}\]</div>
<p>So:</p>
<div class="math notranslate nohighlight">
\[ U_0 = - X^{\otimes n} (MCZ) X^{\otimes n} \]</div>
<p>Using these properties together, we can create <span class="math notranslate nohighlight">\(U_s\)</span> using H-gates, X-gates, and a single multi-controlled-Z gate:</p>
<div class="math notranslate nohighlight">
\[ U_s = - H^{\otimes n} U_0 H^{\otimes n} = H^{\otimes n} X^{\otimes n} (MCZ) X^{\otimes n} H^{\otimes n} \]</div>
<p>Note that we can ignore the global phase of -1.</p>
</details><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">diffuser</span><span class="p">(</span><span class="n">nqubits</span><span class="p">):</span>
    <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">nqubits</span><span class="p">)</span>
    <span class="c1"># Apply transformation |s&gt; -&gt; |00..0&gt; (H-gates)</span>
    <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nqubits</span><span class="p">):</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
    <span class="c1"># Apply transformation |00..0&gt; -&gt; |11..1&gt; (X-gates)</span>
    <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nqubits</span><span class="p">):</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
    <span class="c1"># Do multi-controlled-Z gate</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">nqubits</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">mct</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nqubits</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="n">nqubits</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># multi-controlled-toffoli</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">nqubits</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Apply transformation |11..1&gt; -&gt; |00..0&gt;</span>
    <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nqubits</span><span class="p">):</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
    <span class="c1"># Apply transformation |00..0&gt; -&gt; |s&gt;</span>
    <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nqubits</span><span class="p">):</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
    <span class="c1"># We will return the diffuser as a gate</span>
    <span class="n">U_s</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">to_gate</span><span class="p">()</span>
    <span class="n">U_s</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;U$_s$&quot;</span>
    <span class="k">return</span> <span class="n">U_s</span>
</pre></div>
</div>
</div>
</div>
<p>We’ll now put the pieces together, with the creation of a uniform superposition at the start of the circuit and a measurement at the end. Note that since there are 2 solutions and 8 possibilities, we will only need to run one iteration.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">grover_circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">grover_circuit</span> <span class="o">=</span> <span class="n">initialize_s</span><span class="p">(</span><span class="n">grover_circuit</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">grover_circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oracle_ex3</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">grover_circuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diffuser</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">grover_circuit</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>
<span class="n">grover_circuit</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_150_0.png" src="../../../_images/lab8-book_150_0.png" />
</div>
</div>
</div>
<div class="section" id="experiment-with-simulators-a-id-3qubits-simulation-a">
<h3>3.1.1 Experiment with Simulators  <a id='3qubits-simulation'></a><a class="headerlink" href="#experiment-with-simulators-a-id-3qubits-simulation-a" title="Permalink to this headline">¶</a></h3>
<p>We can run the above circuit on the simulator.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qasm_sim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">)</span>
<span class="n">transpiled_grover_circuit</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">grover_circuit</span><span class="p">,</span> <span class="n">qasm_sim</span><span class="p">)</span>
<span class="n">qobj</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">transpiled_grover_circuit</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">qasm_sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qobj</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_152_0.png" src="../../../_images/lab8-book_152_0.png" />
</div>
</div>
<p>As we can see, the algorithm discovers our marked states <span class="math notranslate nohighlight">\(\lvert101\rangle\)</span> and <span class="math notranslate nohighlight">\(\lvert110\rangle\)</span>.</p>
</div>
<div class="section" id="experiment-with-real-devices-a-id-3qubits-device-a">
<h3>3.1.2 Experiment with Real Devices  <a id='3qubits-device'></a><a class="headerlink" href="#experiment-with-real-devices-a-id-3qubits-device-a" title="Permalink to this headline">¶</a></h3>
<p>We can run the circuit on the real device as below.</p>
<div class="cell tag_uses-hardware docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">backend</span> <span class="o">=</span> <span class="n">least_busy</span><span class="p">(</span><span class="n">provider</span><span class="o">.</span><span class="n">backends</span><span class="p">(</span><span class="n">filters</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">configuration</span><span class="p">()</span><span class="o">.</span><span class="n">n_qubits</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="ow">and</span> 
                                   <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">configuration</span><span class="p">()</span><span class="o">.</span><span class="n">simulator</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">status</span><span class="p">()</span><span class="o">.</span><span class="n">operational</span><span class="o">==</span><span class="kc">True</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;least busy backend: &quot;</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>least busy backend:  ibmqx2
</pre></div>
</div>
</div>
</div>
<div class="cell tag_uses-hardware docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Run our circuit on the least busy backend. Monitor the execution of the job in the queue</span>
<span class="kn">from</span> <span class="nn">qiskit.tools.monitor</span> <span class="kn">import</span> <span class="n">job_monitor</span>
<span class="n">transpiled_grover_circuit</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">grover_circuit</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">optimization_level</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qobj</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">transpiled_grover_circuit</span><span class="p">)</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qobj</span><span class="p">)</span>
<span class="n">job_monitor</span><span class="p">(</span><span class="n">job</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;ipython-input-62-258ed4a38608&gt;:5: DeprecationWarning: Passing a Qobj to Backend.run is deprecated and will be removed in a future release. Please pass in circuits or pulse schedules instead.
  job = backend.run(qobj)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Job Status: job has successfully run
</pre></div>
</div>
</div>
</div>
<div class="cell tag_uses-hardware docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the results from the computation</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">answer</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">grover_circuit</span><span class="p">)</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">answer</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_157_0.png" src="../../../_images/lab8-book_157_0.png" />
</div>
</div>
<p>As we can (hopefully) see, there is a higher chance of measuring <span class="math notranslate nohighlight">\(\lvert101\rangle\)</span> and <span class="math notranslate nohighlight">\(\lvert110\rangle\)</span>. The other results are due to errors in the quantum computation.</p>
</div>
</div>
<div class="section" id="problems-a-id-problems-a">
<h2>4. Problems <a id='problems'></a><a class="headerlink" href="#problems-a-id-problems-a" title="Permalink to this headline">¶</a></h2>
<p>The function <code class="docutils literal notranslate"><span class="pre">grover_problem_oracle</span></code> below takes a number of qubits (<code class="docutils literal notranslate"><span class="pre">n</span></code>), and a <code class="docutils literal notranslate"><span class="pre">variant</span></code> and returns an n-qubit oracle. The function will always return the same oracle for the same <code class="docutils literal notranslate"><span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">variant</span></code>. You can see the solutions to each oracle by setting <code class="docutils literal notranslate"><span class="pre">print_solutions</span> <span class="pre">=</span> <span class="pre">True</span></code> when calling <code class="docutils literal notranslate"><span class="pre">grover_problem_oracle</span></code>.</p>
<div class="section" id="exercise-10">
<h3>Exercise 10<a class="headerlink" href="#exercise-10" title="Permalink to this headline">¶</a></h3>
<p>Answer the questions below:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit_textbook.problems</span> <span class="kn">import</span> <span class="n">grover_problem_oracle</span>
<span class="c1">## Example Usage</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">oracle</span> <span class="o">=</span> <span class="n">grover_problem_oracle</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">variant</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># 0th variant of oracle, with n qubits</span>
<span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oracle</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_161_0.png" src="../../../_images/lab8-book_161_0.png" />
</div>
</div>
<ol class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">grover_problem_oracle(4,</span> <span class="pre">variant=2)</span></code> uses 4 qubits and has 1 solution.<br />
a. How many iterations do we need to have a &gt; 90% chance of measuring this solution?<br />
b. Use Grover’s algorithm to find this solution state.
c. What happens if we apply more iterations the the number we calculated in problem 1a above? Why?</p></li>
</ol>
</div>
<div class="section" id="answer-1">
<h3>Answer 1<a class="headerlink" href="#answer-1" title="Permalink to this headline">¶</a></h3>
<p>a-</p>
<p>b- fill in the cells below:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>
<span class="c1"># Initialize a quantum circuit 4 qubits</span>

<span class="c1"># apply H to all qubits</span>

<span class="c1"># append the oracle to your circuit as many times as needed,</span>
<span class="n">oracle</span> <span class="o">=</span> <span class="n">grover_problem_oracle</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">variant</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># draw your circuit here</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Run your circuit on a qasm_simulator</span>

<span class="c1"># get your results and plot them here !</span>
</pre></div>
</div>
</div>
</div>
<p>b - Discuss your results and answer: What happens if we apply more iterations the the number we calculated in problem 1a above? Why?</p>
</div>
</div>
<div class="section" id="important">
<h2>Important<a class="headerlink" href="#important" title="Permalink to this headline">¶</a></h2>
<p>The below part is not included in the course material but you are free to read it!</p>
</div>
<div class="section" id="solving-sudoku-using-grover-s-algorithm-a-id-sudoku-a">
<h2>5. Solving Sudoku using Grover’s Algorithm <a id="sudoku"></a><a class="headerlink" href="#solving-sudoku-using-grover-s-algorithm-a-id-sudoku-a" title="Permalink to this headline">¶</a></h2>
<p>The oracles used throughout this chapter so far have been created with prior knowledge of their solutions. We will now solve a simple problem using Grover’s algorithm, for which we do not necessarily know the solution beforehand. Our problem is a 2×2 binary sudoku, which in our case has two simple rules:</p>
<ul class="simple">
<li><p>No column may contain the same value twice</p></li>
<li><p>No row may contain the same value twice</p></li>
</ul>
<p>If we assign each square in our sudoku to a variable like so:</p>
<p><img alt="image.png" src="PHYS343/hands-ons/hands-on-8/attachment:image.png" /></p>
<p>we want our circuit to output a solution to this sudoku.</p>
<p>Note that, while this approach of using Grover’s algorithm to solve this problem is not practical (you can probably find the solution in your head!), the purpose of this example is to demonstrate the conversion of classical <a class="reference external" href="https://en.wikipedia.org/wiki/Decision_problem">decision problems</a> into oracles for Grover’s algorithm.</p>
<div class="section" id="turning-the-problem-into-a-circuit">
<h3>5.1 Turning the Problem into a Circuit<a class="headerlink" href="#turning-the-problem-into-a-circuit" title="Permalink to this headline">¶</a></h3>
<p>We want to create an oracle that will help us solve this problem, and we will start by creating a circuit that identifies a correct solution. Similar to how we created a classical adder using quantum circuits in <a class="reference external" href="https://qiskit.org/textbook/ch-states/atoms-computation.html"><em>The Atoms of Computation</em></a>, we simply need to create a <em>classical</em> function on a quantum circuit that checks whether the state of our variable bits is a valid solution.</p>
<p>Since we need to check down both columns and across both rows, there are 4 conditions we need to check:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>v0 ≠ v1   # check along top row
v2 ≠ v3   # check along bottom row
v0 ≠ v2   # check down left column
v1 ≠ v3   # check down right column
</pre></div>
</div>
<p>Remember we are comparing classical (computational basis) states. For convenience, we can compile this set of comparisons into a list of clauses:</p>
<div class="cell tag_thebelab-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">clause_list</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
<p>We will assign the value of each variable to a bit in our circuit. To check these clauses computationally, we will use the <code class="docutils literal notranslate"><span class="pre">XOR</span></code> gate (we came across this in the atoms of computation).</p>
<div class="cell tag_thebelab-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">XOR</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Convince yourself that the <code class="docutils literal notranslate"><span class="pre">output0</span></code> bit in the circuit below will only be flipped if <code class="docutils literal notranslate"><span class="pre">input0</span> <span class="pre">≠</span> <span class="pre">input1</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># We will use separate registers to name the bits</span>
<span class="n">in_qubits</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">)</span>
<span class="n">out_qubit</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;output&#39;</span><span class="p">)</span>
<span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">in_qubits</span><span class="p">,</span> <span class="n">out_qubit</span><span class="p">)</span>
<span class="n">XOR</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">in_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">in_qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out_qubit</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_173_0.png" src="../../../_images/lab8-book_173_0.png" />
</div>
</div>
<p>This circuit checks whether <code class="docutils literal notranslate"><span class="pre">input0</span> <span class="pre">==</span> <span class="pre">input1</span></code> and stores the output to <code class="docutils literal notranslate"><span class="pre">output0</span></code>. To check each clause, we repeat this circuit for each pairing in <code class="docutils literal notranslate"><span class="pre">clause_list</span></code> and store the output to a new bit:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create separate registers to name bits</span>
<span class="n">var_qubits</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>  <span class="c1"># variable bits</span>
<span class="n">clause_qubits</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>  <span class="c1"># bits to store clause-checks</span>

<span class="c1"># Create quantum circuit</span>
<span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">var_qubits</span><span class="p">,</span> <span class="n">clause_qubits</span><span class="p">)</span>

<span class="c1"># Use XOR gate to check each clause</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">clause</span> <span class="ow">in</span> <span class="n">clause_list</span><span class="p">:</span>
    <span class="n">XOR</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">clause</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">clause</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">clause_qubits</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_175_0.png" src="../../../_images/lab8-book_175_0.png" />
</div>
</div>
<p>The final state of the bits <code class="docutils literal notranslate"><span class="pre">c0,</span> <span class="pre">c1,</span> <span class="pre">c2,</span> <span class="pre">c3</span></code> will only all be <code class="docutils literal notranslate"><span class="pre">1</span></code> in the case that the assignments of <code class="docutils literal notranslate"><span class="pre">v0,</span> <span class="pre">v1,</span> <span class="pre">v2,</span> <span class="pre">v3</span></code> are a solution to the sudoku. To complete our checking circuit, we want a single bit to be <code class="docutils literal notranslate"><span class="pre">1</span></code> if (and only if) all the clauses are satisfied, this way we can look at just one bit to see if our assignment is a solution. We can do this using a multi-controlled-Toffoli-gate:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create separate registers to name bits</span>
<span class="n">var_qubits</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="n">clause_qubits</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="n">output_qubit</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">)</span>
<span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">var_qubits</span><span class="p">,</span> <span class="n">clause_qubits</span><span class="p">,</span> <span class="n">output_qubit</span><span class="p">)</span>

<span class="c1"># Compute clauses</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">clause</span> <span class="ow">in</span> <span class="n">clause_list</span><span class="p">:</span>
    <span class="n">XOR</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">clause</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">clause</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">clause_qubits</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="c1"># Flip &#39;output&#39; bit if all clauses are satisfied</span>
<span class="n">qc</span><span class="o">.</span><span class="n">mct</span><span class="p">(</span><span class="n">clause_qubits</span><span class="p">,</span> <span class="n">output_qubit</span><span class="p">)</span>

<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_177_0.png" src="../../../_images/lab8-book_177_0.png" />
</div>
</div>
<p>The circuit above takes as input an initial assignment of the bits <code class="docutils literal notranslate"><span class="pre">v0</span></code>, <code class="docutils literal notranslate"><span class="pre">v1</span></code>, <code class="docutils literal notranslate"><span class="pre">v2</span></code> and <code class="docutils literal notranslate"><span class="pre">v3</span></code>, and all other bits should be initialised to <code class="docutils literal notranslate"><span class="pre">0</span></code>. After running the circuit, the state of the <code class="docutils literal notranslate"><span class="pre">out0</span></code> bit tells us if this assignment is a solution or not; <code class="docutils literal notranslate"><span class="pre">out0</span> <span class="pre">=</span> <span class="pre">0</span></code> means the assignment <em>is not</em> a solution, and <code class="docutils literal notranslate"><span class="pre">out0</span> <span class="pre">=</span> <span class="pre">1</span></code> means the assignment <em>is</em> a solution.</p>
<p><strong>Important:</strong> Before you continue, it is important you fully understand this circuit and are convinced it works as stated in the paragraph above.</p>
</div>
<div class="section" id="uncomputing-and-completing-the-oracle">
<h3>5.2 Uncomputing, and Completing the Oracle<a class="headerlink" href="#uncomputing-and-completing-the-oracle" title="Permalink to this headline">¶</a></h3>
<p>We can now turn this checking circuit into a Grover oracle using <a class="reference external" href="https://qiskit.org/textbook/ch-gates/phase-kickback.html">phase kickback</a>. To recap, we have 3 registers:</p>
<ul class="simple">
<li><p>One register which stores our sudoku variables (we’ll say <span class="math notranslate nohighlight">\(x = v_3, v_2, v_1, v_0\)</span>)</p></li>
<li><p>One register that stores our clauses (this starts in the state <span class="math notranslate nohighlight">\(|0000\rangle\)</span> which we’ll abbreviate to <span class="math notranslate nohighlight">\(|0\rangle\)</span>)</p></li>
<li><p>And one qubit (<span class="math notranslate nohighlight">\(|\text{out}_0\rangle\)</span>) that we’ve been using to store the output of our checking circuit.</p></li>
</ul>
<p>To create an oracle, we need our circuit (<span class="math notranslate nohighlight">\(U_\omega\)</span>) to perform the transformation:</p>
<div class="math notranslate nohighlight">
\[
U_\omega|x\rangle|0\rangle|\text{out}_0\rangle = |x\rangle|0\rangle|\text{out}_0\oplus f(x)\rangle
\]</div>
<p>If we set the <code class="docutils literal notranslate"><span class="pre">out0</span></code> qubit to the superposition state <span class="math notranslate nohighlight">\(|{-}\rangle\)</span> we have:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
U_\omega|x\rangle|0\rangle|{-}\rangle 
&amp;= U_\omega|x\rangle|0\rangle\otimes\tfrac{1}{\sqrt{2}}(|0\rangle - |1\rangle)\\
&amp;= |x\rangle|0\rangle\otimes\tfrac{1}{\sqrt{2}}(|0\oplus f(x)\rangle - |1\oplus f(x)\rangle)
\end{aligned}
\end{split}\]</div>
<p>If <span class="math notranslate nohighlight">\(f(x) = 0\)</span>, then we have the state:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
&amp;= |x\rangle|0\rangle\otimes \tfrac{1}{\sqrt{2}}(|0\rangle - |1\rangle)\\
&amp;= |x\rangle|0\rangle|-\rangle\\
\end{aligned}
\end{split}\]</div>
<p>(i.e. no change). But if <span class="math notranslate nohighlight">\(f(x) = 1\)</span> (i.e. <span class="math notranslate nohighlight">\(x = \omega\)</span>), we introduce a negative phase to the <span class="math notranslate nohighlight">\(|{-}\rangle\)</span> qubit:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
&amp;= \phantom{-}|x\rangle|0\rangle\otimes\tfrac{1}{\sqrt{2}}(|1\rangle - |0\rangle)\\
&amp;= \phantom{-}|x\rangle|0\rangle\otimes -\tfrac{1}{\sqrt{2}}(|0\rangle - |1\rangle)\\
&amp;= -|x\rangle|0\rangle|-\rangle\\
\end{aligned}
\end{split}\]</div>
<p>This is a functioning oracle that uses two auxiliary registers in the state <span class="math notranslate nohighlight">\(|0\rangle|{-}\rangle\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
U_\omega|x\rangle|0\rangle|{-}\rangle = \Bigg\{
\begin{aligned}
\phantom{-}|x\rangle|0\rangle|-\rangle \quad \text{for} \; x \neq \omega \\
-|x\rangle|0\rangle|-\rangle \quad \text{for} \; x = \omega \\
\end{aligned}
\end{split}\]</div>
<p>To adapt our checking circuit into a Grover oracle, we need to guarantee the bits in the second register (<code class="docutils literal notranslate"><span class="pre">c</span></code>) are always returned to the state <span class="math notranslate nohighlight">\(|0000\rangle\)</span> after the computation. To do this, we simply repeat the part of the circuit that computes the clauses which guarantees <code class="docutils literal notranslate"><span class="pre">c0</span> <span class="pre">=</span> <span class="pre">c1</span> <span class="pre">=</span> <span class="pre">c2</span> <span class="pre">=</span> <span class="pre">c3</span> <span class="pre">=</span> <span class="pre">0</span></code> after our circuit has run. We call this step <em>‘uncomputation’</em>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">var_qubits</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="n">clause_qubits</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="n">output_qubit</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">)</span>
<span class="n">cbits</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;cbits&#39;</span><span class="p">)</span>
<span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">var_qubits</span><span class="p">,</span> <span class="n">clause_qubits</span><span class="p">,</span> <span class="n">output_qubit</span><span class="p">,</span> <span class="n">cbits</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sudoku_oracle</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">clause_list</span><span class="p">,</span> <span class="n">clause_qubits</span><span class="p">):</span>
    <span class="c1"># Compute clauses</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">clause</span> <span class="ow">in</span> <span class="n">clause_list</span><span class="p">:</span>
        <span class="n">XOR</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">clause</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">clause</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">clause_qubits</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Flip &#39;output&#39; bit if all clauses are satisfied</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">mct</span><span class="p">(</span><span class="n">clause_qubits</span><span class="p">,</span> <span class="n">output_qubit</span><span class="p">)</span>

    <span class="c1"># Uncompute clauses to reset clause-checking bits to 0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">clause</span> <span class="ow">in</span> <span class="n">clause_list</span><span class="p">:</span>
        <span class="n">XOR</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">clause</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">clause</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">clause_qubits</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">sudoku_oracle</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">clause_list</span><span class="p">,</span> <span class="n">clause_qubits</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_179_0.png" src="../../../_images/lab8-book_179_0.png" />
</div>
</div>
<p>In summary, the circuit above performs:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
U_\omega|x\rangle|0\rangle|\text{out}_0\rangle = \Bigg\{
\begin{aligned}
|x\rangle|0\rangle|\text{out}_0\rangle \quad \text{for} \; x \neq \omega \\
|x\rangle|0\rangle\otimes X|\text{out}_0\rangle \quad \text{for} \; x = \omega \\
\end{aligned}
\end{split}\]</div>
<p>and if the initial state of <span class="math notranslate nohighlight">\(|\text{out}_0\rangle = |{-}\rangle\)</span>,:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
U_\omega|x\rangle|0\rangle|{-}\rangle = \Bigg\{
\begin{aligned}
\phantom{-}|x\rangle|0\rangle|-\rangle \quad \text{for} \; x \neq \omega \\
-|x\rangle|0\rangle|-\rangle \quad \text{for} \; x = \omega \\
\end{aligned}
\end{split}\]</div>
</div>
<div class="section" id="the-full-algorithm">
<h3>5.3 The Full Algorithm<a class="headerlink" href="#the-full-algorithm" title="Permalink to this headline">¶</a></h3>
<p>All that’s left to do now is to put this oracle into Grover’s algorithm!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">var_qubits</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="n">clause_qubits</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="n">output_qubit</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">)</span>
<span class="n">cbits</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;cbits&#39;</span><span class="p">)</span>
<span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">var_qubits</span><span class="p">,</span> <span class="n">clause_qubits</span><span class="p">,</span> <span class="n">output_qubit</span><span class="p">,</span> <span class="n">cbits</span><span class="p">)</span>

<span class="c1"># Initialise &#39;out0&#39; in state |-&gt;</span>
<span class="n">qc</span><span class="o">.</span><span class="n">initialize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">output_qubit</span><span class="p">)</span>

<span class="c1"># Initialise qubits in state |s&gt;</span>
<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">var_qubits</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>  <span class="c1"># for visual separation</span>

<span class="c1">## First Iteration</span>
<span class="c1"># Apply our oracle</span>
<span class="n">sudoku_oracle</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">clause_list</span><span class="p">,</span> <span class="n">clause_qubits</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>  <span class="c1"># for visual separation</span>
<span class="c1"># Apply our diffuser</span>
<span class="n">qc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diffuser</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>

<span class="c1">## Second Iteration</span>
<span class="n">sudoku_oracle</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">clause_list</span><span class="p">,</span> <span class="n">clause_qubits</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>  <span class="c1"># for visual separation</span>
<span class="c1"># Apply our diffuser</span>
<span class="n">qc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diffuser</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>

<span class="c1"># Measure the variable qubits</span>
<span class="n">qc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">var_qubits</span><span class="p">,</span> <span class="n">cbits</span><span class="p">)</span>

<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">fold</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_182_0.png" src="../../../_images/lab8-book_182_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Simulate and plot results</span>
<span class="n">qasm_simulator</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">)</span>
<span class="n">transpiled_qc</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">qasm_simulator</span><span class="p">)</span>
<span class="n">qobj</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">transpiled_qc</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">qasm_sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qobj</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">get_counts</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/lab8-book_183_0.png" src="../../../_images/lab8-book_183_0.png" />
</div>
</div>
<p>There are two bit strings with a much higher probability of measurement than any of the others, <code class="docutils literal notranslate"><span class="pre">0110</span></code> and <code class="docutils literal notranslate"><span class="pre">1001</span></code>. These correspond to the assignments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v0</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">v1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">v2</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">v3</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v0</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">v1</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">v2</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">v3</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>which are the two solutions to our sudoku! The aim of this section is to show how we can create Grover oracles from real problems. While this specific problem is trivial, the process can be applied (allowing large enough circuits) to any decision problem. To recap, the steps are:</p>
<ol class="simple">
<li><p>Create a reversible classical circuit that identifies a correct solution</p></li>
<li><p>Use phase kickback and uncomputation to turn this circuit into an oracle</p></li>
<li><p>Use Grover’s algorithm to solve this oracle</p></li>
</ol>
</div>
</div>
<div class="section" id="id12">
<h2>6. References <a id='references'></a><a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p>L. K. Grover (1996), “A fast quantum mechanical algorithm for database search”, Proceedings of the 28th Annual ACM Symposium on the Theory of Computing (STOC 1996), <a class="reference external" href="http://doi.acm.org/10.1145/237814.237866">doi:10.1145/237814.237866</a>, <a class="reference external" href="https://arxiv.org/abs/quant-ph/9605043">arXiv:quant-ph/9605043</a></p></li>
<li><p>C. Figgatt, D. Maslov, K. A. Landsman, N. M. Linke, S. Debnath &amp; C. Monroe (2017), “Complete 3-Qubit Grover search on a programmable quantum computer”, Nature Communications, Vol 8, Art 1918, <a class="reference external" href="https://doi.org/10.1038/s41467-017-01904-7">doi:10.1038/s41467-017-01904-7</a>, <a class="reference external" href="https://arxiv.org/abs/1703.10535">arXiv:1703.10535 </a></p></li>
<li><p>I. Chuang &amp; M. Nielsen, “Quantum Computation and Quantum Information”, Cambridge: Cambridge University Press, 2000.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">qiskit</span>
<span class="n">qiskit</span><span class="o">.</span><span class="n">__qiskit_version__</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;qiskit-terra&#39;: &#39;0.17.4&#39;, &#39;qiskit-aer&#39;: &#39;0.8.2&#39;, &#39;qiskit-ignis&#39;: &#39;0.6.0&#39;, &#39;qiskit-ibmq-provider&#39;: &#39;0.13.1&#39;, &#39;qiskit-aqua&#39;: &#39;0.9.1&#39;, &#39;qiskit&#39;: &#39;0.26.2&#39;, &#39;qiskit-nature&#39;: &#39;0.1.3&#39;, &#39;qiskit-finance&#39;: None, &#39;qiskit-optimization&#39;: &#39;0.1.0&#39;, &#39;qiskit-machine-learning&#39;: None}
</pre></div>
</div>
</div>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../../../_sources/PHYS343/hands-ons/hands-on-8/lab8-book.ipynb.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2021, Tüysüz, Cenk; Yenilen, Berat; Malcıoğlu, O. Barış.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>